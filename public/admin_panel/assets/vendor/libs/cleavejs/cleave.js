/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/cleavejs/cleave.js":
/*!*********************************!*\
  !*** ./libs/cleavejs/cleave.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cleave\": function() { return /* reexport module object */ cleave_js_dist_cleave__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var cleave_js_dist_cleave__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cleave.js/dist/cleave */ \"./node_modules/cleave.js/dist/cleave.js\");\n/* harmony import */ var cleave_js_dist_cleave__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cleave_js_dist_cleave__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL2NsZWF2ZWpzL2NsZWF2ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVzdC8uL2xpYnMvY2xlYXZlanMvY2xlYXZlLmpzP2QxNTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQ2xlYXZlIGZyb20gJ2NsZWF2ZS5qcy9kaXN0L2NsZWF2ZSc7XHJcblxyXG5leHBvcnQgeyBDbGVhdmUgfTtcclxuIl0sIm5hbWVzIjpbIkNsZWF2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/cleavejs/cleave.js\n");

/***/ }),

/***/ "./node_modules/cleave.js/dist/cleave.js":
/*!***********************************************!*\
  !*** ./node_modules/cleave.js/dist/cleave.js ***!
  \***********************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_527__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_527__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_527__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_527__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_527__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_527__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __nested_webpack_require_1728__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\n\t/**\n\t * Construct a new Cleave instance by passing the configuration object\n\t *\n\t * @param {String | HTMLElement} element\n\t * @param {Object} opts\n\t */\n\tvar Cleave = function (element, opts) {\n\t    var owner = this;\n\t    var hasMultipleElements = false;\n\n\t    if (typeof element === 'string') {\n\t        owner.element = document.querySelector(element);\n\t        hasMultipleElements = document.querySelectorAll(element).length > 1;\n\t    } else {\n\t      if (typeof element.length !== 'undefined' && element.length > 0) {\n\t        owner.element = element[0];\n\t        hasMultipleElements = element.length > 1;\n\t      } else {\n\t        owner.element = element;\n\t      }\n\t    }\n\n\t    if (!owner.element) {\n\t        throw new Error('[cleave.js] Please check the element');\n\t    }\n\n\t    if (hasMultipleElements) {\n\t      try {\n\t        // eslint-disable-next-line\n\t        console.warn('[cleave.js] Multiple input fields matched, cleave.js will only take the first one.');\n\t      } catch (e) {\n\t        // Old IE\n\t      }\n\t    }\n\n\t    opts.initValue = owner.element.value;\n\n\t    owner.properties = Cleave.DefaultProperties.assign({}, opts);\n\n\t    owner.init();\n\t};\n\n\tCleave.prototype = {\n\t    init: function () {\n\t        var owner = this, pps = owner.properties;\n\n\t        // no need to use this lib\n\t        if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && (pps.blocksLength === 0 && !pps.prefix)) {\n\t            owner.onInput(pps.initValue);\n\n\t            return;\n\t        }\n\n\t        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);\n\n\t        owner.isAndroid = Cleave.Util.isAndroid();\n\t        owner.lastInputValue = '';\n\t        owner.isBackward = '';\n\n\t        owner.onChangeListener = owner.onChange.bind(owner);\n\t        owner.onKeyDownListener = owner.onKeyDown.bind(owner);\n\t        owner.onFocusListener = owner.onFocus.bind(owner);\n\t        owner.onCutListener = owner.onCut.bind(owner);\n\t        owner.onCopyListener = owner.onCopy.bind(owner);\n\n\t        owner.initSwapHiddenInput();\n\n\t        owner.element.addEventListener('input', owner.onChangeListener);\n\t        owner.element.addEventListener('keydown', owner.onKeyDownListener);\n\t        owner.element.addEventListener('focus', owner.onFocusListener);\n\t        owner.element.addEventListener('cut', owner.onCutListener);\n\t        owner.element.addEventListener('copy', owner.onCopyListener);\n\n\n\t        owner.initPhoneFormatter();\n\t        owner.initDateFormatter();\n\t        owner.initTimeFormatter();\n\t        owner.initNumeralFormatter();\n\n\t        // avoid touch input field if value is null\n\t        // otherwise Firefox will add red box-shadow for <input required />\n\t        if (pps.initValue || (pps.prefix && !pps.noImmediatePrefix)) {\n\t            owner.onInput(pps.initValue);\n\t        }\n\t    },\n\n\t    initSwapHiddenInput: function () {\n\t        var owner = this, pps = owner.properties;\n\t        if (!pps.swapHiddenInput) return;\n\n\t        var inputFormatter = owner.element.cloneNode(true);\n\t        owner.element.parentNode.insertBefore(inputFormatter, owner.element);\n\n\t        owner.elementSwapHidden = owner.element;\n\t        owner.elementSwapHidden.type = 'hidden';\n\n\t        owner.element = inputFormatter;\n\t        owner.element.id = '';\n\t    },\n\n\t    initNumeralFormatter: function () {\n\t        var owner = this, pps = owner.properties;\n\n\t        if (!pps.numeral) {\n\t            return;\n\t        }\n\n\t        pps.numeralFormatter = new Cleave.NumeralFormatter(\n\t            pps.numeralDecimalMark,\n\t            pps.numeralIntegerScale,\n\t            pps.numeralDecimalScale,\n\t            pps.numeralThousandsGroupStyle,\n\t            pps.numeralPositiveOnly,\n\t            pps.stripLeadingZeroes,\n\t            pps.prefix,\n\t            pps.signBeforePrefix,\n\t            pps.tailPrefix,\n\t            pps.delimiter\n\t        );\n\t    },\n\n\t    initTimeFormatter: function() {\n\t        var owner = this, pps = owner.properties;\n\n\t        if (!pps.time) {\n\t            return;\n\t        }\n\n\t        pps.timeFormatter = new Cleave.TimeFormatter(pps.timePattern, pps.timeFormat);\n\t        pps.blocks = pps.timeFormatter.getBlocks();\n\t        pps.blocksLength = pps.blocks.length;\n\t        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);\n\t    },\n\n\t    initDateFormatter: function () {\n\t        var owner = this, pps = owner.properties;\n\n\t        if (!pps.date) {\n\t            return;\n\t        }\n\n\t        pps.dateFormatter = new Cleave.DateFormatter(pps.datePattern, pps.dateMin, pps.dateMax);\n\t        pps.blocks = pps.dateFormatter.getBlocks();\n\t        pps.blocksLength = pps.blocks.length;\n\t        pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);\n\t    },\n\n\t    initPhoneFormatter: function () {\n\t        var owner = this, pps = owner.properties;\n\n\t        if (!pps.phone) {\n\t            return;\n\t        }\n\n\t        // Cleave.AsYouTypeFormatter should be provided by\n\t        // external google closure lib\n\t        try {\n\t            pps.phoneFormatter = new Cleave.PhoneFormatter(\n\t                new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode),\n\t                pps.delimiter\n\t            );\n\t        } catch (ex) {\n\t            throw new Error('[cleave.js] Please include phone-type-formatter.{country}.js lib');\n\t        }\n\t    },\n\n\t    onKeyDown: function (event) {\n\t        var owner = this,\n\t            charCode = event.which || event.keyCode;\n\n\t        owner.lastInputValue = owner.element.value;\n\t        owner.isBackward = charCode === 8;\n\t    },\n\n\t    onChange: function (event) {\n\t        var owner = this, pps = owner.properties,\n\t            Util = Cleave.Util;\n\n\t        owner.isBackward = owner.isBackward || event.inputType === 'deleteContentBackward';\n\n\t        var postDelimiter = Util.getPostDelimiter(owner.lastInputValue, pps.delimiter, pps.delimiters);\n\n\t        if (owner.isBackward && postDelimiter) {\n\t            pps.postDelimiterBackspace = postDelimiter;\n\t        } else {\n\t            pps.postDelimiterBackspace = false;\n\t        }\n\n\t        this.onInput(this.element.value);\n\t    },\n\n\t    onFocus: function () {\n\t        var owner = this,\n\t            pps = owner.properties;\n\t        owner.lastInputValue = owner.element.value;\n\n\t        if (pps.prefix && pps.noImmediatePrefix && !owner.element.value) {\n\t            this.onInput(pps.prefix);\n\t        }\n\n\t        Cleave.Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);\n\t    },\n\n\t    onCut: function (e) {\n\t        if (!Cleave.Util.checkFullSelection(this.element.value)) return;\n\t        this.copyClipboardData(e);\n\t        this.onInput('');\n\t    },\n\n\t    onCopy: function (e) {\n\t        if (!Cleave.Util.checkFullSelection(this.element.value)) return;\n\t        this.copyClipboardData(e);\n\t    },\n\n\t    copyClipboardData: function (e) {\n\t        var owner = this,\n\t            pps = owner.properties,\n\t            Util = Cleave.Util,\n\t            inputValue = owner.element.value,\n\t            textToCopy = '';\n\n\t        if (!pps.copyDelimiter) {\n\t            textToCopy = Util.stripDelimiters(inputValue, pps.delimiter, pps.delimiters);\n\t        } else {\n\t            textToCopy = inputValue;\n\t        }\n\n\t        try {\n\t            if (e.clipboardData) {\n\t                e.clipboardData.setData('Text', textToCopy);\n\t            } else {\n\t                window.clipboardData.setData('Text', textToCopy);\n\t            }\n\n\t            e.preventDefault();\n\t        } catch (ex) {\n\t            //  empty\n\t        }\n\t    },\n\n\t    onInput: function (value) {\n\t        var owner = this, pps = owner.properties,\n\t            Util = Cleave.Util;\n\n\t        // case 1: delete one more character \"4\"\n\t        // 1234*| -> hit backspace -> 123|\n\t        // case 2: last character is not delimiter which is:\n\t        // 12|34* -> hit backspace -> 1|34*\n\t        // note: no need to apply this for numeral mode\n\t        var postDelimiterAfter = Util.getPostDelimiter(value, pps.delimiter, pps.delimiters);\n\t        if (!pps.numeral && pps.postDelimiterBackspace && !postDelimiterAfter) {\n\t            value = Util.headStr(value, value.length - pps.postDelimiterBackspace.length);\n\t        }\n\n\t        // phone formatter\n\t        if (pps.phone) {\n\t            if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {\n\t                pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);\n\t            } else {\n\t                pps.result = pps.phoneFormatter.format(value);\n\t            }\n\t            owner.updateValueState();\n\n\t            return;\n\t        }\n\n\t        // numeral formatter\n\t        if (pps.numeral) {\n\t            // Do not show prefix when noImmediatePrefix is specified\n\t            // This mostly because we need to show user the native input placeholder\n\t            if (pps.prefix && pps.noImmediatePrefix && value.length === 0) {\n\t                pps.result = '';\n\t            } else {\n\t                pps.result = pps.numeralFormatter.format(value);\n\t            }\n\t            owner.updateValueState();\n\n\t            return;\n\t        }\n\n\t        // date\n\t        if (pps.date) {\n\t            value = pps.dateFormatter.getValidatedDate(value);\n\t        }\n\n\t        // time\n\t        if (pps.time) {\n\t            value = pps.timeFormatter.getValidatedTime(value);\n\t        }\n\n\t        // strip delimiters\n\t        value = Util.stripDelimiters(value, pps.delimiter, pps.delimiters);\n\n\t        // strip prefix\n\t        value = Util.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);\n\n\t        // strip non-numeric characters\n\t        value = pps.numericOnly ? Util.strip(value, /[^\\d]/g) : value;\n\n\t        // convert case\n\t        value = pps.uppercase ? value.toUpperCase() : value;\n\t        value = pps.lowercase ? value.toLowerCase() : value;\n\n\t        // prevent from showing prefix when no immediate option enabled with empty input value\n\t        if (pps.prefix) {\n\t            if (pps.tailPrefix) {\n\t                value = value + pps.prefix;\n\t            } else {\n\t                value = pps.prefix + value;\n\t            }\n\n\n\t            // no blocks specified, no need to do formatting\n\t            if (pps.blocksLength === 0) {\n\t                pps.result = value;\n\t                owner.updateValueState();\n\n\t                return;\n\t            }\n\t        }\n\n\t        // update credit card props\n\t        if (pps.creditCard) {\n\t            owner.updateCreditCardPropsByValue(value);\n\t        }\n\n\t        // strip over length characters\n\t        value = Util.headStr(value, pps.maxLength);\n\n\t        // apply blocks\n\t        pps.result = Util.getFormattedValue(\n\t            value,\n\t            pps.blocks, pps.blocksLength,\n\t            pps.delimiter, pps.delimiters, pps.delimiterLazyShow\n\t        );\n\n\t        owner.updateValueState();\n\t    },\n\n\t    updateCreditCardPropsByValue: function (value) {\n\t        var owner = this, pps = owner.properties,\n\t            Util = Cleave.Util,\n\t            creditCardInfo;\n\n\t        // At least one of the first 4 characters has changed\n\t        if (Util.headStr(pps.result, 4) === Util.headStr(value, 4)) {\n\t            return;\n\t        }\n\n\t        creditCardInfo = Cleave.CreditCardDetector.getInfo(value, pps.creditCardStrictMode);\n\n\t        pps.blocks = creditCardInfo.blocks;\n\t        pps.blocksLength = pps.blocks.length;\n\t        pps.maxLength = Util.getMaxLength(pps.blocks);\n\n\t        // credit card type changed\n\t        if (pps.creditCardType !== creditCardInfo.type) {\n\t            pps.creditCardType = creditCardInfo.type;\n\n\t            pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);\n\t        }\n\t    },\n\n\t    updateValueState: function () {\n\t        var owner = this,\n\t            Util = Cleave.Util,\n\t            pps = owner.properties;\n\n\t        if (!owner.element) {\n\t            return;\n\t        }\n\n\t        var endPos = owner.element.selectionEnd;\n\t        var oldValue = owner.element.value;\n\t        var newValue = pps.result;\n\n\t        endPos = Util.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);\n\n\t        // fix Android browser type=\"text\" input field\n\t        // cursor not jumping issue\n\t        if (owner.isAndroid) {\n\t            window.setTimeout(function () {\n\t                owner.element.value = newValue;\n\t                Util.setSelection(owner.element, endPos, pps.document, false);\n\t                owner.callOnValueChanged();\n\t            }, 1);\n\n\t            return;\n\t        }\n\n\t        owner.element.value = newValue;\n\t        if (pps.swapHiddenInput) owner.elementSwapHidden.value = owner.getRawValue();\n\n\t        Util.setSelection(owner.element, endPos, pps.document, false);\n\t        owner.callOnValueChanged();\n\t    },\n\n\t    callOnValueChanged: function () {\n\t        var owner = this,\n\t            pps = owner.properties;\n\n\t        pps.onValueChanged.call(owner, {\n\t            target: {\n\t                name: owner.element.name,\n\t                value: pps.result,\n\t                rawValue: owner.getRawValue()\n\t            }\n\t        });\n\t    },\n\n\t    setPhoneRegionCode: function (phoneRegionCode) {\n\t        var owner = this, pps = owner.properties;\n\n\t        pps.phoneRegionCode = phoneRegionCode;\n\t        owner.initPhoneFormatter();\n\t        owner.onChange();\n\t    },\n\n\t    setRawValue: function (value) {\n\t        var owner = this, pps = owner.properties;\n\n\t        value = value !== undefined && value !== null ? value.toString() : '';\n\n\t        if (pps.numeral) {\n\t            value = value.replace('.', pps.numeralDecimalMark);\n\t        }\n\n\t        pps.postDelimiterBackspace = false;\n\n\t        owner.element.value = value;\n\t        owner.onInput(value);\n\t    },\n\n\t    getRawValue: function () {\n\t        var owner = this,\n\t            pps = owner.properties,\n\t            Util = Cleave.Util,\n\t            rawValue = owner.element.value;\n\n\t        if (pps.rawValueTrimPrefix) {\n\t            rawValue = Util.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);\n\t        }\n\n\t        if (pps.numeral) {\n\t            rawValue = pps.numeralFormatter.getRawValue(rawValue);\n\t        } else {\n\t            rawValue = Util.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);\n\t        }\n\n\t        return rawValue;\n\t    },\n\n\t    getISOFormatDate: function () {\n\t        var owner = this,\n\t            pps = owner.properties;\n\n\t        return pps.date ? pps.dateFormatter.getISOFormatDate() : '';\n\t    },\n\n\t    getISOFormatTime: function () {\n\t        var owner = this,\n\t            pps = owner.properties;\n\n\t        return pps.time ? pps.timeFormatter.getISOFormatTime() : '';\n\t    },\n\n\t    getFormattedValue: function () {\n\t        return this.element.value;\n\t    },\n\n\t    destroy: function () {\n\t        var owner = this;\n\n\t        owner.element.removeEventListener('input', owner.onChangeListener);\n\t        owner.element.removeEventListener('keydown', owner.onKeyDownListener);\n\t        owner.element.removeEventListener('focus', owner.onFocusListener);\n\t        owner.element.removeEventListener('cut', owner.onCutListener);\n\t        owner.element.removeEventListener('copy', owner.onCopyListener);\n\t    },\n\n\t    toString: function () {\n\t        return '[Cleave Object]';\n\t    }\n\t};\n\n\tCleave.NumeralFormatter = __nested_webpack_require_1728__(1);\n\tCleave.DateFormatter = __nested_webpack_require_1728__(2);\n\tCleave.TimeFormatter = __nested_webpack_require_1728__(3);\n\tCleave.PhoneFormatter = __nested_webpack_require_1728__(4);\n\tCleave.CreditCardDetector = __nested_webpack_require_1728__(5);\n\tCleave.Util = __nested_webpack_require_1728__(6);\n\tCleave.DefaultProperties = __nested_webpack_require_1728__(7);\n\n\t// for angular directive\n\t((typeof global === 'object' && global) ? global : window)['Cleave'] = Cleave;\n\n\t// CommonJS\n\tmodule.exports = Cleave;\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\tvar NumeralFormatter = function (numeralDecimalMark,\n\t                                 numeralIntegerScale,\n\t                                 numeralDecimalScale,\n\t                                 numeralThousandsGroupStyle,\n\t                                 numeralPositiveOnly,\n\t                                 stripLeadingZeroes,\n\t                                 prefix,\n\t                                 signBeforePrefix,\n\t                                 tailPrefix,\n\t                                 delimiter) {\n\t    var owner = this;\n\n\t    owner.numeralDecimalMark = numeralDecimalMark || '.';\n\t    owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;\n\t    owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;\n\t    owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;\n\t    owner.numeralPositiveOnly = !!numeralPositiveOnly;\n\t    owner.stripLeadingZeroes = stripLeadingZeroes !== false;\n\t    owner.prefix = (prefix || prefix === '') ? prefix : '';\n\t    owner.signBeforePrefix = !!signBeforePrefix;\n\t    owner.tailPrefix = !!tailPrefix;\n\t    owner.delimiter = (delimiter || delimiter === '') ? delimiter : ',';\n\t    owner.delimiterRE = delimiter ? new RegExp('\\\\' + delimiter, 'g') : '';\n\t};\n\n\tNumeralFormatter.groupStyle = {\n\t    thousand: 'thousand',\n\t    lakh:     'lakh',\n\t    wan:      'wan',\n\t    none:     'none'    \n\t};\n\n\tNumeralFormatter.prototype = {\n\t    getRawValue: function (value) {\n\t        return value.replace(this.delimiterRE, '').replace(this.numeralDecimalMark, '.');\n\t    },\n\n\t    format: function (value) {\n\t        var owner = this, parts, partSign, partSignAndPrefix, partInteger, partDecimal = '';\n\n\t        // strip alphabet letters\n\t        value = value.replace(/[A-Za-z]/g, '')\n\t            // replace the first decimal mark with reserved placeholder\n\t            .replace(owner.numeralDecimalMark, 'M')\n\n\t            // strip non numeric letters except minus and \"M\"\n\t            // this is to ensure prefix has been stripped\n\t            .replace(/[^\\dM-]/g, '')\n\n\t            // replace the leading minus with reserved placeholder\n\t            .replace(/^\\-/, 'N')\n\n\t            // strip the other minus sign (if present)\n\t            .replace(/\\-/g, '')\n\n\t            // replace the minus sign (if present)\n\t            .replace('N', owner.numeralPositiveOnly ? '' : '-')\n\n\t            // replace decimal mark\n\t            .replace('M', owner.numeralDecimalMark);\n\n\t        // strip any leading zeros\n\t        if (owner.stripLeadingZeroes) {\n\t            value = value.replace(/^(-)?0+(?=\\d)/, '$1');\n\t        }\n\n\t        partSign = value.slice(0, 1) === '-' ? '-' : '';\n\t        if (typeof owner.prefix != 'undefined') {\n\t            if (owner.signBeforePrefix) {\n\t                partSignAndPrefix = partSign + owner.prefix;\n\t            } else {\n\t                partSignAndPrefix = owner.prefix + partSign;\n\t            }\n\t        } else {\n\t            partSignAndPrefix = partSign;\n\t        }\n\t        \n\t        partInteger = value;\n\n\t        if (value.indexOf(owner.numeralDecimalMark) >= 0) {\n\t            parts = value.split(owner.numeralDecimalMark);\n\t            partInteger = parts[0];\n\t            partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);\n\t        }\n\n\t        if(partSign === '-') {\n\t            partInteger = partInteger.slice(1);\n\t        }\n\n\t        if (owner.numeralIntegerScale > 0) {\n\t          partInteger = partInteger.slice(0, owner.numeralIntegerScale);\n\t        }\n\n\t        switch (owner.numeralThousandsGroupStyle) {\n\t        case NumeralFormatter.groupStyle.lakh:\n\t            partInteger = partInteger.replace(/(\\d)(?=(\\d\\d)+\\d$)/g, '$1' + owner.delimiter);\n\n\t            break;\n\n\t        case NumeralFormatter.groupStyle.wan:\n\t            partInteger = partInteger.replace(/(\\d)(?=(\\d{4})+$)/g, '$1' + owner.delimiter);\n\n\t            break;\n\n\t        case NumeralFormatter.groupStyle.thousand:\n\t            partInteger = partInteger.replace(/(\\d)(?=(\\d{3})+$)/g, '$1' + owner.delimiter);\n\n\t            break;\n\t        }\n\n\t        if (owner.tailPrefix) {\n\t            return partSign + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : '') + owner.prefix;\n\t        }\n\n\t        return partSignAndPrefix + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : '');\n\t    }\n\t};\n\n\tmodule.exports = NumeralFormatter;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\tvar DateFormatter = function (datePattern, dateMin, dateMax) {\n\t    var owner = this;\n\n\t    owner.date = [];\n\t    owner.blocks = [];\n\t    owner.datePattern = datePattern;\n\t    owner.dateMin = dateMin\n\t      .split('-')\n\t      .reverse()\n\t      .map(function(x) {\n\t        return parseInt(x, 10);\n\t      });\n\t    if (owner.dateMin.length === 2) owner.dateMin.unshift(0);\n\n\t    owner.dateMax = dateMax\n\t      .split('-')\n\t      .reverse()\n\t      .map(function(x) {\n\t        return parseInt(x, 10);\n\t      });\n\t    if (owner.dateMax.length === 2) owner.dateMax.unshift(0);\n\t    \n\t    owner.initBlocks();\n\t};\n\n\tDateFormatter.prototype = {\n\t    initBlocks: function () {\n\t        var owner = this;\n\t        owner.datePattern.forEach(function (value) {\n\t            if (value === 'Y') {\n\t                owner.blocks.push(4);\n\t            } else {\n\t                owner.blocks.push(2);\n\t            }\n\t        });\n\t    },\n\n\t    getISOFormatDate: function () {\n\t        var owner = this,\n\t            date = owner.date;\n\n\t        return date[2] ? (\n\t            date[2] + '-' + owner.addLeadingZero(date[1]) + '-' + owner.addLeadingZero(date[0])\n\t        ) : '';\n\t    },\n\n\t    getBlocks: function () {\n\t        return this.blocks;\n\t    },\n\n\t    getValidatedDate: function (value) {\n\t        var owner = this, result = '';\n\n\t        value = value.replace(/[^\\d]/g, '');\n\n\t        owner.blocks.forEach(function (length, index) {\n\t            if (value.length > 0) {\n\t                var sub = value.slice(0, length),\n\t                    sub0 = sub.slice(0, 1),\n\t                    rest = value.slice(length);\n\n\t                switch (owner.datePattern[index]) {\n\t                case 'd':\n\t                    if (sub === '00') {\n\t                        sub = '01';\n\t                    } else if (parseInt(sub0, 10) > 3) {\n\t                        sub = '0' + sub0;\n\t                    } else if (parseInt(sub, 10) > 31) {\n\t                        sub = '31';\n\t                    }\n\n\t                    break;\n\n\t                case 'm':\n\t                    if (sub === '00') {\n\t                        sub = '01';\n\t                    } else if (parseInt(sub0, 10) > 1) {\n\t                        sub = '0' + sub0;\n\t                    } else if (parseInt(sub, 10) > 12) {\n\t                        sub = '12';\n\t                    }\n\n\t                    break;\n\t                }\n\n\t                result += sub;\n\n\t                // update remaining string\n\t                value = rest;\n\t            }\n\t        });\n\n\t        return this.getFixedDateString(result);\n\t    },\n\n\t    getFixedDateString: function (value) {\n\t        var owner = this, datePattern = owner.datePattern, date = [],\n\t            dayIndex = 0, monthIndex = 0, yearIndex = 0,\n\t            dayStartIndex = 0, monthStartIndex = 0, yearStartIndex = 0,\n\t            day, month, year, fullYearDone = false;\n\n\t        // mm-dd || dd-mm\n\t        if (value.length === 4 && datePattern[0].toLowerCase() !== 'y' && datePattern[1].toLowerCase() !== 'y') {\n\t            dayStartIndex = datePattern[0] === 'd' ? 0 : 2;\n\t            monthStartIndex = 2 - dayStartIndex;\n\t            day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);\n\t            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n\n\t            date = this.getFixedDate(day, month, 0);\n\t        }\n\n\t        // yyyy-mm-dd || yyyy-dd-mm || mm-dd-yyyy || dd-mm-yyyy || dd-yyyy-mm || mm-yyyy-dd\n\t        if (value.length === 8) {\n\t            datePattern.forEach(function (type, index) {\n\t                switch (type) {\n\t                case 'd':\n\t                    dayIndex = index;\n\t                    break;\n\t                case 'm':\n\t                    monthIndex = index;\n\t                    break;\n\t                default:\n\t                    yearIndex = index;\n\t                    break;\n\t                }\n\t            });\n\n\t            yearStartIndex = yearIndex * 2;\n\t            dayStartIndex = (dayIndex <= yearIndex) ? dayIndex * 2 : (dayIndex * 2 + 2);\n\t            monthStartIndex = (monthIndex <= yearIndex) ? monthIndex * 2 : (monthIndex * 2 + 2);\n\n\t            day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);\n\t            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n\t            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);\n\n\t            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;\n\n\t            date = this.getFixedDate(day, month, year);\n\t        }\n\n\t        // mm-yy || yy-mm\n\t        if (value.length === 4 && (datePattern[0] === 'y' || datePattern[1] === 'y')) {\n\t            monthStartIndex = datePattern[0] === 'm' ? 0 : 2;\n\t            yearStartIndex = 2 - monthStartIndex;\n\t            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n\t            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 2), 10);\n\n\t            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 2).length === 2;\n\n\t            date = [0, month, year];\n\t        }\n\n\t        // mm-yyyy || yyyy-mm\n\t        if (value.length === 6 && (datePattern[0] === 'Y' || datePattern[1] === 'Y')) {\n\t            monthStartIndex = datePattern[0] === 'm' ? 0 : 4;\n\t            yearStartIndex = 2 - 0.5 * monthStartIndex;\n\t            month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);\n\t            year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);\n\n\t            fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;\n\n\t            date = [0, month, year];\n\t        }\n\n\t        date = owner.getRangeFixedDate(date);\n\t        owner.date = date;\n\n\t        var result = date.length === 0 ? value : datePattern.reduce(function (previous, current) {\n\t            switch (current) {\n\t            case 'd':\n\t                return previous + (date[0] === 0 ? '' : owner.addLeadingZero(date[0]));\n\t            case 'm':\n\t                return previous + (date[1] === 0 ? '' : owner.addLeadingZero(date[1]));\n\t            case 'y':\n\t                return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], false) : '');\n\t            case 'Y':\n\t                return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], true) : '');\n\t            }\n\t        }, '');\n\n\t        return result;\n\t    },\n\n\t    getRangeFixedDate: function (date) {\n\t        var owner = this,\n\t            datePattern = owner.datePattern,\n\t            dateMin = owner.dateMin || [],\n\t            dateMax = owner.dateMax || [];\n\n\t        if (!date.length || (dateMin.length < 3 && dateMax.length < 3)) return date;\n\n\t        if (\n\t          datePattern.find(function(x) {\n\t            return x.toLowerCase() === 'y';\n\t          }) &&\n\t          date[2] === 0\n\t        ) return date;\n\n\t        if (dateMax.length && (dateMax[2] < date[2] || (\n\t          dateMax[2] === date[2] && (dateMax[1] < date[1] || (\n\t            dateMax[1] === date[1] && dateMax[0] < date[0]\n\t          ))\n\t        ))) return dateMax;\n\n\t        if (dateMin.length && (dateMin[2] > date[2] || (\n\t          dateMin[2] === date[2] && (dateMin[1] > date[1] || (\n\t            dateMin[1] === date[1] && dateMin[0] > date[0]\n\t          ))\n\t        ))) return dateMin;\n\n\t        return date;\n\t    },\n\n\t    getFixedDate: function (day, month, year) {\n\t        day = Math.min(day, 31);\n\t        month = Math.min(month, 12);\n\t        year = parseInt((year || 0), 10);\n\n\t        if ((month < 7 && month % 2 === 0) || (month > 8 && month % 2 === 1)) {\n\t            day = Math.min(day, month === 2 ? (this.isLeapYear(year) ? 29 : 28) : 30);\n\t        }\n\n\t        return [day, month, year];\n\t    },\n\n\t    isLeapYear: function (year) {\n\t        return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\n\t    },\n\n\t    addLeadingZero: function (number) {\n\t        return (number < 10 ? '0' : '') + number;\n\t    },\n\n\t    addLeadingZeroForYear: function (number, fullYearMode) {\n\t        if (fullYearMode) {\n\t            return (number < 10 ? '000' : (number < 100 ? '00' : (number < 1000 ? '0' : ''))) + number;\n\t        }\n\n\t        return (number < 10 ? '0' : '') + number;\n\t    }\n\t};\n\n\tmodule.exports = DateFormatter;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\tvar TimeFormatter = function (timePattern, timeFormat) {\n\t    var owner = this;\n\n\t    owner.time = [];\n\t    owner.blocks = [];\n\t    owner.timePattern = timePattern;\n\t    owner.timeFormat = timeFormat;\n\t    owner.initBlocks();\n\t};\n\n\tTimeFormatter.prototype = {\n\t    initBlocks: function () {\n\t        var owner = this;\n\t        owner.timePattern.forEach(function () {\n\t            owner.blocks.push(2);\n\t        });\n\t    },\n\n\t    getISOFormatTime: function () {\n\t        var owner = this,\n\t            time = owner.time;\n\n\t        return time[2] ? (\n\t            owner.addLeadingZero(time[0]) + ':' + owner.addLeadingZero(time[1]) + ':' + owner.addLeadingZero(time[2])\n\t        ) : '';\n\t    },\n\n\t    getBlocks: function () {\n\t        return this.blocks;\n\t    },\n\n\t    getTimeFormatOptions: function () {\n\t        var owner = this;\n\t        if (String(owner.timeFormat) === '12') {\n\t            return {\n\t                maxHourFirstDigit: 1,\n\t                maxHours: 12,\n\t                maxMinutesFirstDigit: 5,\n\t                maxMinutes: 60\n\t            };\n\t        }\n\n\t        return {\n\t            maxHourFirstDigit: 2,\n\t            maxHours: 23,\n\t            maxMinutesFirstDigit: 5,\n\t            maxMinutes: 60\n\t        };\n\t    },\n\n\t    getValidatedTime: function (value) {\n\t        var owner = this, result = '';\n\n\t        value = value.replace(/[^\\d]/g, '');\n\n\t        var timeFormatOptions = owner.getTimeFormatOptions();\n\n\t        owner.blocks.forEach(function (length, index) {\n\t            if (value.length > 0) {\n\t                var sub = value.slice(0, length),\n\t                    sub0 = sub.slice(0, 1),\n\t                    rest = value.slice(length);\n\n\t                switch (owner.timePattern[index]) {\n\n\t                case 'h':\n\t                    if (parseInt(sub0, 10) > timeFormatOptions.maxHourFirstDigit) {\n\t                        sub = '0' + sub0;\n\t                    } else if (parseInt(sub, 10) > timeFormatOptions.maxHours) {\n\t                        sub = timeFormatOptions.maxHours + '';\n\t                    }\n\n\t                    break;\n\n\t                case 'm':\n\t                case 's':\n\t                    if (parseInt(sub0, 10) > timeFormatOptions.maxMinutesFirstDigit) {\n\t                        sub = '0' + sub0;\n\t                    } else if (parseInt(sub, 10) > timeFormatOptions.maxMinutes) {\n\t                        sub = timeFormatOptions.maxMinutes + '';\n\t                    }\n\t                    break;\n\t                }\n\n\t                result += sub;\n\n\t                // update remaining string\n\t                value = rest;\n\t            }\n\t        });\n\n\t        return this.getFixedTimeString(result);\n\t    },\n\n\t    getFixedTimeString: function (value) {\n\t        var owner = this, timePattern = owner.timePattern, time = [],\n\t            secondIndex = 0, minuteIndex = 0, hourIndex = 0,\n\t            secondStartIndex = 0, minuteStartIndex = 0, hourStartIndex = 0,\n\t            second, minute, hour;\n\n\t        if (value.length === 6) {\n\t            timePattern.forEach(function (type, index) {\n\t                switch (type) {\n\t                case 's':\n\t                    secondIndex = index * 2;\n\t                    break;\n\t                case 'm':\n\t                    minuteIndex = index * 2;\n\t                    break;\n\t                case 'h':\n\t                    hourIndex = index * 2;\n\t                    break;\n\t                }\n\t            });\n\n\t            hourStartIndex = hourIndex;\n\t            minuteStartIndex = minuteIndex;\n\t            secondStartIndex = secondIndex;\n\n\t            second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);\n\t            minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);\n\t            hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);\n\n\t            time = this.getFixedTime(hour, minute, second);\n\t        }\n\n\t        if (value.length === 4 && owner.timePattern.indexOf('s') < 0) {\n\t            timePattern.forEach(function (type, index) {\n\t                switch (type) {\n\t                case 'm':\n\t                    minuteIndex = index * 2;\n\t                    break;\n\t                case 'h':\n\t                    hourIndex = index * 2;\n\t                    break;\n\t                }\n\t            });\n\n\t            hourStartIndex = hourIndex;\n\t            minuteStartIndex = minuteIndex;\n\n\t            second = 0;\n\t            minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);\n\t            hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);\n\n\t            time = this.getFixedTime(hour, minute, second);\n\t        }\n\n\t        owner.time = time;\n\n\t        return time.length === 0 ? value : timePattern.reduce(function (previous, current) {\n\t            switch (current) {\n\t            case 's':\n\t                return previous + owner.addLeadingZero(time[2]);\n\t            case 'm':\n\t                return previous + owner.addLeadingZero(time[1]);\n\t            case 'h':\n\t                return previous + owner.addLeadingZero(time[0]);\n\t            }\n\t        }, '');\n\t    },\n\n\t    getFixedTime: function (hour, minute, second) {\n\t        second = Math.min(parseInt(second || 0, 10), 60);\n\t        minute = Math.min(minute, 60);\n\t        hour = Math.min(hour, 60);\n\n\t        return [hour, minute, second];\n\t    },\n\n\t    addLeadingZero: function (number) {\n\t        return (number < 10 ? '0' : '') + number;\n\t    }\n\t};\n\n\tmodule.exports = TimeFormatter;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\tvar PhoneFormatter = function (formatter, delimiter) {\n\t    var owner = this;\n\n\t    owner.delimiter = (delimiter || delimiter === '') ? delimiter : ' ';\n\t    owner.delimiterRE = delimiter ? new RegExp('\\\\' + delimiter, 'g') : '';\n\n\t    owner.formatter = formatter;\n\t};\n\n\tPhoneFormatter.prototype = {\n\t    setFormatter: function (formatter) {\n\t        this.formatter = formatter;\n\t    },\n\n\t    format: function (phoneNumber) {\n\t        var owner = this;\n\n\t        owner.formatter.clear();\n\n\t        // only keep number and +\n\t        phoneNumber = phoneNumber.replace(/[^\\d+]/g, '');\n\n\t        // strip non-leading +\n\t        phoneNumber = phoneNumber.replace(/^\\+/, 'B').replace(/\\+/g, '').replace('B', '+');\n\n\t        // strip delimiter\n\t        phoneNumber = phoneNumber.replace(owner.delimiterRE, '');\n\n\t        var result = '', current, validated = false;\n\n\t        for (var i = 0, iMax = phoneNumber.length; i < iMax; i++) {\n\t            current = owner.formatter.inputDigit(phoneNumber.charAt(i));\n\n\t            // has ()- or space inside\n\t            if (/[\\s()-]/g.test(current)) {\n\t                result = current;\n\n\t                validated = true;\n\t            } else {\n\t                if (!validated) {\n\t                    result = current;\n\t                }\n\t                // else: over length input\n\t                // it turns to invalid number again\n\t            }\n\t        }\n\n\t        // strip ()\n\t        // e.g. US: 7161234567 returns (716) 123-4567\n\t        result = result.replace(/[()]/g, '');\n\t        // replace library delimiter with user customized delimiter\n\t        result = result.replace(/[\\s-]/g, owner.delimiter);\n\n\t        return result;\n\t    }\n\t};\n\n\tmodule.exports = PhoneFormatter;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\tvar CreditCardDetector = {\n\t    blocks: {\n\t        uatp:          [4, 5, 6],\n\t        amex:          [4, 6, 5],\n\t        diners:        [4, 6, 4],\n\t        discover:      [4, 4, 4, 4],\n\t        mastercard:    [4, 4, 4, 4],\n\t        dankort:       [4, 4, 4, 4],\n\t        instapayment:  [4, 4, 4, 4],\n\t        jcb15:         [4, 6, 5],\n\t        jcb:           [4, 4, 4, 4],\n\t        maestro:       [4, 4, 4, 4],\n\t        visa:          [4, 4, 4, 4],\n\t        mir:           [4, 4, 4, 4],\n\t        unionPay:      [4, 4, 4, 4],\n\t        general:       [4, 4, 4, 4]\n\t    },\n\n\t    re: {\n\t        // starts with 1; 15 digits, not starts with 1800 (jcb card)\n\t        uatp: /^(?!1800)1\\d{0,14}/,\n\n\t        // starts with 34/37; 15 digits\n\t        amex: /^3[47]\\d{0,13}/,\n\n\t        // starts with 6011/65/644-649; 16 digits\n\t        discover: /^(?:6011|65\\d{0,2}|64[4-9]\\d?)\\d{0,12}/,\n\n\t        // starts with 300-305/309 or 36/38/39; 14 digits\n\t        diners: /^3(?:0([0-5]|9)|[689]\\d?)\\d{0,11}/,\n\n\t        // starts with 51-55/2221â€“2720; 16 digits\n\t        mastercard: /^(5[1-5]\\d{0,2}|22[2-9]\\d{0,1}|2[3-7]\\d{0,2})\\d{0,12}/,\n\n\t        // starts with 5019/4175/4571; 16 digits\n\t        dankort: /^(5019|4175|4571)\\d{0,12}/,\n\n\t        // starts with 637-639; 16 digits\n\t        instapayment: /^63[7-9]\\d{0,13}/,\n\n\t        // starts with 2131/1800; 15 digits\n\t        jcb15: /^(?:2131|1800)\\d{0,11}/,\n\n\t        // starts with 2131/1800/35; 16 digits\n\t        jcb: /^(?:35\\d{0,2})\\d{0,12}/,\n\n\t        // starts with 50/56-58/6304/67; 16 digits\n\t        maestro: /^(?:5[0678]\\d{0,2}|6304|67\\d{0,2})\\d{0,12}/,\n\n\t        // starts with 22; 16 digits\n\t        mir: /^220[0-4]\\d{0,12}/,\n\n\t        // starts with 4; 16 digits\n\t        visa: /^4\\d{0,15}/,\n\n\t        // starts with 62/81; 16 digits\n\t        unionPay: /^(62|81)\\d{0,14}/\n\t    },\n\n\t    getStrictBlocks: function (block) {\n\t      var total = block.reduce(function (prev, current) {\n\t        return prev + current;\n\t      }, 0);\n\n\t      return block.concat(19 - total);\n\t    },\n\n\t    getInfo: function (value, strictMode) {\n\t        var blocks = CreditCardDetector.blocks,\n\t            re = CreditCardDetector.re;\n\n\t        // Some credit card can have up to 19 digits number.\n\t        // Set strictMode to true will remove the 16 max-length restrain,\n\t        // however, I never found any website validate card number like\n\t        // this, hence probably you don't want to enable this option.\n\t        strictMode = !!strictMode;\n\n\t        for (var key in re) {\n\t            if (re[key].test(value)) {\n\t                var matchedBlocks = blocks[key];\n\t                return {\n\t                    type: key,\n\t                    blocks: strictMode ? this.getStrictBlocks(matchedBlocks) : matchedBlocks\n\t                };\n\t            }\n\t        }\n\n\t        return {\n\t            type: 'unknown',\n\t            blocks: strictMode ? this.getStrictBlocks(blocks.general) : blocks.general\n\t        };\n\t    }\n\t};\n\n\tmodule.exports = CreditCardDetector;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\tvar Util = {\n\t    noop: function () {\n\t    },\n\n\t    strip: function (value, re) {\n\t        return value.replace(re, '');\n\t    },\n\n\t    getPostDelimiter: function (value, delimiter, delimiters) {\n\t        // single delimiter\n\t        if (delimiters.length === 0) {\n\t            return value.slice(-delimiter.length) === delimiter ? delimiter : '';\n\t        }\n\n\t        // multiple delimiters\n\t        var matchedDelimiter = '';\n\t        delimiters.forEach(function (current) {\n\t            if (value.slice(-current.length) === current) {\n\t                matchedDelimiter = current;\n\t            }\n\t        });\n\n\t        return matchedDelimiter;\n\t    },\n\n\t    getDelimiterREByDelimiter: function (delimiter) {\n\t        return new RegExp(delimiter.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1'), 'g');\n\t    },\n\n\t    getNextCursorPosition: function (prevPos, oldValue, newValue, delimiter, delimiters) {\n\t      // If cursor was at the end of value, just place it back.\n\t      // Because new value could contain additional chars.\n\t      if (oldValue.length === prevPos) {\n\t          return newValue.length;\n\t      }\n\n\t      return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter ,delimiters);\n\t    },\n\n\t    getPositionOffset: function (prevPos, oldValue, newValue, delimiter, delimiters) {\n\t        var oldRawValue, newRawValue, lengthOffset;\n\n\t        oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);\n\t        newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);\n\t        lengthOffset = oldRawValue.length - newRawValue.length;\n\n\t        return (lengthOffset !== 0) ? (lengthOffset / Math.abs(lengthOffset)) : 0;\n\t    },\n\n\t    stripDelimiters: function (value, delimiter, delimiters) {\n\t        var owner = this;\n\n\t        // single delimiter\n\t        if (delimiters.length === 0) {\n\t            var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : '';\n\n\t            return value.replace(delimiterRE, '');\n\t        }\n\n\t        // multiple delimiters\n\t        delimiters.forEach(function (current) {\n\t            current.split('').forEach(function (letter) {\n\t                value = value.replace(owner.getDelimiterREByDelimiter(letter), '');\n\t            });\n\t        });\n\n\t        return value;\n\t    },\n\n\t    headStr: function (str, length) {\n\t        return str.slice(0, length);\n\t    },\n\n\t    getMaxLength: function (blocks) {\n\t        return blocks.reduce(function (previous, current) {\n\t            return previous + current;\n\t        }, 0);\n\t    },\n\n\t    // strip prefix\n\t    // Before type  |   After type    |     Return value\n\t    // PEFIX-...    |   PEFIX-...     |     ''\n\t    // PREFIX-123   |   PEFIX-123     |     123\n\t    // PREFIX-123   |   PREFIX-23     |     23\n\t    // PREFIX-123   |   PREFIX-1234   |     1234\n\t    getPrefixStrippedValue: function (value, prefix, prefixLength, prevResult, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix) {\n\t        // No prefix\n\t        if (prefixLength === 0) {\n\t          return value;\n\t        }\n\n\t        // Value is prefix\n\t        if (value === prefix && value !== '') {\n\t          return '';\n\t        }\n\n\t        if (signBeforePrefix && (value.slice(0, 1) == '-')) {\n\t            var prev = (prevResult.slice(0, 1) == '-') ? prevResult.slice(1) : prevResult;\n\t            return '-' + this.getPrefixStrippedValue(value.slice(1), prefix, prefixLength, prev, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix);\n\t        }\n\n\t        // Pre result prefix string does not match pre-defined prefix\n\t        if (prevResult.slice(0, prefixLength) !== prefix && !tailPrefix) {\n\t            // Check if the first time user entered something\n\t            if (noImmediatePrefix && !prevResult && value) return value;\n\t            return '';\n\t        } else if (prevResult.slice(-prefixLength) !== prefix && tailPrefix) {\n\t            // Check if the first time user entered something\n\t            if (noImmediatePrefix && !prevResult && value) return value;\n\t            return '';\n\t        }\n\n\t        var prevValue = this.stripDelimiters(prevResult, delimiter, delimiters);\n\n\t        // New value has issue, someone typed in between prefix letters\n\t        // Revert to pre value\n\t        if (value.slice(0, prefixLength) !== prefix && !tailPrefix) {\n\t            return prevValue.slice(prefixLength);\n\t        } else if (value.slice(-prefixLength) !== prefix && tailPrefix) {\n\t            return prevValue.slice(0, -prefixLength - 1);\n\t        }\n\n\t        // No issue, strip prefix for new value\n\t        return tailPrefix ? value.slice(0, -prefixLength) : value.slice(prefixLength);\n\t    },\n\n\t    getFirstDiffIndex: function (prev, current) {\n\t        var index = 0;\n\n\t        while (prev.charAt(index) === current.charAt(index)) {\n\t            if (prev.charAt(index++) === '') {\n\t                return -1;\n\t            }\n\t        }\n\n\t        return index;\n\t    },\n\n\t    getFormattedValue: function (value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {\n\t        var result = '',\n\t            multipleDelimiters = delimiters.length > 0,\n\t            currentDelimiter = '';\n\n\t        // no options, normal input\n\t        if (blocksLength === 0) {\n\t            return value;\n\t        }\n\n\t        blocks.forEach(function (length, index) {\n\t            if (value.length > 0) {\n\t                var sub = value.slice(0, length),\n\t                    rest = value.slice(length);\n\n\t                if (multipleDelimiters) {\n\t                    currentDelimiter = delimiters[delimiterLazyShow ? (index - 1) : index] || currentDelimiter;\n\t                } else {\n\t                    currentDelimiter = delimiter;\n\t                }\n\n\t                if (delimiterLazyShow) {\n\t                    if (index > 0) {\n\t                        result += currentDelimiter;\n\t                    }\n\n\t                    result += sub;\n\t                } else {\n\t                    result += sub;\n\n\t                    if (sub.length === length && index < blocksLength - 1) {\n\t                        result += currentDelimiter;\n\t                    }\n\t                }\n\n\t                // update remaining string\n\t                value = rest;\n\t            }\n\t        });\n\n\t        return result;\n\t    },\n\n\t    // move cursor to the end\n\t    // the first time user focuses on an input with prefix\n\t    fixPrefixCursor: function (el, prefix, delimiter, delimiters) {\n\t        if (!el) {\n\t            return;\n\t        }\n\n\t        var val = el.value,\n\t            appendix = delimiter || (delimiters[0] || ' ');\n\n\t        if (!el.setSelectionRange || !prefix || (prefix.length + appendix.length) <= val.length) {\n\t            return;\n\t        }\n\n\t        var len = val.length * 2;\n\n\t        // set timeout to avoid blink\n\t        setTimeout(function () {\n\t            el.setSelectionRange(len, len);\n\t        }, 1);\n\t    },\n\n\t    // Check if input field is fully selected\n\t    checkFullSelection: function(value) {\n\t      try {\n\t        var selection = window.getSelection() || document.getSelection() || {};\n\t        return selection.toString().length === value.length;\n\t      } catch (ex) {\n\t        // Ignore\n\t      }\n\n\t      return false;\n\t    },\n\n\t    setSelection: function (element, position, doc) {\n\t        if (element !== this.getActiveElement(doc)) {\n\t            return;\n\t        }\n\n\t        // cursor is already in the end\n\t        if (element && element.value.length <= position) {\n\t          return;\n\t        }\n\n\t        if (element.createTextRange) {\n\t            var range = element.createTextRange();\n\n\t            range.move('character', position);\n\t            range.select();\n\t        } else {\n\t            try {\n\t                element.setSelectionRange(position, position);\n\t            } catch (e) {\n\t                // eslint-disable-next-line\n\t                console.warn('The input element type does not support selection');\n\t            }\n\t        }\n\t    },\n\n\t    getActiveElement: function(parent) {\n\t        var activeElement = parent.activeElement;\n\t        if (activeElement && activeElement.shadowRoot) {\n\t            return this.getActiveElement(activeElement.shadowRoot);\n\t        }\n\t        return activeElement;\n\t    },\n\n\t    isAndroid: function () {\n\t        return navigator && /android/i.test(navigator.userAgent);\n\t    },\n\n\t    // On Android chrome, the keyup and keydown events\n\t    // always return key code 229 as a composition that\n\t    // buffers the userâ€™s keystrokes\n\t    // see https://github.com/nosir/cleave.js/issues/147\n\t    isAndroidBackspaceKeydown: function (lastInputValue, currentInputValue) {\n\t        if (!this.isAndroid() || !lastInputValue || !currentInputValue) {\n\t            return false;\n\t        }\n\n\t        return currentInputValue === lastInputValue.slice(0, -1);\n\t    }\n\t};\n\n\tmodule.exports = Util;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\n\t/**\n\t * Props Assignment\n\t *\n\t * Separate this, so react module can share the usage\n\t */\n\tvar DefaultProperties = {\n\t    // Maybe change to object-assign\n\t    // for now just keep it as simple\n\t    assign: function (target, opts) {\n\t        target = target || {};\n\t        opts = opts || {};\n\n\t        // credit card\n\t        target.creditCard = !!opts.creditCard;\n\t        target.creditCardStrictMode = !!opts.creditCardStrictMode;\n\t        target.creditCardType = '';\n\t        target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || (function () {});\n\n\t        // phone\n\t        target.phone = !!opts.phone;\n\t        target.phoneRegionCode = opts.phoneRegionCode || 'AU';\n\t        target.phoneFormatter = {};\n\n\t        // time\n\t        target.time = !!opts.time;\n\t        target.timePattern = opts.timePattern || ['h', 'm', 's'];\n\t        target.timeFormat = opts.timeFormat || '24';\n\t        target.timeFormatter = {};\n\n\t        // date\n\t        target.date = !!opts.date;\n\t        target.datePattern = opts.datePattern || ['d', 'm', 'Y'];\n\t        target.dateMin = opts.dateMin || '';\n\t        target.dateMax = opts.dateMax || '';\n\t        target.dateFormatter = {};\n\n\t        // numeral\n\t        target.numeral = !!opts.numeral;\n\t        target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;\n\t        target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;\n\t        target.numeralDecimalMark = opts.numeralDecimalMark || '.';\n\t        target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || 'thousand';\n\t        target.numeralPositiveOnly = !!opts.numeralPositiveOnly;\n\t        target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;\n\t        target.signBeforePrefix = !!opts.signBeforePrefix;\n\t        target.tailPrefix = !!opts.tailPrefix;\n\n\t        // others\n\t        target.swapHiddenInput = !!opts.swapHiddenInput;\n\t        \n\t        target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;\n\n\t        target.uppercase = !!opts.uppercase;\n\t        target.lowercase = !!opts.lowercase;\n\n\t        target.prefix = (target.creditCard || target.date) ? '' : (opts.prefix || '');\n\t        target.noImmediatePrefix = !!opts.noImmediatePrefix;\n\t        target.prefixLength = target.prefix.length;\n\t        target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;\n\t        target.copyDelimiter = !!opts.copyDelimiter;\n\n\t        target.initValue = (opts.initValue !== undefined && opts.initValue !== null) ? opts.initValue.toString() : '';\n\n\t        target.delimiter =\n\t            (opts.delimiter || opts.delimiter === '') ? opts.delimiter :\n\t                (opts.date ? '/' :\n\t                    (opts.time ? ':' :\n\t                        (opts.numeral ? ',' :\n\t                            (opts.phone ? ' ' :\n\t                                ' '))));\n\t        target.delimiterLength = target.delimiter.length;\n\t        target.delimiterLazyShow = !!opts.delimiterLazyShow;\n\t        target.delimiters = opts.delimiters || [];\n\n\t        target.blocks = opts.blocks || [];\n\t        target.blocksLength = target.blocks.length;\n\n\t        target.root = (typeof global === 'object' && global) ? global : window;\n\t        target.document = opts.document || target.root.document;\n\n\t        target.maxLength = 0;\n\n\t        target.backspace = false;\n\t        target.result = '';\n\n\t        target.onValueChanged = opts.onValueChanged || (function () {});\n\n\t        return target;\n\t    }\n\t};\n\n\tmodule.exports = DefaultProperties;\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ })\n/******/ ])\n});\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2xlYXZlLmpzL2Rpc3QvY2xlYXZlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLdUI7QUFDN0IsQ0FBQztBQUNELHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDhCQUFtQjs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLDhCQUFtQjs7QUFFN0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVSw4QkFBbUI7O0FBRTdCO0FBQ0EsVUFBVSw4QkFBbUI7O0FBRTdCO0FBQ0EsVUFBVSw4QkFBbUI7O0FBRTdCO0FBQ0EsaUJBQWlCLDhCQUFtQjtBQUNwQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtCQUFtQjs7QUFFcEQsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwREFBMEQ7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLCtFQUErRSxRQUFRO0FBQ3ZGO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsK0JBQW1CO0FBQzlDLHdCQUF3QiwrQkFBbUI7QUFDM0Msd0JBQXdCLCtCQUFtQjtBQUMzQyx5QkFBeUIsK0JBQW1CO0FBQzVDLDZCQUE2QiwrQkFBbUI7QUFDaEQsZUFBZSwrQkFBbUI7QUFDbEMsNEJBQTRCLCtCQUFtQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2Qiw2QkFBNkIsY0FBYzs7QUFFeEUsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyREFBMkQsRUFBRTs7QUFFN0Q7O0FBRUE7QUFDQSwyREFBMkQsRUFBRTs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9EQUFvRCxVQUFVO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsMkJBQTJCO0FBQzNCLDZCQUE2QixLQUFLOztBQUVsQywrQkFBK0I7QUFDL0IseUJBQXlCLEtBQUs7O0FBRTlCLHlDQUF5QztBQUN6QyxrQ0FBa0MsSUFBSSxlQUFlLEtBQUs7O0FBRTFELGlEQUFpRDtBQUNqRCw4Q0FBOEMsS0FBSzs7QUFFbkQseUNBQXlDO0FBQ3pDLGlDQUFpQyxJQUFJLFdBQVcsSUFBSSxVQUFVLElBQUksSUFBSSxLQUFLOztBQUUzRSx3Q0FBd0M7QUFDeEMsdUNBQXVDLEtBQUs7O0FBRTVDLGlDQUFpQztBQUNqQyxtQ0FBbUMsS0FBSzs7QUFFeEMsbUNBQW1DO0FBQ25DLGtDQUFrQyxLQUFLOztBQUV2QyxzQ0FBc0M7QUFDdEMsd0JBQXdCLElBQUksSUFBSSxLQUFLOztBQUVyQywwQ0FBMEM7QUFDMUMsaUNBQWlDLElBQUksV0FBVyxJQUFJLElBQUksS0FBSzs7QUFFN0QsNEJBQTRCO0FBQzVCLDJCQUEyQixLQUFLOztBQUVoQywyQkFBMkI7QUFDM0IscUJBQXFCLEtBQUs7O0FBRTFCLCtCQUErQjtBQUMvQiwrQkFBK0IsS0FBSztBQUNwQyxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLE1BQU07O0FBRU47QUFDQSwrREFBK0Q7QUFDL0QsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7O0FBRVY7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7O0FBRXpGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1RUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkIsNkJBQTZCLGNBQWM7O0FBRXhFLE9BQU87QUFDUDtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZXN0Ly4vbm9kZV9tb2R1bGVzL2NsZWF2ZS5qcy9kaXN0L2NsZWF2ZS5qcz9hMjE2Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkNsZWF2ZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJDbGVhdmVcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdCBhIG5ldyBDbGVhdmUgaW5zdGFuY2UgYnkgcGFzc2luZyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3Rcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBIVE1MRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuXHQgKi9cblx0dmFyIENsZWF2ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRzKSB7XG5cdCAgICB2YXIgb3duZXIgPSB0aGlzO1xuXHQgICAgdmFyIGhhc011bHRpcGxlRWxlbWVudHMgPSBmYWxzZTtcblxuXHQgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIG93bmVyLmVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpO1xuXHQgICAgICAgIGhhc011bHRpcGxlRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnQpLmxlbmd0aCA+IDE7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAodHlwZW9mIGVsZW1lbnQubGVuZ3RoICE9PSAndW5kZWZpbmVkJyAmJiBlbGVtZW50Lmxlbmd0aCA+IDApIHtcblx0ICAgICAgICBvd25lci5lbGVtZW50ID0gZWxlbWVudFswXTtcblx0ICAgICAgICBoYXNNdWx0aXBsZUVsZW1lbnRzID0gZWxlbWVudC5sZW5ndGggPiAxO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIG93bmVyLmVsZW1lbnQgPSBlbGVtZW50O1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICghb3duZXIuZWxlbWVudCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignW2NsZWF2ZS5qc10gUGxlYXNlIGNoZWNrIHRoZSBlbGVtZW50Jyk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChoYXNNdWx0aXBsZUVsZW1lbnRzKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cdCAgICAgICAgY29uc29sZS53YXJuKCdbY2xlYXZlLmpzXSBNdWx0aXBsZSBpbnB1dCBmaWVsZHMgbWF0Y2hlZCwgY2xlYXZlLmpzIHdpbGwgb25seSB0YWtlIHRoZSBmaXJzdCBvbmUuJyk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAvLyBPbGQgSUVcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBvcHRzLmluaXRWYWx1ZSA9IG93bmVyLmVsZW1lbnQudmFsdWU7XG5cblx0ICAgIG93bmVyLnByb3BlcnRpZXMgPSBDbGVhdmUuRGVmYXVsdFByb3BlcnRpZXMuYXNzaWduKHt9LCBvcHRzKTtcblxuXHQgICAgb3duZXIuaW5pdCgpO1xuXHR9O1xuXG5cdENsZWF2ZS5wcm90b3R5cGUgPSB7XG5cdCAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcywgcHBzID0gb3duZXIucHJvcGVydGllcztcblxuXHQgICAgICAgIC8vIG5vIG5lZWQgdG8gdXNlIHRoaXMgbGliXG5cdCAgICAgICAgaWYgKCFwcHMubnVtZXJhbCAmJiAhcHBzLnBob25lICYmICFwcHMuY3JlZGl0Q2FyZCAmJiAhcHBzLnRpbWUgJiYgIXBwcy5kYXRlICYmIChwcHMuYmxvY2tzTGVuZ3RoID09PSAwICYmICFwcHMucHJlZml4KSkge1xuXHQgICAgICAgICAgICBvd25lci5vbklucHV0KHBwcy5pbml0VmFsdWUpO1xuXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwcHMubWF4TGVuZ3RoID0gQ2xlYXZlLlV0aWwuZ2V0TWF4TGVuZ3RoKHBwcy5ibG9ja3MpO1xuXG5cdCAgICAgICAgb3duZXIuaXNBbmRyb2lkID0gQ2xlYXZlLlV0aWwuaXNBbmRyb2lkKCk7XG5cdCAgICAgICAgb3duZXIubGFzdElucHV0VmFsdWUgPSAnJztcblx0ICAgICAgICBvd25lci5pc0JhY2t3YXJkID0gJyc7XG5cblx0ICAgICAgICBvd25lci5vbkNoYW5nZUxpc3RlbmVyID0gb3duZXIub25DaGFuZ2UuYmluZChvd25lcik7XG5cdCAgICAgICAgb3duZXIub25LZXlEb3duTGlzdGVuZXIgPSBvd25lci5vbktleURvd24uYmluZChvd25lcik7XG5cdCAgICAgICAgb3duZXIub25Gb2N1c0xpc3RlbmVyID0gb3duZXIub25Gb2N1cy5iaW5kKG93bmVyKTtcblx0ICAgICAgICBvd25lci5vbkN1dExpc3RlbmVyID0gb3duZXIub25DdXQuYmluZChvd25lcik7XG5cdCAgICAgICAgb3duZXIub25Db3B5TGlzdGVuZXIgPSBvd25lci5vbkNvcHkuYmluZChvd25lcik7XG5cblx0ICAgICAgICBvd25lci5pbml0U3dhcEhpZGRlbklucHV0KCk7XG5cblx0ICAgICAgICBvd25lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0Jywgb3duZXIub25DaGFuZ2VMaXN0ZW5lcik7XG5cdCAgICAgICAgb3duZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb3duZXIub25LZXlEb3duTGlzdGVuZXIpO1xuXHQgICAgICAgIG93bmVyLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBvd25lci5vbkZvY3VzTGlzdGVuZXIpO1xuXHQgICAgICAgIG93bmVyLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY3V0Jywgb3duZXIub25DdXRMaXN0ZW5lcik7XG5cdCAgICAgICAgb3duZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb3B5Jywgb3duZXIub25Db3B5TGlzdGVuZXIpO1xuXG5cblx0ICAgICAgICBvd25lci5pbml0UGhvbmVGb3JtYXR0ZXIoKTtcblx0ICAgICAgICBvd25lci5pbml0RGF0ZUZvcm1hdHRlcigpO1xuXHQgICAgICAgIG93bmVyLmluaXRUaW1lRm9ybWF0dGVyKCk7XG5cdCAgICAgICAgb3duZXIuaW5pdE51bWVyYWxGb3JtYXR0ZXIoKTtcblxuXHQgICAgICAgIC8vIGF2b2lkIHRvdWNoIGlucHV0IGZpZWxkIGlmIHZhbHVlIGlzIG51bGxcblx0ICAgICAgICAvLyBvdGhlcndpc2UgRmlyZWZveCB3aWxsIGFkZCByZWQgYm94LXNoYWRvdyBmb3IgPGlucHV0IHJlcXVpcmVkIC8+XG5cdCAgICAgICAgaWYgKHBwcy5pbml0VmFsdWUgfHwgKHBwcy5wcmVmaXggJiYgIXBwcy5ub0ltbWVkaWF0ZVByZWZpeCkpIHtcblx0ICAgICAgICAgICAgb3duZXIub25JbnB1dChwcHMuaW5pdFZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICB9LFxuXG5cdCAgICBpbml0U3dhcEhpZGRlbklucHV0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcywgcHBzID0gb3duZXIucHJvcGVydGllcztcblx0ICAgICAgICBpZiAoIXBwcy5zd2FwSGlkZGVuSW5wdXQpIHJldHVybjtcblxuXHQgICAgICAgIHZhciBpbnB1dEZvcm1hdHRlciA9IG93bmVyLmVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuXHQgICAgICAgIG93bmVyLmVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5wdXRGb3JtYXR0ZXIsIG93bmVyLmVsZW1lbnQpO1xuXG5cdCAgICAgICAgb3duZXIuZWxlbWVudFN3YXBIaWRkZW4gPSBvd25lci5lbGVtZW50O1xuXHQgICAgICAgIG93bmVyLmVsZW1lbnRTd2FwSGlkZGVuLnR5cGUgPSAnaGlkZGVuJztcblxuXHQgICAgICAgIG93bmVyLmVsZW1lbnQgPSBpbnB1dEZvcm1hdHRlcjtcblx0ICAgICAgICBvd25lci5lbGVtZW50LmlkID0gJyc7XG5cdCAgICB9LFxuXG5cdCAgICBpbml0TnVtZXJhbEZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cblx0ICAgICAgICBpZiAoIXBwcy5udW1lcmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwcHMubnVtZXJhbEZvcm1hdHRlciA9IG5ldyBDbGVhdmUuTnVtZXJhbEZvcm1hdHRlcihcblx0ICAgICAgICAgICAgcHBzLm51bWVyYWxEZWNpbWFsTWFyayxcblx0ICAgICAgICAgICAgcHBzLm51bWVyYWxJbnRlZ2VyU2NhbGUsXG5cdCAgICAgICAgICAgIHBwcy5udW1lcmFsRGVjaW1hbFNjYWxlLFxuXHQgICAgICAgICAgICBwcHMubnVtZXJhbFRob3VzYW5kc0dyb3VwU3R5bGUsXG5cdCAgICAgICAgICAgIHBwcy5udW1lcmFsUG9zaXRpdmVPbmx5LFxuXHQgICAgICAgICAgICBwcHMuc3RyaXBMZWFkaW5nWmVyb2VzLFxuXHQgICAgICAgICAgICBwcHMucHJlZml4LFxuXHQgICAgICAgICAgICBwcHMuc2lnbkJlZm9yZVByZWZpeCxcblx0ICAgICAgICAgICAgcHBzLnRhaWxQcmVmaXgsXG5cdCAgICAgICAgICAgIHBwcy5kZWxpbWl0ZXJcblx0ICAgICAgICApO1xuXHQgICAgfSxcblxuXHQgICAgaW5pdFRpbWVGb3JtYXR0ZXI6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cblx0ICAgICAgICBpZiAoIXBwcy50aW1lKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwcHMudGltZUZvcm1hdHRlciA9IG5ldyBDbGVhdmUuVGltZUZvcm1hdHRlcihwcHMudGltZVBhdHRlcm4sIHBwcy50aW1lRm9ybWF0KTtcblx0ICAgICAgICBwcHMuYmxvY2tzID0gcHBzLnRpbWVGb3JtYXR0ZXIuZ2V0QmxvY2tzKCk7XG5cdCAgICAgICAgcHBzLmJsb2Nrc0xlbmd0aCA9IHBwcy5ibG9ja3MubGVuZ3RoO1xuXHQgICAgICAgIHBwcy5tYXhMZW5ndGggPSBDbGVhdmUuVXRpbC5nZXRNYXhMZW5ndGgocHBzLmJsb2Nrcyk7XG5cdCAgICB9LFxuXG5cdCAgICBpbml0RGF0ZUZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cblx0ICAgICAgICBpZiAoIXBwcy5kYXRlKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwcHMuZGF0ZUZvcm1hdHRlciA9IG5ldyBDbGVhdmUuRGF0ZUZvcm1hdHRlcihwcHMuZGF0ZVBhdHRlcm4sIHBwcy5kYXRlTWluLCBwcHMuZGF0ZU1heCk7XG5cdCAgICAgICAgcHBzLmJsb2NrcyA9IHBwcy5kYXRlRm9ybWF0dGVyLmdldEJsb2NrcygpO1xuXHQgICAgICAgIHBwcy5ibG9ja3NMZW5ndGggPSBwcHMuYmxvY2tzLmxlbmd0aDtcblx0ICAgICAgICBwcHMubWF4TGVuZ3RoID0gQ2xlYXZlLlV0aWwuZ2V0TWF4TGVuZ3RoKHBwcy5ibG9ja3MpO1xuXHQgICAgfSxcblxuXHQgICAgaW5pdFBob25lRm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcywgcHBzID0gb3duZXIucHJvcGVydGllcztcblxuXHQgICAgICAgIGlmICghcHBzLnBob25lKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDbGVhdmUuQXNZb3VUeXBlRm9ybWF0dGVyIHNob3VsZCBiZSBwcm92aWRlZCBieVxuXHQgICAgICAgIC8vIGV4dGVybmFsIGdvb2dsZSBjbG9zdXJlIGxpYlxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHBwcy5waG9uZUZvcm1hdHRlciA9IG5ldyBDbGVhdmUuUGhvbmVGb3JtYXR0ZXIoXG5cdCAgICAgICAgICAgICAgICBuZXcgcHBzLnJvb3QuQ2xlYXZlLkFzWW91VHlwZUZvcm1hdHRlcihwcHMucGhvbmVSZWdpb25Db2RlKSxcblx0ICAgICAgICAgICAgICAgIHBwcy5kZWxpbWl0ZXJcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICB9IGNhdGNoIChleCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjbGVhdmUuanNdIFBsZWFzZSBpbmNsdWRlIHBob25lLXR5cGUtZm9ybWF0dGVyLntjb3VudHJ5fS5qcyBsaWInKTtcblx0ICAgICAgICB9XG5cdCAgICB9LFxuXG5cdCAgICBvbktleURvd246IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIGNoYXJDb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcblxuXHQgICAgICAgIG93bmVyLmxhc3RJbnB1dFZhbHVlID0gb3duZXIuZWxlbWVudC52YWx1ZTtcblx0ICAgICAgICBvd25lci5pc0JhY2t3YXJkID0gY2hhckNvZGUgPT09IDg7XG5cdCAgICB9LFxuXG5cdCAgICBvbkNoYW5nZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcywgcHBzID0gb3duZXIucHJvcGVydGllcyxcblx0ICAgICAgICAgICAgVXRpbCA9IENsZWF2ZS5VdGlsO1xuXG5cdCAgICAgICAgb3duZXIuaXNCYWNrd2FyZCA9IG93bmVyLmlzQmFja3dhcmQgfHwgZXZlbnQuaW5wdXRUeXBlID09PSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJztcblxuXHQgICAgICAgIHZhciBwb3N0RGVsaW1pdGVyID0gVXRpbC5nZXRQb3N0RGVsaW1pdGVyKG93bmVyLmxhc3RJbnB1dFZhbHVlLCBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycyk7XG5cblx0ICAgICAgICBpZiAob3duZXIuaXNCYWNrd2FyZCAmJiBwb3N0RGVsaW1pdGVyKSB7XG5cdCAgICAgICAgICAgIHBwcy5wb3N0RGVsaW1pdGVyQmFja3NwYWNlID0gcG9zdERlbGltaXRlcjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBwcHMucG9zdERlbGltaXRlckJhY2tzcGFjZSA9IGZhbHNlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMub25JbnB1dCh0aGlzLmVsZW1lbnQudmFsdWUpO1xuXHQgICAgfSxcblxuXHQgICAgb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cdCAgICAgICAgb3duZXIubGFzdElucHV0VmFsdWUgPSBvd25lci5lbGVtZW50LnZhbHVlO1xuXG5cdCAgICAgICAgaWYgKHBwcy5wcmVmaXggJiYgcHBzLm5vSW1tZWRpYXRlUHJlZml4ICYmICFvd25lci5lbGVtZW50LnZhbHVlKSB7XG5cdCAgICAgICAgICAgIHRoaXMub25JbnB1dChwcHMucHJlZml4KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBDbGVhdmUuVXRpbC5maXhQcmVmaXhDdXJzb3Iob3duZXIuZWxlbWVudCwgcHBzLnByZWZpeCwgcHBzLmRlbGltaXRlciwgcHBzLmRlbGltaXRlcnMpO1xuXHQgICAgfSxcblxuXHQgICAgb25DdXQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgaWYgKCFDbGVhdmUuVXRpbC5jaGVja0Z1bGxTZWxlY3Rpb24odGhpcy5lbGVtZW50LnZhbHVlKSkgcmV0dXJuO1xuXHQgICAgICAgIHRoaXMuY29weUNsaXBib2FyZERhdGEoZSk7XG5cdCAgICAgICAgdGhpcy5vbklucHV0KCcnKTtcblx0ICAgIH0sXG5cblx0ICAgIG9uQ29weTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBpZiAoIUNsZWF2ZS5VdGlsLmNoZWNrRnVsbFNlbGVjdGlvbih0aGlzLmVsZW1lbnQudmFsdWUpKSByZXR1cm47XG5cdCAgICAgICAgdGhpcy5jb3B5Q2xpcGJvYXJkRGF0YShlKTtcblx0ICAgIH0sXG5cblx0ICAgIGNvcHlDbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXMsXG5cdCAgICAgICAgICAgIFV0aWwgPSBDbGVhdmUuVXRpbCxcblx0ICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IG93bmVyLmVsZW1lbnQudmFsdWUsXG5cdCAgICAgICAgICAgIHRleHRUb0NvcHkgPSAnJztcblxuXHQgICAgICAgIGlmICghcHBzLmNvcHlEZWxpbWl0ZXIpIHtcblx0ICAgICAgICAgICAgdGV4dFRvQ29weSA9IFV0aWwuc3RyaXBEZWxpbWl0ZXJzKGlucHV0VmFsdWUsIHBwcy5kZWxpbWl0ZXIsIHBwcy5kZWxpbWl0ZXJzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0ZXh0VG9Db3B5ID0gaW5wdXRWYWx1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZS5jbGlwYm9hcmREYXRhKSB7XG5cdCAgICAgICAgICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YSgnVGV4dCcsIHRleHRUb0NvcHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgd2luZG93LmNsaXBib2FyZERhdGEuc2V0RGF0YSgnVGV4dCcsIHRleHRUb0NvcHkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG5cdCAgICAgICAgICAgIC8vICBlbXB0eVxuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cblx0ICAgIG9uSW5wdXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsIHBwcyA9IG93bmVyLnByb3BlcnRpZXMsXG5cdCAgICAgICAgICAgIFV0aWwgPSBDbGVhdmUuVXRpbDtcblxuXHQgICAgICAgIC8vIGNhc2UgMTogZGVsZXRlIG9uZSBtb3JlIGNoYXJhY3RlciBcIjRcIlxuXHQgICAgICAgIC8vIDEyMzQqfCAtPiBoaXQgYmFja3NwYWNlIC0+IDEyM3xcblx0ICAgICAgICAvLyBjYXNlIDI6IGxhc3QgY2hhcmFjdGVyIGlzIG5vdCBkZWxpbWl0ZXIgd2hpY2ggaXM6XG5cdCAgICAgICAgLy8gMTJ8MzQqIC0+IGhpdCBiYWNrc3BhY2UgLT4gMXwzNCpcblx0ICAgICAgICAvLyBub3RlOiBubyBuZWVkIHRvIGFwcGx5IHRoaXMgZm9yIG51bWVyYWwgbW9kZVxuXHQgICAgICAgIHZhciBwb3N0RGVsaW1pdGVyQWZ0ZXIgPSBVdGlsLmdldFBvc3REZWxpbWl0ZXIodmFsdWUsIHBwcy5kZWxpbWl0ZXIsIHBwcy5kZWxpbWl0ZXJzKTtcblx0ICAgICAgICBpZiAoIXBwcy5udW1lcmFsICYmIHBwcy5wb3N0RGVsaW1pdGVyQmFja3NwYWNlICYmICFwb3N0RGVsaW1pdGVyQWZ0ZXIpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBVdGlsLmhlYWRTdHIodmFsdWUsIHZhbHVlLmxlbmd0aCAtIHBwcy5wb3N0RGVsaW1pdGVyQmFja3NwYWNlLmxlbmd0aCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gcGhvbmUgZm9ybWF0dGVyXG5cdCAgICAgICAgaWYgKHBwcy5waG9uZSkge1xuXHQgICAgICAgICAgICBpZiAocHBzLnByZWZpeCAmJiAoIXBwcy5ub0ltbWVkaWF0ZVByZWZpeCB8fCB2YWx1ZS5sZW5ndGgpKSB7XG5cdCAgICAgICAgICAgICAgICBwcHMucmVzdWx0ID0gcHBzLnByZWZpeCArIHBwcy5waG9uZUZvcm1hdHRlci5mb3JtYXQodmFsdWUpLnNsaWNlKHBwcy5wcmVmaXgubGVuZ3RoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHBwcy5yZXN1bHQgPSBwcHMucGhvbmVGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvd25lci51cGRhdGVWYWx1ZVN0YXRlKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIG51bWVyYWwgZm9ybWF0dGVyXG5cdCAgICAgICAgaWYgKHBwcy5udW1lcmFsKSB7XG5cdCAgICAgICAgICAgIC8vIERvIG5vdCBzaG93IHByZWZpeCB3aGVuIG5vSW1tZWRpYXRlUHJlZml4IGlzIHNwZWNpZmllZFxuXHQgICAgICAgICAgICAvLyBUaGlzIG1vc3RseSBiZWNhdXNlIHdlIG5lZWQgdG8gc2hvdyB1c2VyIHRoZSBuYXRpdmUgaW5wdXQgcGxhY2Vob2xkZXJcblx0ICAgICAgICAgICAgaWYgKHBwcy5wcmVmaXggJiYgcHBzLm5vSW1tZWRpYXRlUHJlZml4ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgcHBzLnJlc3VsdCA9ICcnO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcHBzLnJlc3VsdCA9IHBwcy5udW1lcmFsRm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3duZXIudXBkYXRlVmFsdWVTdGF0ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBkYXRlXG5cdCAgICAgICAgaWYgKHBwcy5kYXRlKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gcHBzLmRhdGVGb3JtYXR0ZXIuZ2V0VmFsaWRhdGVkRGF0ZSh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gdGltZVxuXHQgICAgICAgIGlmIChwcHMudGltZSkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHBwcy50aW1lRm9ybWF0dGVyLmdldFZhbGlkYXRlZFRpbWUodmFsdWUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIHN0cmlwIGRlbGltaXRlcnNcblx0ICAgICAgICB2YWx1ZSA9IFV0aWwuc3RyaXBEZWxpbWl0ZXJzKHZhbHVlLCBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycyk7XG5cblx0ICAgICAgICAvLyBzdHJpcCBwcmVmaXhcblx0ICAgICAgICB2YWx1ZSA9IFV0aWwuZ2V0UHJlZml4U3RyaXBwZWRWYWx1ZSh2YWx1ZSwgcHBzLnByZWZpeCwgcHBzLnByZWZpeExlbmd0aCwgcHBzLnJlc3VsdCwgcHBzLmRlbGltaXRlciwgcHBzLmRlbGltaXRlcnMsIHBwcy5ub0ltbWVkaWF0ZVByZWZpeCwgcHBzLnRhaWxQcmVmaXgsIHBwcy5zaWduQmVmb3JlUHJlZml4KTtcblxuXHQgICAgICAgIC8vIHN0cmlwIG5vbi1udW1lcmljIGNoYXJhY3RlcnNcblx0ICAgICAgICB2YWx1ZSA9IHBwcy5udW1lcmljT25seSA/IFV0aWwuc3RyaXAodmFsdWUsIC9bXlxcZF0vZykgOiB2YWx1ZTtcblxuXHQgICAgICAgIC8vIGNvbnZlcnQgY2FzZVxuXHQgICAgICAgIHZhbHVlID0gcHBzLnVwcGVyY2FzZSA/IHZhbHVlLnRvVXBwZXJDYXNlKCkgOiB2YWx1ZTtcblx0ICAgICAgICB2YWx1ZSA9IHBwcy5sb3dlcmNhc2UgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogdmFsdWU7XG5cblx0ICAgICAgICAvLyBwcmV2ZW50IGZyb20gc2hvd2luZyBwcmVmaXggd2hlbiBubyBpbW1lZGlhdGUgb3B0aW9uIGVuYWJsZWQgd2l0aCBlbXB0eSBpbnB1dCB2YWx1ZVxuXHQgICAgICAgIGlmIChwcHMucHJlZml4KSB7XG5cdCAgICAgICAgICAgIGlmIChwcHMudGFpbFByZWZpeCkge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArIHBwcy5wcmVmaXg7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHBwcy5wcmVmaXggKyB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cblx0ICAgICAgICAgICAgLy8gbm8gYmxvY2tzIHNwZWNpZmllZCwgbm8gbmVlZCB0byBkbyBmb3JtYXR0aW5nXG5cdCAgICAgICAgICAgIGlmIChwcHMuYmxvY2tzTGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBwcHMucmVzdWx0ID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICBvd25lci51cGRhdGVWYWx1ZVN0YXRlKCk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIHVwZGF0ZSBjcmVkaXQgY2FyZCBwcm9wc1xuXHQgICAgICAgIGlmIChwcHMuY3JlZGl0Q2FyZCkge1xuXHQgICAgICAgICAgICBvd25lci51cGRhdGVDcmVkaXRDYXJkUHJvcHNCeVZhbHVlKHZhbHVlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBzdHJpcCBvdmVyIGxlbmd0aCBjaGFyYWN0ZXJzXG5cdCAgICAgICAgdmFsdWUgPSBVdGlsLmhlYWRTdHIodmFsdWUsIHBwcy5tYXhMZW5ndGgpO1xuXG5cdCAgICAgICAgLy8gYXBwbHkgYmxvY2tzXG5cdCAgICAgICAgcHBzLnJlc3VsdCA9IFV0aWwuZ2V0Rm9ybWF0dGVkVmFsdWUoXG5cdCAgICAgICAgICAgIHZhbHVlLFxuXHQgICAgICAgICAgICBwcHMuYmxvY2tzLCBwcHMuYmxvY2tzTGVuZ3RoLFxuXHQgICAgICAgICAgICBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycywgcHBzLmRlbGltaXRlckxhenlTaG93XG5cdCAgICAgICAgKTtcblxuXHQgICAgICAgIG93bmVyLnVwZGF0ZVZhbHVlU3RhdGUoKTtcblx0ICAgIH0sXG5cblx0ICAgIHVwZGF0ZUNyZWRpdENhcmRQcm9wc0J5VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsIHBwcyA9IG93bmVyLnByb3BlcnRpZXMsXG5cdCAgICAgICAgICAgIFV0aWwgPSBDbGVhdmUuVXRpbCxcblx0ICAgICAgICAgICAgY3JlZGl0Q2FyZEluZm87XG5cblx0ICAgICAgICAvLyBBdCBsZWFzdCBvbmUgb2YgdGhlIGZpcnN0IDQgY2hhcmFjdGVycyBoYXMgY2hhbmdlZFxuXHQgICAgICAgIGlmIChVdGlsLmhlYWRTdHIocHBzLnJlc3VsdCwgNCkgPT09IFV0aWwuaGVhZFN0cih2YWx1ZSwgNCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGNyZWRpdENhcmRJbmZvID0gQ2xlYXZlLkNyZWRpdENhcmREZXRlY3Rvci5nZXRJbmZvKHZhbHVlLCBwcHMuY3JlZGl0Q2FyZFN0cmljdE1vZGUpO1xuXG5cdCAgICAgICAgcHBzLmJsb2NrcyA9IGNyZWRpdENhcmRJbmZvLmJsb2Nrcztcblx0ICAgICAgICBwcHMuYmxvY2tzTGVuZ3RoID0gcHBzLmJsb2Nrcy5sZW5ndGg7XG5cdCAgICAgICAgcHBzLm1heExlbmd0aCA9IFV0aWwuZ2V0TWF4TGVuZ3RoKHBwcy5ibG9ja3MpO1xuXG5cdCAgICAgICAgLy8gY3JlZGl0IGNhcmQgdHlwZSBjaGFuZ2VkXG5cdCAgICAgICAgaWYgKHBwcy5jcmVkaXRDYXJkVHlwZSAhPT0gY3JlZGl0Q2FyZEluZm8udHlwZSkge1xuXHQgICAgICAgICAgICBwcHMuY3JlZGl0Q2FyZFR5cGUgPSBjcmVkaXRDYXJkSW5mby50eXBlO1xuXG5cdCAgICAgICAgICAgIHBwcy5vbkNyZWRpdENhcmRUeXBlQ2hhbmdlZC5jYWxsKG93bmVyLCBwcHMuY3JlZGl0Q2FyZFR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cblx0ICAgIHVwZGF0ZVZhbHVlU3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBVdGlsID0gQ2xlYXZlLlV0aWwsXG5cdCAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cblx0ICAgICAgICBpZiAoIW93bmVyLmVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBlbmRQb3MgPSBvd25lci5lbGVtZW50LnNlbGVjdGlvbkVuZDtcblx0ICAgICAgICB2YXIgb2xkVmFsdWUgPSBvd25lci5lbGVtZW50LnZhbHVlO1xuXHQgICAgICAgIHZhciBuZXdWYWx1ZSA9IHBwcy5yZXN1bHQ7XG5cblx0ICAgICAgICBlbmRQb3MgPSBVdGlsLmdldE5leHRDdXJzb3JQb3NpdGlvbihlbmRQb3MsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgcHBzLmRlbGltaXRlciwgcHBzLmRlbGltaXRlcnMpO1xuXG5cdCAgICAgICAgLy8gZml4IEFuZHJvaWQgYnJvd3NlciB0eXBlPVwidGV4dFwiIGlucHV0IGZpZWxkXG5cdCAgICAgICAgLy8gY3Vyc29yIG5vdCBqdW1waW5nIGlzc3VlXG5cdCAgICAgICAgaWYgKG93bmVyLmlzQW5kcm9pZCkge1xuXHQgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBvd25lci5lbGVtZW50LnZhbHVlID0gbmV3VmFsdWU7XG5cdCAgICAgICAgICAgICAgICBVdGlsLnNldFNlbGVjdGlvbihvd25lci5lbGVtZW50LCBlbmRQb3MsIHBwcy5kb2N1bWVudCwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgb3duZXIuY2FsbE9uVmFsdWVDaGFuZ2VkKCk7XG5cdCAgICAgICAgICAgIH0sIDEpO1xuXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBvd25lci5lbGVtZW50LnZhbHVlID0gbmV3VmFsdWU7XG5cdCAgICAgICAgaWYgKHBwcy5zd2FwSGlkZGVuSW5wdXQpIG93bmVyLmVsZW1lbnRTd2FwSGlkZGVuLnZhbHVlID0gb3duZXIuZ2V0UmF3VmFsdWUoKTtcblxuXHQgICAgICAgIFV0aWwuc2V0U2VsZWN0aW9uKG93bmVyLmVsZW1lbnQsIGVuZFBvcywgcHBzLmRvY3VtZW50LCBmYWxzZSk7XG5cdCAgICAgICAgb3duZXIuY2FsbE9uVmFsdWVDaGFuZ2VkKCk7XG5cdCAgICB9LFxuXG5cdCAgICBjYWxsT25WYWx1ZUNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuXG5cdCAgICAgICAgcHBzLm9uVmFsdWVDaGFuZ2VkLmNhbGwob3duZXIsIHtcblx0ICAgICAgICAgICAgdGFyZ2V0OiB7XG5cdCAgICAgICAgICAgICAgICBuYW1lOiBvd25lci5lbGVtZW50Lm5hbWUsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogcHBzLnJlc3VsdCxcblx0ICAgICAgICAgICAgICAgIHJhd1ZhbHVlOiBvd25lci5nZXRSYXdWYWx1ZSgpXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIHNldFBob25lUmVnaW9uQ29kZTogZnVuY3Rpb24gKHBob25lUmVnaW9uQ29kZSkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cblx0ICAgICAgICBwcHMucGhvbmVSZWdpb25Db2RlID0gcGhvbmVSZWdpb25Db2RlO1xuXHQgICAgICAgIG93bmVyLmluaXRQaG9uZUZvcm1hdHRlcigpO1xuXHQgICAgICAgIG93bmVyLm9uQ2hhbmdlKCk7XG5cdCAgICB9LFxuXG5cdCAgICBzZXRSYXdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcywgcHBzID0gb3duZXIucHJvcGVydGllcztcblxuXHQgICAgICAgIHZhbHVlID0gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlLnRvU3RyaW5nKCkgOiAnJztcblxuXHQgICAgICAgIGlmIChwcHMubnVtZXJhbCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy4nLCBwcHMubnVtZXJhbERlY2ltYWxNYXJrKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwcHMucG9zdERlbGltaXRlckJhY2tzcGFjZSA9IGZhbHNlO1xuXG5cdCAgICAgICAgb3duZXIuZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgIG93bmVyLm9uSW5wdXQodmFsdWUpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0UmF3VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzLFxuXHQgICAgICAgICAgICBVdGlsID0gQ2xlYXZlLlV0aWwsXG5cdCAgICAgICAgICAgIHJhd1ZhbHVlID0gb3duZXIuZWxlbWVudC52YWx1ZTtcblxuXHQgICAgICAgIGlmIChwcHMucmF3VmFsdWVUcmltUHJlZml4KSB7XG5cdCAgICAgICAgICAgIHJhd1ZhbHVlID0gVXRpbC5nZXRQcmVmaXhTdHJpcHBlZFZhbHVlKHJhd1ZhbHVlLCBwcHMucHJlZml4LCBwcHMucHJlZml4TGVuZ3RoLCBwcHMucmVzdWx0LCBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycywgcHBzLm5vSW1tZWRpYXRlUHJlZml4LCBwcHMudGFpbFByZWZpeCwgcHBzLnNpZ25CZWZvcmVQcmVmaXgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChwcHMubnVtZXJhbCkge1xuXHQgICAgICAgICAgICByYXdWYWx1ZSA9IHBwcy5udW1lcmFsRm9ybWF0dGVyLmdldFJhd1ZhbHVlKHJhd1ZhbHVlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByYXdWYWx1ZSA9IFV0aWwuc3RyaXBEZWxpbWl0ZXJzKHJhd1ZhbHVlLCBwcHMuZGVsaW1pdGVyLCBwcHMuZGVsaW1pdGVycyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0SVNPRm9ybWF0RGF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIHBwcyA9IG93bmVyLnByb3BlcnRpZXM7XG5cblx0ICAgICAgICByZXR1cm4gcHBzLmRhdGUgPyBwcHMuZGF0ZUZvcm1hdHRlci5nZXRJU09Gb3JtYXREYXRlKCkgOiAnJztcblx0ICAgIH0sXG5cblx0ICAgIGdldElTT0Zvcm1hdFRpbWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBwcHMgPSBvd25lci5wcm9wZXJ0aWVzO1xuXG5cdCAgICAgICAgcmV0dXJuIHBwcy50aW1lID8gcHBzLnRpbWVGb3JtYXR0ZXIuZ2V0SVNPRm9ybWF0VGltZSgpIDogJyc7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRGb3JtYXR0ZWRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQudmFsdWU7XG5cdCAgICB9LFxuXG5cdCAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcztcblxuXHQgICAgICAgIG93bmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBvd25lci5vbkNoYW5nZUxpc3RlbmVyKTtcblx0ICAgICAgICBvd25lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvd25lci5vbktleURvd25MaXN0ZW5lcik7XG5cdCAgICAgICAgb3duZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIG93bmVyLm9uRm9jdXNMaXN0ZW5lcik7XG5cdCAgICAgICAgb3duZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjdXQnLCBvd25lci5vbkN1dExpc3RlbmVyKTtcblx0ICAgICAgICBvd25lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvcHknLCBvd25lci5vbkNvcHlMaXN0ZW5lcik7XG5cdCAgICB9LFxuXG5cdCAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAnW0NsZWF2ZSBPYmplY3RdJztcblx0ICAgIH1cblx0fTtcblxuXHRDbGVhdmUuTnVtZXJhbEZvcm1hdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdENsZWF2ZS5EYXRlRm9ybWF0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0Q2xlYXZlLlRpbWVGb3JtYXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRDbGVhdmUuUGhvbmVGb3JtYXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRDbGVhdmUuQ3JlZGl0Q2FyZERldGVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0Q2xlYXZlLlV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRDbGVhdmUuRGVmYXVsdFByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5cdC8vIGZvciBhbmd1bGFyIGRpcmVjdGl2ZVxuXHQoKHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbCkgPyBnbG9iYWwgOiB3aW5kb3cpWydDbGVhdmUnXSA9IENsZWF2ZTtcblxuXHQvLyBDb21tb25KU1xuXHRtb2R1bGUuZXhwb3J0cyA9IENsZWF2ZTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgTnVtZXJhbEZvcm1hdHRlciA9IGZ1bmN0aW9uIChudW1lcmFsRGVjaW1hbE1hcmssXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyYWxJbnRlZ2VyU2NhbGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyYWxEZWNpbWFsU2NhbGUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyYWxUaG91c2FuZHNHcm91cFN0eWxlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmFsUG9zaXRpdmVPbmx5LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpcExlYWRpbmdaZXJvZXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbkJlZm9yZVByZWZpeCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFpbFByZWZpeCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyKSB7XG5cdCAgICB2YXIgb3duZXIgPSB0aGlzO1xuXG5cdCAgICBvd25lci5udW1lcmFsRGVjaW1hbE1hcmsgPSBudW1lcmFsRGVjaW1hbE1hcmsgfHwgJy4nO1xuXHQgICAgb3duZXIubnVtZXJhbEludGVnZXJTY2FsZSA9IG51bWVyYWxJbnRlZ2VyU2NhbGUgPiAwID8gbnVtZXJhbEludGVnZXJTY2FsZSA6IDA7XG5cdCAgICBvd25lci5udW1lcmFsRGVjaW1hbFNjYWxlID0gbnVtZXJhbERlY2ltYWxTY2FsZSA+PSAwID8gbnVtZXJhbERlY2ltYWxTY2FsZSA6IDI7XG5cdCAgICBvd25lci5udW1lcmFsVGhvdXNhbmRzR3JvdXBTdHlsZSA9IG51bWVyYWxUaG91c2FuZHNHcm91cFN0eWxlIHx8IE51bWVyYWxGb3JtYXR0ZXIuZ3JvdXBTdHlsZS50aG91c2FuZDtcblx0ICAgIG93bmVyLm51bWVyYWxQb3NpdGl2ZU9ubHkgPSAhIW51bWVyYWxQb3NpdGl2ZU9ubHk7XG5cdCAgICBvd25lci5zdHJpcExlYWRpbmdaZXJvZXMgPSBzdHJpcExlYWRpbmdaZXJvZXMgIT09IGZhbHNlO1xuXHQgICAgb3duZXIucHJlZml4ID0gKHByZWZpeCB8fCBwcmVmaXggPT09ICcnKSA/IHByZWZpeCA6ICcnO1xuXHQgICAgb3duZXIuc2lnbkJlZm9yZVByZWZpeCA9ICEhc2lnbkJlZm9yZVByZWZpeDtcblx0ICAgIG93bmVyLnRhaWxQcmVmaXggPSAhIXRhaWxQcmVmaXg7XG5cdCAgICBvd25lci5kZWxpbWl0ZXIgPSAoZGVsaW1pdGVyIHx8IGRlbGltaXRlciA9PT0gJycpID8gZGVsaW1pdGVyIDogJywnO1xuXHQgICAgb3duZXIuZGVsaW1pdGVyUkUgPSBkZWxpbWl0ZXIgPyBuZXcgUmVnRXhwKCdcXFxcJyArIGRlbGltaXRlciwgJ2cnKSA6ICcnO1xuXHR9O1xuXG5cdE51bWVyYWxGb3JtYXR0ZXIuZ3JvdXBTdHlsZSA9IHtcblx0ICAgIHRob3VzYW5kOiAndGhvdXNhbmQnLFxuXHQgICAgbGFraDogICAgICdsYWtoJyxcblx0ICAgIHdhbjogICAgICAnd2FuJyxcblx0ICAgIG5vbmU6ICAgICAnbm9uZScgICAgXG5cdH07XG5cblx0TnVtZXJhbEZvcm1hdHRlci5wcm90b3R5cGUgPSB7XG5cdCAgICBnZXRSYXdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UodGhpcy5kZWxpbWl0ZXJSRSwgJycpLnJlcGxhY2UodGhpcy5udW1lcmFsRGVjaW1hbE1hcmssICcuJyk7XG5cdCAgICB9LFxuXG5cdCAgICBmb3JtYXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsIHBhcnRzLCBwYXJ0U2lnbiwgcGFydFNpZ25BbmRQcmVmaXgsIHBhcnRJbnRlZ2VyLCBwYXJ0RGVjaW1hbCA9ICcnO1xuXG5cdCAgICAgICAgLy8gc3RyaXAgYWxwaGFiZXQgbGV0dGVyc1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW0EtWmEtel0vZywgJycpXG5cdCAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGZpcnN0IGRlY2ltYWwgbWFyayB3aXRoIHJlc2VydmVkIHBsYWNlaG9sZGVyXG5cdCAgICAgICAgICAgIC5yZXBsYWNlKG93bmVyLm51bWVyYWxEZWNpbWFsTWFyaywgJ00nKVxuXG5cdCAgICAgICAgICAgIC8vIHN0cmlwIG5vbiBudW1lcmljIGxldHRlcnMgZXhjZXB0IG1pbnVzIGFuZCBcIk1cIlxuXHQgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSBwcmVmaXggaGFzIGJlZW4gc3RyaXBwZWRcblx0ICAgICAgICAgICAgLnJlcGxhY2UoL1teXFxkTS1dL2csICcnKVxuXG5cdCAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGxlYWRpbmcgbWludXMgd2l0aCByZXNlcnZlZCBwbGFjZWhvbGRlclxuXHQgICAgICAgICAgICAucmVwbGFjZSgvXlxcLS8sICdOJylcblxuXHQgICAgICAgICAgICAvLyBzdHJpcCB0aGUgb3RoZXIgbWludXMgc2lnbiAoaWYgcHJlc2VudClcblx0ICAgICAgICAgICAgLnJlcGxhY2UoL1xcLS9nLCAnJylcblxuXHQgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBtaW51cyBzaWduIChpZiBwcmVzZW50KVxuXHQgICAgICAgICAgICAucmVwbGFjZSgnTicsIG93bmVyLm51bWVyYWxQb3NpdGl2ZU9ubHkgPyAnJyA6ICctJylcblxuXHQgICAgICAgICAgICAvLyByZXBsYWNlIGRlY2ltYWwgbWFya1xuXHQgICAgICAgICAgICAucmVwbGFjZSgnTScsIG93bmVyLm51bWVyYWxEZWNpbWFsTWFyayk7XG5cblx0ICAgICAgICAvLyBzdHJpcCBhbnkgbGVhZGluZyB6ZXJvc1xuXHQgICAgICAgIGlmIChvd25lci5zdHJpcExlYWRpbmdaZXJvZXMpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKC0pPzArKD89XFxkKS8sICckMScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHBhcnRTaWduID0gdmFsdWUuc2xpY2UoMCwgMSkgPT09ICctJyA/ICctJyA6ICcnO1xuXHQgICAgICAgIGlmICh0eXBlb2Ygb3duZXIucHJlZml4ICE9ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIGlmIChvd25lci5zaWduQmVmb3JlUHJlZml4KSB7XG5cdCAgICAgICAgICAgICAgICBwYXJ0U2lnbkFuZFByZWZpeCA9IHBhcnRTaWduICsgb3duZXIucHJlZml4O1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcGFydFNpZ25BbmRQcmVmaXggPSBvd25lci5wcmVmaXggKyBwYXJ0U2lnbjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHBhcnRTaWduQW5kUHJlZml4ID0gcGFydFNpZ247XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFxuXHQgICAgICAgIHBhcnRJbnRlZ2VyID0gdmFsdWU7XG5cblx0ICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihvd25lci5udW1lcmFsRGVjaW1hbE1hcmspID49IDApIHtcblx0ICAgICAgICAgICAgcGFydHMgPSB2YWx1ZS5zcGxpdChvd25lci5udW1lcmFsRGVjaW1hbE1hcmspO1xuXHQgICAgICAgICAgICBwYXJ0SW50ZWdlciA9IHBhcnRzWzBdO1xuXHQgICAgICAgICAgICBwYXJ0RGVjaW1hbCA9IG93bmVyLm51bWVyYWxEZWNpbWFsTWFyayArIHBhcnRzWzFdLnNsaWNlKDAsIG93bmVyLm51bWVyYWxEZWNpbWFsU2NhbGUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmKHBhcnRTaWduID09PSAnLScpIHtcblx0ICAgICAgICAgICAgcGFydEludGVnZXIgPSBwYXJ0SW50ZWdlci5zbGljZSgxKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAob3duZXIubnVtZXJhbEludGVnZXJTY2FsZSA+IDApIHtcblx0ICAgICAgICAgIHBhcnRJbnRlZ2VyID0gcGFydEludGVnZXIuc2xpY2UoMCwgb3duZXIubnVtZXJhbEludGVnZXJTY2FsZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgc3dpdGNoIChvd25lci5udW1lcmFsVGhvdXNhbmRzR3JvdXBTdHlsZSkge1xuXHQgICAgICAgIGNhc2UgTnVtZXJhbEZvcm1hdHRlci5ncm91cFN0eWxlLmxha2g6XG5cdCAgICAgICAgICAgIHBhcnRJbnRlZ2VyID0gcGFydEludGVnZXIucmVwbGFjZSgvKFxcZCkoPz0oXFxkXFxkKStcXGQkKS9nLCAnJDEnICsgb3duZXIuZGVsaW1pdGVyKTtcblxuXHQgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgTnVtZXJhbEZvcm1hdHRlci5ncm91cFN0eWxlLndhbjpcblx0ICAgICAgICAgICAgcGFydEludGVnZXIgPSBwYXJ0SW50ZWdlci5yZXBsYWNlKC8oXFxkKSg/PShcXGR7NH0pKyQpL2csICckMScgKyBvd25lci5kZWxpbWl0ZXIpO1xuXG5cdCAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSBOdW1lcmFsRm9ybWF0dGVyLmdyb3VwU3R5bGUudGhvdXNhbmQ6XG5cdCAgICAgICAgICAgIHBhcnRJbnRlZ2VyID0gcGFydEludGVnZXIucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSskKS9nLCAnJDEnICsgb3duZXIuZGVsaW1pdGVyKTtcblxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAob3duZXIudGFpbFByZWZpeCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcGFydFNpZ24gKyBwYXJ0SW50ZWdlci50b1N0cmluZygpICsgKG93bmVyLm51bWVyYWxEZWNpbWFsU2NhbGUgPiAwID8gcGFydERlY2ltYWwudG9TdHJpbmcoKSA6ICcnKSArIG93bmVyLnByZWZpeDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcGFydFNpZ25BbmRQcmVmaXggKyBwYXJ0SW50ZWdlci50b1N0cmluZygpICsgKG93bmVyLm51bWVyYWxEZWNpbWFsU2NhbGUgPiAwID8gcGFydERlY2ltYWwudG9TdHJpbmcoKSA6ICcnKTtcblx0ICAgIH1cblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IE51bWVyYWxGb3JtYXR0ZXI7XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBEYXRlRm9ybWF0dGVyID0gZnVuY3Rpb24gKGRhdGVQYXR0ZXJuLCBkYXRlTWluLCBkYXRlTWF4KSB7XG5cdCAgICB2YXIgb3duZXIgPSB0aGlzO1xuXG5cdCAgICBvd25lci5kYXRlID0gW107XG5cdCAgICBvd25lci5ibG9ja3MgPSBbXTtcblx0ICAgIG93bmVyLmRhdGVQYXR0ZXJuID0gZGF0ZVBhdHRlcm47XG5cdCAgICBvd25lci5kYXRlTWluID0gZGF0ZU1pblxuXHQgICAgICAuc3BsaXQoJy0nKVxuXHQgICAgICAucmV2ZXJzZSgpXG5cdCAgICAgIC5tYXAoZnVuY3Rpb24oeCkge1xuXHQgICAgICAgIHJldHVybiBwYXJzZUludCh4LCAxMCk7XG5cdCAgICAgIH0pO1xuXHQgICAgaWYgKG93bmVyLmRhdGVNaW4ubGVuZ3RoID09PSAyKSBvd25lci5kYXRlTWluLnVuc2hpZnQoMCk7XG5cblx0ICAgIG93bmVyLmRhdGVNYXggPSBkYXRlTWF4XG5cdCAgICAgIC5zcGxpdCgnLScpXG5cdCAgICAgIC5yZXZlcnNlKClcblx0ICAgICAgLm1hcChmdW5jdGlvbih4KSB7XG5cdCAgICAgICAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKTtcblx0ICAgICAgfSk7XG5cdCAgICBpZiAob3duZXIuZGF0ZU1heC5sZW5ndGggPT09IDIpIG93bmVyLmRhdGVNYXgudW5zaGlmdCgwKTtcblx0ICAgIFxuXHQgICAgb3duZXIuaW5pdEJsb2NrcygpO1xuXHR9O1xuXG5cdERhdGVGb3JtYXR0ZXIucHJvdG90eXBlID0ge1xuXHQgICAgaW5pdEJsb2NrczogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXM7XG5cdCAgICAgICAgb3duZXIuZGF0ZVBhdHRlcm4uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnWScpIHtcblx0ICAgICAgICAgICAgICAgIG93bmVyLmJsb2Nrcy5wdXNoKDQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgb3duZXIuYmxvY2tzLnB1c2goMik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIGdldElTT0Zvcm1hdERhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICBkYXRlID0gb3duZXIuZGF0ZTtcblxuXHQgICAgICAgIHJldHVybiBkYXRlWzJdID8gKFxuXHQgICAgICAgICAgICBkYXRlWzJdICsgJy0nICsgb3duZXIuYWRkTGVhZGluZ1plcm8oZGF0ZVsxXSkgKyAnLScgKyBvd25lci5hZGRMZWFkaW5nWmVybyhkYXRlWzBdKVxuXHQgICAgICAgICkgOiAnJztcblx0ICAgIH0sXG5cblx0ICAgIGdldEJsb2NrczogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmJsb2Nrcztcblx0ICAgIH0sXG5cblx0ICAgIGdldFZhbGlkYXRlZERhdGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsIHJlc3VsdCA9ICcnO1xuXG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcZF0vZywgJycpO1xuXG5cdCAgICAgICAgb3duZXIuYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGxlbmd0aCwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdWIgPSB2YWx1ZS5zbGljZSgwLCBsZW5ndGgpLFxuXHQgICAgICAgICAgICAgICAgICAgIHN1YjAgPSBzdWIuc2xpY2UoMCwgMSksXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHZhbHVlLnNsaWNlKGxlbmd0aCk7XG5cblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAob3duZXIuZGF0ZVBhdHRlcm5baW5kZXhdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdkJzpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3ViID09PSAnMDAnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YiA9ICcwMSc7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZUludChzdWIwLCAxMCkgPiAzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YiA9ICcwJyArIHN1YjA7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZUludChzdWIsIDEwKSA+IDMxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YiA9ICczMSc7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdWIgPT09ICcwMCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gJzAxJztcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHN1YjAsIDEwKSA+IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gJzAnICsgc3ViMDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHN1YiwgMTApID4gMTIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gJzEyJztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN1YjtcblxuXHQgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHJlbWFpbmluZyBzdHJpbmdcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rml4ZWREYXRlU3RyaW5nKHJlc3VsdCk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRGaXhlZERhdGVTdHJpbmc6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsIGRhdGVQYXR0ZXJuID0gb3duZXIuZGF0ZVBhdHRlcm4sIGRhdGUgPSBbXSxcblx0ICAgICAgICAgICAgZGF5SW5kZXggPSAwLCBtb250aEluZGV4ID0gMCwgeWVhckluZGV4ID0gMCxcblx0ICAgICAgICAgICAgZGF5U3RhcnRJbmRleCA9IDAsIG1vbnRoU3RhcnRJbmRleCA9IDAsIHllYXJTdGFydEluZGV4ID0gMCxcblx0ICAgICAgICAgICAgZGF5LCBtb250aCwgeWVhciwgZnVsbFllYXJEb25lID0gZmFsc2U7XG5cblx0ICAgICAgICAvLyBtbS1kZCB8fCBkZC1tbVxuXHQgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDQgJiYgZGF0ZVBhdHRlcm5bMF0udG9Mb3dlckNhc2UoKSAhPT0gJ3knICYmIGRhdGVQYXR0ZXJuWzFdLnRvTG93ZXJDYXNlKCkgIT09ICd5Jykge1xuXHQgICAgICAgICAgICBkYXlTdGFydEluZGV4ID0gZGF0ZVBhdHRlcm5bMF0gPT09ICdkJyA/IDAgOiAyO1xuXHQgICAgICAgICAgICBtb250aFN0YXJ0SW5kZXggPSAyIC0gZGF5U3RhcnRJbmRleDtcblx0ICAgICAgICAgICAgZGF5ID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoZGF5U3RhcnRJbmRleCwgZGF5U3RhcnRJbmRleCArIDIpLCAxMCk7XG5cdCAgICAgICAgICAgIG1vbnRoID0gcGFyc2VJbnQodmFsdWUuc2xpY2UobW9udGhTdGFydEluZGV4LCBtb250aFN0YXJ0SW5kZXggKyAyKSwgMTApO1xuXG5cdCAgICAgICAgICAgIGRhdGUgPSB0aGlzLmdldEZpeGVkRGF0ZShkYXksIG1vbnRoLCAwKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyB5eXl5LW1tLWRkIHx8IHl5eXktZGQtbW0gfHwgbW0tZGQteXl5eSB8fCBkZC1tbS15eXl5IHx8IGRkLXl5eXktbW0gfHwgbW0teXl5eS1kZFxuXHQgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDgpIHtcblx0ICAgICAgICAgICAgZGF0ZVBhdHRlcm4uZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG5cdCAgICAgICAgICAgICAgICAgICAgZGF5SW5kZXggPSBpbmRleDtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuXHQgICAgICAgICAgICAgICAgICAgIG1vbnRoSW5kZXggPSBpbmRleDtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgeWVhckluZGV4ID0gaW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIHllYXJTdGFydEluZGV4ID0geWVhckluZGV4ICogMjtcblx0ICAgICAgICAgICAgZGF5U3RhcnRJbmRleCA9IChkYXlJbmRleCA8PSB5ZWFySW5kZXgpID8gZGF5SW5kZXggKiAyIDogKGRheUluZGV4ICogMiArIDIpO1xuXHQgICAgICAgICAgICBtb250aFN0YXJ0SW5kZXggPSAobW9udGhJbmRleCA8PSB5ZWFySW5kZXgpID8gbW9udGhJbmRleCAqIDIgOiAobW9udGhJbmRleCAqIDIgKyAyKTtcblxuXHQgICAgICAgICAgICBkYXkgPSBwYXJzZUludCh2YWx1ZS5zbGljZShkYXlTdGFydEluZGV4LCBkYXlTdGFydEluZGV4ICsgMiksIDEwKTtcblx0ICAgICAgICAgICAgbW9udGggPSBwYXJzZUludCh2YWx1ZS5zbGljZShtb250aFN0YXJ0SW5kZXgsIG1vbnRoU3RhcnRJbmRleCArIDIpLCAxMCk7XG5cdCAgICAgICAgICAgIHllYXIgPSBwYXJzZUludCh2YWx1ZS5zbGljZSh5ZWFyU3RhcnRJbmRleCwgeWVhclN0YXJ0SW5kZXggKyA0KSwgMTApO1xuXG5cdCAgICAgICAgICAgIGZ1bGxZZWFyRG9uZSA9IHZhbHVlLnNsaWNlKHllYXJTdGFydEluZGV4LCB5ZWFyU3RhcnRJbmRleCArIDQpLmxlbmd0aCA9PT0gNDtcblxuXHQgICAgICAgICAgICBkYXRlID0gdGhpcy5nZXRGaXhlZERhdGUoZGF5LCBtb250aCwgeWVhcik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gbW0teXkgfHwgeXktbW1cblx0ICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSA0ICYmIChkYXRlUGF0dGVyblswXSA9PT0gJ3knIHx8IGRhdGVQYXR0ZXJuWzFdID09PSAneScpKSB7XG5cdCAgICAgICAgICAgIG1vbnRoU3RhcnRJbmRleCA9IGRhdGVQYXR0ZXJuWzBdID09PSAnbScgPyAwIDogMjtcblx0ICAgICAgICAgICAgeWVhclN0YXJ0SW5kZXggPSAyIC0gbW9udGhTdGFydEluZGV4O1xuXHQgICAgICAgICAgICBtb250aCA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKG1vbnRoU3RhcnRJbmRleCwgbW9udGhTdGFydEluZGV4ICsgMiksIDEwKTtcblx0ICAgICAgICAgICAgeWVhciA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKHllYXJTdGFydEluZGV4LCB5ZWFyU3RhcnRJbmRleCArIDIpLCAxMCk7XG5cblx0ICAgICAgICAgICAgZnVsbFllYXJEb25lID0gdmFsdWUuc2xpY2UoeWVhclN0YXJ0SW5kZXgsIHllYXJTdGFydEluZGV4ICsgMikubGVuZ3RoID09PSAyO1xuXG5cdCAgICAgICAgICAgIGRhdGUgPSBbMCwgbW9udGgsIHllYXJdO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIG1tLXl5eXkgfHwgeXl5eS1tbVxuXHQgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDYgJiYgKGRhdGVQYXR0ZXJuWzBdID09PSAnWScgfHwgZGF0ZVBhdHRlcm5bMV0gPT09ICdZJykpIHtcblx0ICAgICAgICAgICAgbW9udGhTdGFydEluZGV4ID0gZGF0ZVBhdHRlcm5bMF0gPT09ICdtJyA/IDAgOiA0O1xuXHQgICAgICAgICAgICB5ZWFyU3RhcnRJbmRleCA9IDIgLSAwLjUgKiBtb250aFN0YXJ0SW5kZXg7XG5cdCAgICAgICAgICAgIG1vbnRoID0gcGFyc2VJbnQodmFsdWUuc2xpY2UobW9udGhTdGFydEluZGV4LCBtb250aFN0YXJ0SW5kZXggKyAyKSwgMTApO1xuXHQgICAgICAgICAgICB5ZWFyID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoeWVhclN0YXJ0SW5kZXgsIHllYXJTdGFydEluZGV4ICsgNCksIDEwKTtcblxuXHQgICAgICAgICAgICBmdWxsWWVhckRvbmUgPSB2YWx1ZS5zbGljZSh5ZWFyU3RhcnRJbmRleCwgeWVhclN0YXJ0SW5kZXggKyA0KS5sZW5ndGggPT09IDQ7XG5cblx0ICAgICAgICAgICAgZGF0ZSA9IFswLCBtb250aCwgeWVhcl07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZGF0ZSA9IG93bmVyLmdldFJhbmdlRml4ZWREYXRlKGRhdGUpO1xuXHQgICAgICAgIG93bmVyLmRhdGUgPSBkYXRlO1xuXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGUubGVuZ3RoID09PSAwID8gdmFsdWUgOiBkYXRlUGF0dGVybi5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoY3VycmVudCkge1xuXHQgICAgICAgICAgICBjYXNlICdkJzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91cyArIChkYXRlWzBdID09PSAwID8gJycgOiBvd25lci5hZGRMZWFkaW5nWmVybyhkYXRlWzBdKSk7XG5cdCAgICAgICAgICAgIGNhc2UgJ20nOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzICsgKGRhdGVbMV0gPT09IDAgPyAnJyA6IG93bmVyLmFkZExlYWRpbmdaZXJvKGRhdGVbMV0pKTtcblx0ICAgICAgICAgICAgY2FzZSAneSc6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyAoZnVsbFllYXJEb25lID8gb3duZXIuYWRkTGVhZGluZ1plcm9Gb3JZZWFyKGRhdGVbMl0sIGZhbHNlKSA6ICcnKTtcblx0ICAgICAgICAgICAgY2FzZSAnWSc6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyAoZnVsbFllYXJEb25lID8gb3duZXIuYWRkTGVhZGluZ1plcm9Gb3JZZWFyKGRhdGVbMl0sIHRydWUpIDogJycpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSwgJycpO1xuXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH0sXG5cblx0ICAgIGdldFJhbmdlRml4ZWREYXRlOiBmdW5jdGlvbiAoZGF0ZSkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsXG5cdCAgICAgICAgICAgIGRhdGVQYXR0ZXJuID0gb3duZXIuZGF0ZVBhdHRlcm4sXG5cdCAgICAgICAgICAgIGRhdGVNaW4gPSBvd25lci5kYXRlTWluIHx8IFtdLFxuXHQgICAgICAgICAgICBkYXRlTWF4ID0gb3duZXIuZGF0ZU1heCB8fCBbXTtcblxuXHQgICAgICAgIGlmICghZGF0ZS5sZW5ndGggfHwgKGRhdGVNaW4ubGVuZ3RoIDwgMyAmJiBkYXRlTWF4Lmxlbmd0aCA8IDMpKSByZXR1cm4gZGF0ZTtcblxuXHQgICAgICAgIGlmIChcblx0ICAgICAgICAgIGRhdGVQYXR0ZXJuLmZpbmQoZnVuY3Rpb24oeCkge1xuXHQgICAgICAgICAgICByZXR1cm4geC50b0xvd2VyQ2FzZSgpID09PSAneSc7XG5cdCAgICAgICAgICB9KSAmJlxuXHQgICAgICAgICAgZGF0ZVsyXSA9PT0gMFxuXHQgICAgICAgICkgcmV0dXJuIGRhdGU7XG5cblx0ICAgICAgICBpZiAoZGF0ZU1heC5sZW5ndGggJiYgKGRhdGVNYXhbMl0gPCBkYXRlWzJdIHx8IChcblx0ICAgICAgICAgIGRhdGVNYXhbMl0gPT09IGRhdGVbMl0gJiYgKGRhdGVNYXhbMV0gPCBkYXRlWzFdIHx8IChcblx0ICAgICAgICAgICAgZGF0ZU1heFsxXSA9PT0gZGF0ZVsxXSAmJiBkYXRlTWF4WzBdIDwgZGF0ZVswXVxuXHQgICAgICAgICAgKSlcblx0ICAgICAgICApKSkgcmV0dXJuIGRhdGVNYXg7XG5cblx0ICAgICAgICBpZiAoZGF0ZU1pbi5sZW5ndGggJiYgKGRhdGVNaW5bMl0gPiBkYXRlWzJdIHx8IChcblx0ICAgICAgICAgIGRhdGVNaW5bMl0gPT09IGRhdGVbMl0gJiYgKGRhdGVNaW5bMV0gPiBkYXRlWzFdIHx8IChcblx0ICAgICAgICAgICAgZGF0ZU1pblsxXSA9PT0gZGF0ZVsxXSAmJiBkYXRlTWluWzBdID4gZGF0ZVswXVxuXHQgICAgICAgICAgKSlcblx0ICAgICAgICApKSkgcmV0dXJuIGRhdGVNaW47XG5cblx0ICAgICAgICByZXR1cm4gZGF0ZTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEZpeGVkRGF0ZTogZnVuY3Rpb24gKGRheSwgbW9udGgsIHllYXIpIHtcblx0ICAgICAgICBkYXkgPSBNYXRoLm1pbihkYXksIDMxKTtcblx0ICAgICAgICBtb250aCA9IE1hdGgubWluKG1vbnRoLCAxMik7XG5cdCAgICAgICAgeWVhciA9IHBhcnNlSW50KCh5ZWFyIHx8IDApLCAxMCk7XG5cblx0ICAgICAgICBpZiAoKG1vbnRoIDwgNyAmJiBtb250aCAlIDIgPT09IDApIHx8IChtb250aCA+IDggJiYgbW9udGggJSAyID09PSAxKSkge1xuXHQgICAgICAgICAgICBkYXkgPSBNYXRoLm1pbihkYXksIG1vbnRoID09PSAyID8gKHRoaXMuaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpIDogMzApO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBbZGF5LCBtb250aCwgeWVhcl07XG5cdCAgICB9LFxuXG5cdCAgICBpc0xlYXBZZWFyOiBmdW5jdGlvbiAoeWVhcikge1xuXHQgICAgICAgIHJldHVybiAoKHllYXIgJSA0ID09PSAwKSAmJiAoeWVhciAlIDEwMCAhPT0gMCkpIHx8ICh5ZWFyICUgNDAwID09PSAwKTtcblx0ICAgIH0sXG5cblx0ICAgIGFkZExlYWRpbmdaZXJvOiBmdW5jdGlvbiAobnVtYmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIChudW1iZXIgPCAxMCA/ICcwJyA6ICcnKSArIG51bWJlcjtcblx0ICAgIH0sXG5cblx0ICAgIGFkZExlYWRpbmdaZXJvRm9yWWVhcjogZnVuY3Rpb24gKG51bWJlciwgZnVsbFllYXJNb2RlKSB7XG5cdCAgICAgICAgaWYgKGZ1bGxZZWFyTW9kZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gKG51bWJlciA8IDEwID8gJzAwMCcgOiAobnVtYmVyIDwgMTAwID8gJzAwJyA6IChudW1iZXIgPCAxMDAwID8gJzAnIDogJycpKSkgKyBudW1iZXI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIChudW1iZXIgPCAxMCA/ICcwJyA6ICcnKSArIG51bWJlcjtcblx0ICAgIH1cblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IERhdGVGb3JtYXR0ZXI7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBUaW1lRm9ybWF0dGVyID0gZnVuY3Rpb24gKHRpbWVQYXR0ZXJuLCB0aW1lRm9ybWF0KSB7XG5cdCAgICB2YXIgb3duZXIgPSB0aGlzO1xuXG5cdCAgICBvd25lci50aW1lID0gW107XG5cdCAgICBvd25lci5ibG9ja3MgPSBbXTtcblx0ICAgIG93bmVyLnRpbWVQYXR0ZXJuID0gdGltZVBhdHRlcm47XG5cdCAgICBvd25lci50aW1lRm9ybWF0ID0gdGltZUZvcm1hdDtcblx0ICAgIG93bmVyLmluaXRCbG9ja3MoKTtcblx0fTtcblxuXHRUaW1lRm9ybWF0dGVyLnByb3RvdHlwZSA9IHtcblx0ICAgIGluaXRCbG9ja3M6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzO1xuXHQgICAgICAgIG93bmVyLnRpbWVQYXR0ZXJuLmZvckVhY2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBvd25lci5ibG9ja3MucHVzaCgyKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH0sXG5cblx0ICAgIGdldElTT0Zvcm1hdFRpbWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICB0aW1lID0gb3duZXIudGltZTtcblxuXHQgICAgICAgIHJldHVybiB0aW1lWzJdID8gKFxuXHQgICAgICAgICAgICBvd25lci5hZGRMZWFkaW5nWmVybyh0aW1lWzBdKSArICc6JyArIG93bmVyLmFkZExlYWRpbmdaZXJvKHRpbWVbMV0pICsgJzonICsgb3duZXIuYWRkTGVhZGluZ1plcm8odGltZVsyXSlcblx0ICAgICAgICApIDogJyc7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRCbG9ja3M6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5ibG9ja3M7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRUaW1lRm9ybWF0T3B0aW9uczogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXM7XG5cdCAgICAgICAgaWYgKFN0cmluZyhvd25lci50aW1lRm9ybWF0KSA9PT0gJzEyJykge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgbWF4SG91ckZpcnN0RGlnaXQ6IDEsXG5cdCAgICAgICAgICAgICAgICBtYXhIb3VyczogMTIsXG5cdCAgICAgICAgICAgICAgICBtYXhNaW51dGVzRmlyc3REaWdpdDogNSxcblx0ICAgICAgICAgICAgICAgIG1heE1pbnV0ZXM6IDYwXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgbWF4SG91ckZpcnN0RGlnaXQ6IDIsXG5cdCAgICAgICAgICAgIG1heEhvdXJzOiAyMyxcblx0ICAgICAgICAgICAgbWF4TWludXRlc0ZpcnN0RGlnaXQ6IDUsXG5cdCAgICAgICAgICAgIG1heE1pbnV0ZXM6IDYwXG5cdCAgICAgICAgfTtcblx0ICAgIH0sXG5cblx0ICAgIGdldFZhbGlkYXRlZFRpbWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBvd25lciA9IHRoaXMsIHJlc3VsdCA9ICcnO1xuXG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcZF0vZywgJycpO1xuXG5cdCAgICAgICAgdmFyIHRpbWVGb3JtYXRPcHRpb25zID0gb3duZXIuZ2V0VGltZUZvcm1hdE9wdGlvbnMoKTtcblxuXHQgICAgICAgIG93bmVyLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChsZW5ndGgsIGluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3ViID0gdmFsdWUuc2xpY2UoMCwgbGVuZ3RoKSxcblx0ICAgICAgICAgICAgICAgICAgICBzdWIwID0gc3ViLnNsaWNlKDAsIDEpLFxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3QgPSB2YWx1ZS5zbGljZShsZW5ndGgpO1xuXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKG93bmVyLnRpbWVQYXR0ZXJuW2luZGV4XSkge1xuXG5cdCAgICAgICAgICAgICAgICBjYXNlICdoJzpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoc3ViMCwgMTApID4gdGltZUZvcm1hdE9wdGlvbnMubWF4SG91ckZpcnN0RGlnaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gJzAnICsgc3ViMDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHN1YiwgMTApID4gdGltZUZvcm1hdE9wdGlvbnMubWF4SG91cnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gdGltZUZvcm1hdE9wdGlvbnMubWF4SG91cnMgKyAnJztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG5cdCAgICAgICAgICAgICAgICBjYXNlICdzJzpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoc3ViMCwgMTApID4gdGltZUZvcm1hdE9wdGlvbnMubWF4TWludXRlc0ZpcnN0RGlnaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ViID0gJzAnICsgc3ViMDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHN1YiwgMTApID4gdGltZUZvcm1hdE9wdGlvbnMubWF4TWludXRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWIgPSB0aW1lRm9ybWF0T3B0aW9ucy5tYXhNaW51dGVzICsgJyc7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3ViO1xuXG5cdCAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcmVtYWluaW5nIHN0cmluZ1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRGaXhlZFRpbWVTdHJpbmcocmVzdWx0KTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEZpeGVkVGltZVN0cmluZzogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcywgdGltZVBhdHRlcm4gPSBvd25lci50aW1lUGF0dGVybiwgdGltZSA9IFtdLFxuXHQgICAgICAgICAgICBzZWNvbmRJbmRleCA9IDAsIG1pbnV0ZUluZGV4ID0gMCwgaG91ckluZGV4ID0gMCxcblx0ICAgICAgICAgICAgc2Vjb25kU3RhcnRJbmRleCA9IDAsIG1pbnV0ZVN0YXJ0SW5kZXggPSAwLCBob3VyU3RhcnRJbmRleCA9IDAsXG5cdCAgICAgICAgICAgIHNlY29uZCwgbWludXRlLCBob3VyO1xuXG5cdCAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gNikge1xuXHQgICAgICAgICAgICB0aW1lUGF0dGVybi5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdzJzpcblx0ICAgICAgICAgICAgICAgICAgICBzZWNvbmRJbmRleCA9IGluZGV4ICogMjtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuXHQgICAgICAgICAgICAgICAgICAgIG1pbnV0ZUluZGV4ID0gaW5kZXggKiAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG5cdCAgICAgICAgICAgICAgICAgICAgaG91ckluZGV4ID0gaW5kZXggKiAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBob3VyU3RhcnRJbmRleCA9IGhvdXJJbmRleDtcblx0ICAgICAgICAgICAgbWludXRlU3RhcnRJbmRleCA9IG1pbnV0ZUluZGV4O1xuXHQgICAgICAgICAgICBzZWNvbmRTdGFydEluZGV4ID0gc2Vjb25kSW5kZXg7XG5cblx0ICAgICAgICAgICAgc2Vjb25kID0gcGFyc2VJbnQodmFsdWUuc2xpY2Uoc2Vjb25kU3RhcnRJbmRleCwgc2Vjb25kU3RhcnRJbmRleCArIDIpLCAxMCk7XG5cdCAgICAgICAgICAgIG1pbnV0ZSA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKG1pbnV0ZVN0YXJ0SW5kZXgsIG1pbnV0ZVN0YXJ0SW5kZXggKyAyKSwgMTApO1xuXHQgICAgICAgICAgICBob3VyID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoaG91clN0YXJ0SW5kZXgsIGhvdXJTdGFydEluZGV4ICsgMiksIDEwKTtcblxuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy5nZXRGaXhlZFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDQgJiYgb3duZXIudGltZVBhdHRlcm4uaW5kZXhPZigncycpIDwgMCkge1xuXHQgICAgICAgICAgICB0aW1lUGF0dGVybi5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdtJzpcblx0ICAgICAgICAgICAgICAgICAgICBtaW51dGVJbmRleCA9IGluZGV4ICogMjtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxuXHQgICAgICAgICAgICAgICAgICAgIGhvdXJJbmRleCA9IGluZGV4ICogMjtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgaG91clN0YXJ0SW5kZXggPSBob3VySW5kZXg7XG5cdCAgICAgICAgICAgIG1pbnV0ZVN0YXJ0SW5kZXggPSBtaW51dGVJbmRleDtcblxuXHQgICAgICAgICAgICBzZWNvbmQgPSAwO1xuXHQgICAgICAgICAgICBtaW51dGUgPSBwYXJzZUludCh2YWx1ZS5zbGljZShtaW51dGVTdGFydEluZGV4LCBtaW51dGVTdGFydEluZGV4ICsgMiksIDEwKTtcblx0ICAgICAgICAgICAgaG91ciA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKGhvdXJTdGFydEluZGV4LCBob3VyU3RhcnRJbmRleCArIDIpLCAxMCk7XG5cblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMuZ2V0Rml4ZWRUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBvd25lci50aW1lID0gdGltZTtcblxuXHQgICAgICAgIHJldHVybiB0aW1lLmxlbmd0aCA9PT0gMCA/IHZhbHVlIDogdGltZVBhdHRlcm4ucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnQpIHtcblx0ICAgICAgICAgICAgY2FzZSAncyc6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyBvd25lci5hZGRMZWFkaW5nWmVybyh0aW1lWzJdKTtcblx0ICAgICAgICAgICAgY2FzZSAnbSc6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyBvd25lci5hZGRMZWFkaW5nWmVybyh0aW1lWzFdKTtcblx0ICAgICAgICAgICAgY2FzZSAnaCc6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyBvd25lci5hZGRMZWFkaW5nWmVybyh0aW1lWzBdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sICcnKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEZpeGVkVGltZTogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSB7XG5cdCAgICAgICAgc2Vjb25kID0gTWF0aC5taW4ocGFyc2VJbnQoc2Vjb25kIHx8IDAsIDEwKSwgNjApO1xuXHQgICAgICAgIG1pbnV0ZSA9IE1hdGgubWluKG1pbnV0ZSwgNjApO1xuXHQgICAgICAgIGhvdXIgPSBNYXRoLm1pbihob3VyLCA2MCk7XG5cblx0ICAgICAgICByZXR1cm4gW2hvdXIsIG1pbnV0ZSwgc2Vjb25kXTtcblx0ICAgIH0sXG5cblx0ICAgIGFkZExlYWRpbmdaZXJvOiBmdW5jdGlvbiAobnVtYmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIChudW1iZXIgPCAxMCA/ICcwJyA6ICcnKSArIG51bWJlcjtcblx0ICAgIH1cblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFRpbWVGb3JtYXR0ZXI7XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBQaG9uZUZvcm1hdHRlciA9IGZ1bmN0aW9uIChmb3JtYXR0ZXIsIGRlbGltaXRlcikge1xuXHQgICAgdmFyIG93bmVyID0gdGhpcztcblxuXHQgICAgb3duZXIuZGVsaW1pdGVyID0gKGRlbGltaXRlciB8fCBkZWxpbWl0ZXIgPT09ICcnKSA/IGRlbGltaXRlciA6ICcgJztcblx0ICAgIG93bmVyLmRlbGltaXRlclJFID0gZGVsaW1pdGVyID8gbmV3IFJlZ0V4cCgnXFxcXCcgKyBkZWxpbWl0ZXIsICdnJykgOiAnJztcblxuXHQgICAgb3duZXIuZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuXHR9O1xuXG5cdFBob25lRm9ybWF0dGVyLnByb3RvdHlwZSA9IHtcblx0ICAgIHNldEZvcm1hdHRlcjogZnVuY3Rpb24gKGZvcm1hdHRlcikge1xuXHQgICAgICAgIHRoaXMuZm9ybWF0dGVyID0gZm9ybWF0dGVyO1xuXHQgICAgfSxcblxuXHQgICAgZm9ybWF0OiBmdW5jdGlvbiAocGhvbmVOdW1iZXIpIHtcblx0ICAgICAgICB2YXIgb3duZXIgPSB0aGlzO1xuXG5cdCAgICAgICAgb3duZXIuZm9ybWF0dGVyLmNsZWFyKCk7XG5cblx0ICAgICAgICAvLyBvbmx5IGtlZXAgbnVtYmVyIGFuZCArXG5cdCAgICAgICAgcGhvbmVOdW1iZXIgPSBwaG9uZU51bWJlci5yZXBsYWNlKC9bXlxcZCtdL2csICcnKTtcblxuXHQgICAgICAgIC8vIHN0cmlwIG5vbi1sZWFkaW5nICtcblx0ICAgICAgICBwaG9uZU51bWJlciA9IHBob25lTnVtYmVyLnJlcGxhY2UoL15cXCsvLCAnQicpLnJlcGxhY2UoL1xcKy9nLCAnJykucmVwbGFjZSgnQicsICcrJyk7XG5cblx0ICAgICAgICAvLyBzdHJpcCBkZWxpbWl0ZXJcblx0ICAgICAgICBwaG9uZU51bWJlciA9IHBob25lTnVtYmVyLnJlcGxhY2Uob3duZXIuZGVsaW1pdGVyUkUsICcnKTtcblxuXHQgICAgICAgIHZhciByZXN1bHQgPSAnJywgY3VycmVudCwgdmFsaWRhdGVkID0gZmFsc2U7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IHBob25lTnVtYmVyLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuXHQgICAgICAgICAgICBjdXJyZW50ID0gb3duZXIuZm9ybWF0dGVyLmlucHV0RGlnaXQocGhvbmVOdW1iZXIuY2hhckF0KGkpKTtcblxuXHQgICAgICAgICAgICAvLyBoYXMgKCktIG9yIHNwYWNlIGluc2lkZVxuXHQgICAgICAgICAgICBpZiAoL1tcXHMoKS1dL2cudGVzdChjdXJyZW50KSkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gY3VycmVudDtcblxuXHQgICAgICAgICAgICAgICAgdmFsaWRhdGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY3VycmVudDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIGVsc2U6IG92ZXIgbGVuZ3RoIGlucHV0XG5cdCAgICAgICAgICAgICAgICAvLyBpdCB0dXJucyB0byBpbnZhbGlkIG51bWJlciBhZ2FpblxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gc3RyaXAgKClcblx0ICAgICAgICAvLyBlLmcuIFVTOiA3MTYxMjM0NTY3IHJldHVybnMgKDcxNikgMTIzLTQ1Njdcblx0ICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvWygpXS9nLCAnJyk7XG5cdCAgICAgICAgLy8gcmVwbGFjZSBsaWJyYXJ5IGRlbGltaXRlciB3aXRoIHVzZXIgY3VzdG9taXplZCBkZWxpbWl0ZXJcblx0ICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvW1xccy1dL2csIG93bmVyLmRlbGltaXRlcik7XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gUGhvbmVGb3JtYXR0ZXI7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBDcmVkaXRDYXJkRGV0ZWN0b3IgPSB7XG5cdCAgICBibG9ja3M6IHtcblx0ICAgICAgICB1YXRwOiAgICAgICAgICBbNCwgNSwgNl0sXG5cdCAgICAgICAgYW1leDogICAgICAgICAgWzQsIDYsIDVdLFxuXHQgICAgICAgIGRpbmVyczogICAgICAgIFs0LCA2LCA0XSxcblx0ICAgICAgICBkaXNjb3ZlcjogICAgICBbNCwgNCwgNCwgNF0sXG5cdCAgICAgICAgbWFzdGVyY2FyZDogICAgWzQsIDQsIDQsIDRdLFxuXHQgICAgICAgIGRhbmtvcnQ6ICAgICAgIFs0LCA0LCA0LCA0XSxcblx0ICAgICAgICBpbnN0YXBheW1lbnQ6ICBbNCwgNCwgNCwgNF0sXG5cdCAgICAgICAgamNiMTU6ICAgICAgICAgWzQsIDYsIDVdLFxuXHQgICAgICAgIGpjYjogICAgICAgICAgIFs0LCA0LCA0LCA0XSxcblx0ICAgICAgICBtYWVzdHJvOiAgICAgICBbNCwgNCwgNCwgNF0sXG5cdCAgICAgICAgdmlzYTogICAgICAgICAgWzQsIDQsIDQsIDRdLFxuXHQgICAgICAgIG1pcjogICAgICAgICAgIFs0LCA0LCA0LCA0XSxcblx0ICAgICAgICB1bmlvblBheTogICAgICBbNCwgNCwgNCwgNF0sXG5cdCAgICAgICAgZ2VuZXJhbDogICAgICAgWzQsIDQsIDQsIDRdXG5cdCAgICB9LFxuXG5cdCAgICByZToge1xuXHQgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDE7IDE1IGRpZ2l0cywgbm90IHN0YXJ0cyB3aXRoIDE4MDAgKGpjYiBjYXJkKVxuXHQgICAgICAgIHVhdHA6IC9eKD8hMTgwMCkxXFxkezAsMTR9LyxcblxuXHQgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDM0LzM3OyAxNSBkaWdpdHNcblx0ICAgICAgICBhbWV4OiAvXjNbNDddXFxkezAsMTN9LyxcblxuXHQgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDYwMTEvNjUvNjQ0LTY0OTsgMTYgZGlnaXRzXG5cdCAgICAgICAgZGlzY292ZXI6IC9eKD86NjAxMXw2NVxcZHswLDJ9fDY0WzQtOV1cXGQ/KVxcZHswLDEyfS8sXG5cblx0ICAgICAgICAvLyBzdGFydHMgd2l0aCAzMDAtMzA1LzMwOSBvciAzNi8zOC8zOTsgMTQgZGlnaXRzXG5cdCAgICAgICAgZGluZXJzOiAvXjMoPzowKFswLTVdfDkpfFs2ODldXFxkPylcXGR7MCwxMX0vLFxuXG5cdCAgICAgICAgLy8gc3RhcnRzIHdpdGggNTEtNTUvMjIyMeKAkzI3MjA7IDE2IGRpZ2l0c1xuXHQgICAgICAgIG1hc3RlcmNhcmQ6IC9eKDVbMS01XVxcZHswLDJ9fDIyWzItOV1cXGR7MCwxfXwyWzMtN11cXGR7MCwyfSlcXGR7MCwxMn0vLFxuXG5cdCAgICAgICAgLy8gc3RhcnRzIHdpdGggNTAxOS80MTc1LzQ1NzE7IDE2IGRpZ2l0c1xuXHQgICAgICAgIGRhbmtvcnQ6IC9eKDUwMTl8NDE3NXw0NTcxKVxcZHswLDEyfS8sXG5cblx0ICAgICAgICAvLyBzdGFydHMgd2l0aCA2MzctNjM5OyAxNiBkaWdpdHNcblx0ICAgICAgICBpbnN0YXBheW1lbnQ6IC9eNjNbNy05XVxcZHswLDEzfS8sXG5cblx0ICAgICAgICAvLyBzdGFydHMgd2l0aCAyMTMxLzE4MDA7IDE1IGRpZ2l0c1xuXHQgICAgICAgIGpjYjE1OiAvXig/OjIxMzF8MTgwMClcXGR7MCwxMX0vLFxuXG5cdCAgICAgICAgLy8gc3RhcnRzIHdpdGggMjEzMS8xODAwLzM1OyAxNiBkaWdpdHNcblx0ICAgICAgICBqY2I6IC9eKD86MzVcXGR7MCwyfSlcXGR7MCwxMn0vLFxuXG5cdCAgICAgICAgLy8gc3RhcnRzIHdpdGggNTAvNTYtNTgvNjMwNC82NzsgMTYgZGlnaXRzXG5cdCAgICAgICAgbWFlc3RybzogL14oPzo1WzA2NzhdXFxkezAsMn18NjMwNHw2N1xcZHswLDJ9KVxcZHswLDEyfS8sXG5cblx0ICAgICAgICAvLyBzdGFydHMgd2l0aCAyMjsgMTYgZGlnaXRzXG5cdCAgICAgICAgbWlyOiAvXjIyMFswLTRdXFxkezAsMTJ9LyxcblxuXHQgICAgICAgIC8vIHN0YXJ0cyB3aXRoIDQ7IDE2IGRpZ2l0c1xuXHQgICAgICAgIHZpc2E6IC9eNFxcZHswLDE1fS8sXG5cblx0ICAgICAgICAvLyBzdGFydHMgd2l0aCA2Mi84MTsgMTYgZGlnaXRzXG5cdCAgICAgICAgdW5pb25QYXk6IC9eKDYyfDgxKVxcZHswLDE0fS9cblx0ICAgIH0sXG5cblx0ICAgIGdldFN0cmljdEJsb2NrczogZnVuY3Rpb24gKGJsb2NrKSB7XG5cdCAgICAgIHZhciB0b3RhbCA9IGJsb2NrLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VycmVudCkge1xuXHQgICAgICAgIHJldHVybiBwcmV2ICsgY3VycmVudDtcblx0ICAgICAgfSwgMCk7XG5cblx0ICAgICAgcmV0dXJuIGJsb2NrLmNvbmNhdCgxOSAtIHRvdGFsKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEluZm86IGZ1bmN0aW9uICh2YWx1ZSwgc3RyaWN0TW9kZSkge1xuXHQgICAgICAgIHZhciBibG9ja3MgPSBDcmVkaXRDYXJkRGV0ZWN0b3IuYmxvY2tzLFxuXHQgICAgICAgICAgICByZSA9IENyZWRpdENhcmREZXRlY3Rvci5yZTtcblxuXHQgICAgICAgIC8vIFNvbWUgY3JlZGl0IGNhcmQgY2FuIGhhdmUgdXAgdG8gMTkgZGlnaXRzIG51bWJlci5cblx0ICAgICAgICAvLyBTZXQgc3RyaWN0TW9kZSB0byB0cnVlIHdpbGwgcmVtb3ZlIHRoZSAxNiBtYXgtbGVuZ3RoIHJlc3RyYWluLFxuXHQgICAgICAgIC8vIGhvd2V2ZXIsIEkgbmV2ZXIgZm91bmQgYW55IHdlYnNpdGUgdmFsaWRhdGUgY2FyZCBudW1iZXIgbGlrZVxuXHQgICAgICAgIC8vIHRoaXMsIGhlbmNlIHByb2JhYmx5IHlvdSBkb24ndCB3YW50IHRvIGVuYWJsZSB0aGlzIG9wdGlvbi5cblx0ICAgICAgICBzdHJpY3RNb2RlID0gISFzdHJpY3RNb2RlO1xuXG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIHJlKSB7XG5cdCAgICAgICAgICAgIGlmIChyZVtrZXldLnRlc3QodmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZEJsb2NrcyA9IGJsb2Nrc1trZXldO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiBrZXksXG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2tzOiBzdHJpY3RNb2RlID8gdGhpcy5nZXRTdHJpY3RCbG9ja3MobWF0Y2hlZEJsb2NrcykgOiBtYXRjaGVkQmxvY2tzXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdHlwZTogJ3Vua25vd24nLFxuXHQgICAgICAgICAgICBibG9ja3M6IHN0cmljdE1vZGUgPyB0aGlzLmdldFN0cmljdEJsb2NrcyhibG9ja3MuZ2VuZXJhbCkgOiBibG9ja3MuZ2VuZXJhbFxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBDcmVkaXRDYXJkRGV0ZWN0b3I7XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBVdGlsID0ge1xuXHQgICAgbm9vcDogZnVuY3Rpb24gKCkge1xuXHQgICAgfSxcblxuXHQgICAgc3RyaXA6IGZ1bmN0aW9uICh2YWx1ZSwgcmUpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgJycpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0UG9zdERlbGltaXRlcjogZnVuY3Rpb24gKHZhbHVlLCBkZWxpbWl0ZXIsIGRlbGltaXRlcnMpIHtcblx0ICAgICAgICAvLyBzaW5nbGUgZGVsaW1pdGVyXG5cdCAgICAgICAgaWYgKGRlbGltaXRlcnMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlciA/IGRlbGltaXRlciA6ICcnO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIG11bHRpcGxlIGRlbGltaXRlcnNcblx0ICAgICAgICB2YXIgbWF0Y2hlZERlbGltaXRlciA9ICcnO1xuXHQgICAgICAgIGRlbGltaXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudCkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUuc2xpY2UoLWN1cnJlbnQubGVuZ3RoKSA9PT0gY3VycmVudCkge1xuXHQgICAgICAgICAgICAgICAgbWF0Y2hlZERlbGltaXRlciA9IGN1cnJlbnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHJldHVybiBtYXRjaGVkRGVsaW1pdGVyO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0RGVsaW1pdGVyUkVCeURlbGltaXRlcjogZnVuY3Rpb24gKGRlbGltaXRlcikge1xuXHQgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGRlbGltaXRlci5yZXBsYWNlKC8oWy4/KiteJFtcXF1cXFxcKCl7fXwtXSkvZywgJ1xcXFwkMScpLCAnZycpO1xuXHQgICAgfSxcblxuXHQgICAgZ2V0TmV4dEN1cnNvclBvc2l0aW9uOiBmdW5jdGlvbiAocHJldlBvcywgb2xkVmFsdWUsIG5ld1ZhbHVlLCBkZWxpbWl0ZXIsIGRlbGltaXRlcnMpIHtcblx0ICAgICAgLy8gSWYgY3Vyc29yIHdhcyBhdCB0aGUgZW5kIG9mIHZhbHVlLCBqdXN0IHBsYWNlIGl0IGJhY2suXG5cdCAgICAgIC8vIEJlY2F1c2UgbmV3IHZhbHVlIGNvdWxkIGNvbnRhaW4gYWRkaXRpb25hbCBjaGFycy5cblx0ICAgICAgaWYgKG9sZFZhbHVlLmxlbmd0aCA9PT0gcHJldlBvcykge1xuXHQgICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlLmxlbmd0aDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBwcmV2UG9zICsgdGhpcy5nZXRQb3NpdGlvbk9mZnNldChwcmV2UG9zLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGRlbGltaXRlciAsZGVsaW1pdGVycyk7XG5cdCAgICB9LFxuXG5cdCAgICBnZXRQb3NpdGlvbk9mZnNldDogZnVuY3Rpb24gKHByZXZQb3MsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzKSB7XG5cdCAgICAgICAgdmFyIG9sZFJhd1ZhbHVlLCBuZXdSYXdWYWx1ZSwgbGVuZ3RoT2Zmc2V0O1xuXG5cdCAgICAgICAgb2xkUmF3VmFsdWUgPSB0aGlzLnN0cmlwRGVsaW1pdGVycyhvbGRWYWx1ZS5zbGljZSgwLCBwcmV2UG9zKSwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzKTtcblx0ICAgICAgICBuZXdSYXdWYWx1ZSA9IHRoaXMuc3RyaXBEZWxpbWl0ZXJzKG5ld1ZhbHVlLnNsaWNlKDAsIHByZXZQb3MpLCBkZWxpbWl0ZXIsIGRlbGltaXRlcnMpO1xuXHQgICAgICAgIGxlbmd0aE9mZnNldCA9IG9sZFJhd1ZhbHVlLmxlbmd0aCAtIG5ld1Jhd1ZhbHVlLmxlbmd0aDtcblxuXHQgICAgICAgIHJldHVybiAobGVuZ3RoT2Zmc2V0ICE9PSAwKSA/IChsZW5ndGhPZmZzZXQgLyBNYXRoLmFicyhsZW5ndGhPZmZzZXQpKSA6IDA7XG5cdCAgICB9LFxuXG5cdCAgICBzdHJpcERlbGltaXRlcnM6IGZ1bmN0aW9uICh2YWx1ZSwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzKSB7XG5cdCAgICAgICAgdmFyIG93bmVyID0gdGhpcztcblxuXHQgICAgICAgIC8vIHNpbmdsZSBkZWxpbWl0ZXJcblx0ICAgICAgICBpZiAoZGVsaW1pdGVycy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgdmFyIGRlbGltaXRlclJFID0gZGVsaW1pdGVyID8gb3duZXIuZ2V0RGVsaW1pdGVyUkVCeURlbGltaXRlcihkZWxpbWl0ZXIpIDogJyc7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoZGVsaW1pdGVyUkUsICcnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBtdWx0aXBsZSBkZWxpbWl0ZXJzXG5cdCAgICAgICAgZGVsaW1pdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50KSB7XG5cdCAgICAgICAgICAgIGN1cnJlbnQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKG93bmVyLmdldERlbGltaXRlclJFQnlEZWxpbWl0ZXIobGV0dGVyKSwgJycpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH0sXG5cblx0ICAgIGhlYWRTdHI6IGZ1bmN0aW9uIChzdHIsIGxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBzdHIuc2xpY2UoMCwgbGVuZ3RoKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldE1heExlbmd0aDogZnVuY3Rpb24gKGJsb2Nrcykge1xuXHQgICAgICAgIHJldHVybiBibG9ja3MucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcHJldmlvdXMgKyBjdXJyZW50O1xuXHQgICAgICAgIH0sIDApO1xuXHQgICAgfSxcblxuXHQgICAgLy8gc3RyaXAgcHJlZml4XG5cdCAgICAvLyBCZWZvcmUgdHlwZSAgfCAgIEFmdGVyIHR5cGUgICAgfCAgICAgUmV0dXJuIHZhbHVlXG5cdCAgICAvLyBQRUZJWC0uLi4gICAgfCAgIFBFRklYLS4uLiAgICAgfCAgICAgJydcblx0ICAgIC8vIFBSRUZJWC0xMjMgICB8ICAgUEVGSVgtMTIzICAgICB8ICAgICAxMjNcblx0ICAgIC8vIFBSRUZJWC0xMjMgICB8ICAgUFJFRklYLTIzICAgICB8ICAgICAyM1xuXHQgICAgLy8gUFJFRklYLTEyMyAgIHwgICBQUkVGSVgtMTIzNCAgIHwgICAgIDEyMzRcblx0ICAgIGdldFByZWZpeFN0cmlwcGVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgcHJlZml4LCBwcmVmaXhMZW5ndGgsIHByZXZSZXN1bHQsIGRlbGltaXRlciwgZGVsaW1pdGVycywgbm9JbW1lZGlhdGVQcmVmaXgsIHRhaWxQcmVmaXgsIHNpZ25CZWZvcmVQcmVmaXgpIHtcblx0ICAgICAgICAvLyBObyBwcmVmaXhcblx0ICAgICAgICBpZiAocHJlZml4TGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gVmFsdWUgaXMgcHJlZml4XG5cdCAgICAgICAgaWYgKHZhbHVlID09PSBwcmVmaXggJiYgdmFsdWUgIT09ICcnKSB7XG5cdCAgICAgICAgICByZXR1cm4gJyc7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHNpZ25CZWZvcmVQcmVmaXggJiYgKHZhbHVlLnNsaWNlKDAsIDEpID09ICctJykpIHtcblx0ICAgICAgICAgICAgdmFyIHByZXYgPSAocHJldlJlc3VsdC5zbGljZSgwLCAxKSA9PSAnLScpID8gcHJldlJlc3VsdC5zbGljZSgxKSA6IHByZXZSZXN1bHQ7XG5cdCAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLmdldFByZWZpeFN0cmlwcGVkVmFsdWUodmFsdWUuc2xpY2UoMSksIHByZWZpeCwgcHJlZml4TGVuZ3RoLCBwcmV2LCBkZWxpbWl0ZXIsIGRlbGltaXRlcnMsIG5vSW1tZWRpYXRlUHJlZml4LCB0YWlsUHJlZml4LCBzaWduQmVmb3JlUHJlZml4KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBQcmUgcmVzdWx0IHByZWZpeCBzdHJpbmcgZG9lcyBub3QgbWF0Y2ggcHJlLWRlZmluZWQgcHJlZml4XG5cdCAgICAgICAgaWYgKHByZXZSZXN1bHQuc2xpY2UoMCwgcHJlZml4TGVuZ3RoKSAhPT0gcHJlZml4ICYmICF0YWlsUHJlZml4KSB7XG5cdCAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCB0aW1lIHVzZXIgZW50ZXJlZCBzb21ldGhpbmdcblx0ICAgICAgICAgICAgaWYgKG5vSW1tZWRpYXRlUHJlZml4ICYmICFwcmV2UmVzdWx0ICYmIHZhbHVlKSByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIHJldHVybiAnJztcblx0ICAgICAgICB9IGVsc2UgaWYgKHByZXZSZXN1bHQuc2xpY2UoLXByZWZpeExlbmd0aCkgIT09IHByZWZpeCAmJiB0YWlsUHJlZml4KSB7XG5cdCAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCB0aW1lIHVzZXIgZW50ZXJlZCBzb21ldGhpbmdcblx0ICAgICAgICAgICAgaWYgKG5vSW1tZWRpYXRlUHJlZml4ICYmICFwcmV2UmVzdWx0ICYmIHZhbHVlKSByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIHJldHVybiAnJztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcHJldlZhbHVlID0gdGhpcy5zdHJpcERlbGltaXRlcnMocHJldlJlc3VsdCwgZGVsaW1pdGVyLCBkZWxpbWl0ZXJzKTtcblxuXHQgICAgICAgIC8vIE5ldyB2YWx1ZSBoYXMgaXNzdWUsIHNvbWVvbmUgdHlwZWQgaW4gYmV0d2VlbiBwcmVmaXggbGV0dGVyc1xuXHQgICAgICAgIC8vIFJldmVydCB0byBwcmUgdmFsdWVcblx0ICAgICAgICBpZiAodmFsdWUuc2xpY2UoMCwgcHJlZml4TGVuZ3RoKSAhPT0gcHJlZml4ICYmICF0YWlsUHJlZml4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBwcmV2VmFsdWUuc2xpY2UocHJlZml4TGVuZ3RoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLnNsaWNlKC1wcmVmaXhMZW5ndGgpICE9PSBwcmVmaXggJiYgdGFpbFByZWZpeCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcHJldlZhbHVlLnNsaWNlKDAsIC1wcmVmaXhMZW5ndGggLSAxKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBObyBpc3N1ZSwgc3RyaXAgcHJlZml4IGZvciBuZXcgdmFsdWVcblx0ICAgICAgICByZXR1cm4gdGFpbFByZWZpeCA/IHZhbHVlLnNsaWNlKDAsIC1wcmVmaXhMZW5ndGgpIDogdmFsdWUuc2xpY2UocHJlZml4TGVuZ3RoKTtcblx0ICAgIH0sXG5cblx0ICAgIGdldEZpcnN0RGlmZkluZGV4OiBmdW5jdGlvbiAocHJldiwgY3VycmVudCkge1xuXHQgICAgICAgIHZhciBpbmRleCA9IDA7XG5cblx0ICAgICAgICB3aGlsZSAocHJldi5jaGFyQXQoaW5kZXgpID09PSBjdXJyZW50LmNoYXJBdChpbmRleCkpIHtcblx0ICAgICAgICAgICAgaWYgKHByZXYuY2hhckF0KGluZGV4KyspID09PSAnJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGluZGV4O1xuXHQgICAgfSxcblxuXHQgICAgZ2V0Rm9ybWF0dGVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgYmxvY2tzLCBibG9ja3NMZW5ndGgsIGRlbGltaXRlciwgZGVsaW1pdGVycywgZGVsaW1pdGVyTGF6eVNob3cpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG5cdCAgICAgICAgICAgIG11bHRpcGxlRGVsaW1pdGVycyA9IGRlbGltaXRlcnMubGVuZ3RoID4gMCxcblx0ICAgICAgICAgICAgY3VycmVudERlbGltaXRlciA9ICcnO1xuXG5cdCAgICAgICAgLy8gbm8gb3B0aW9ucywgbm9ybWFsIGlucHV0XG5cdCAgICAgICAgaWYgKGJsb2Nrc0xlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGxlbmd0aCwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdWIgPSB2YWx1ZS5zbGljZSgwLCBsZW5ndGgpLFxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3QgPSB2YWx1ZS5zbGljZShsZW5ndGgpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGVEZWxpbWl0ZXJzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY3VycmVudERlbGltaXRlciA9IGRlbGltaXRlcnNbZGVsaW1pdGVyTGF6eVNob3cgPyAoaW5kZXggLSAxKSA6IGluZGV4XSB8fCBjdXJyZW50RGVsaW1pdGVyO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVsaW1pdGVyID0gZGVsaW1pdGVyO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoZGVsaW1pdGVyTGF6eVNob3cpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyZW50RGVsaW1pdGVyO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdWI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdWI7XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3ViLmxlbmd0aCA9PT0gbGVuZ3RoICYmIGluZGV4IDwgYmxvY2tzTGVuZ3RoIC0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY3VycmVudERlbGltaXRlcjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSByZW1haW5pbmcgc3RyaW5nXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3Q7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBtb3ZlIGN1cnNvciB0byB0aGUgZW5kXG5cdCAgICAvLyB0aGUgZmlyc3QgdGltZSB1c2VyIGZvY3VzZXMgb24gYW4gaW5wdXQgd2l0aCBwcmVmaXhcblx0ICAgIGZpeFByZWZpeEN1cnNvcjogZnVuY3Rpb24gKGVsLCBwcmVmaXgsIGRlbGltaXRlciwgZGVsaW1pdGVycykge1xuXHQgICAgICAgIGlmICghZWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciB2YWwgPSBlbC52YWx1ZSxcblx0ICAgICAgICAgICAgYXBwZW5kaXggPSBkZWxpbWl0ZXIgfHwgKGRlbGltaXRlcnNbMF0gfHwgJyAnKTtcblxuXHQgICAgICAgIGlmICghZWwuc2V0U2VsZWN0aW9uUmFuZ2UgfHwgIXByZWZpeCB8fCAocHJlZml4Lmxlbmd0aCArIGFwcGVuZGl4Lmxlbmd0aCkgPD0gdmFsLmxlbmd0aCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGxlbiA9IHZhbC5sZW5ndGggKiAyO1xuXG5cdCAgICAgICAgLy8gc2V0IHRpbWVvdXQgdG8gYXZvaWQgYmxpbmtcblx0ICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgZWwuc2V0U2VsZWN0aW9uUmFuZ2UobGVuLCBsZW4pO1xuXHQgICAgICAgIH0sIDEpO1xuXHQgICAgfSxcblxuXHQgICAgLy8gQ2hlY2sgaWYgaW5wdXQgZmllbGQgaXMgZnVsbHkgc2VsZWN0ZWRcblx0ICAgIGNoZWNrRnVsbFNlbGVjdGlvbjogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpIHx8IGRvY3VtZW50LmdldFNlbGVjdGlvbigpIHx8IHt9O1xuXHQgICAgICAgIHJldHVybiBzZWxlY3Rpb24udG9TdHJpbmcoKS5sZW5ndGggPT09IHZhbHVlLmxlbmd0aDtcblx0ICAgICAgfSBjYXRjaCAoZXgpIHtcblx0ICAgICAgICAvLyBJZ25vcmVcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH0sXG5cblx0ICAgIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGVsZW1lbnQsIHBvc2l0aW9uLCBkb2MpIHtcblx0ICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5nZXRBY3RpdmVFbGVtZW50KGRvYykpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGN1cnNvciBpcyBhbHJlYWR5IGluIHRoZSBlbmRcblx0ICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnZhbHVlLmxlbmd0aCA8PSBwb3NpdGlvbikge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChlbGVtZW50LmNyZWF0ZVRleHRSYW5nZSkge1xuXHQgICAgICAgICAgICB2YXIgcmFuZ2UgPSBlbGVtZW50LmNyZWF0ZVRleHRSYW5nZSgpO1xuXG5cdCAgICAgICAgICAgIHJhbmdlLm1vdmUoJ2NoYXJhY3RlcicsIHBvc2l0aW9uKTtcblx0ICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UocG9zaXRpb24sIHBvc2l0aW9uKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBpbnB1dCBlbGVtZW50IHR5cGUgZG9lcyBub3Qgc3VwcG9ydCBzZWxlY3Rpb24nKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cblx0ICAgIGdldEFjdGl2ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBhcmVudCkge1xuXHQgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gcGFyZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdCAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZUVsZW1lbnQoYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG5cdCAgICB9LFxuXG5cdCAgICBpc0FuZHJvaWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbmF2aWdhdG9yICYmIC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblx0ICAgIH0sXG5cblx0ICAgIC8vIE9uIEFuZHJvaWQgY2hyb21lLCB0aGUga2V5dXAgYW5kIGtleWRvd24gZXZlbnRzXG5cdCAgICAvLyBhbHdheXMgcmV0dXJuIGtleSBjb2RlIDIyOSBhcyBhIGNvbXBvc2l0aW9uIHRoYXRcblx0ICAgIC8vIGJ1ZmZlcnMgdGhlIHVzZXLigJlzIGtleXN0cm9rZXNcblx0ICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9zaXIvY2xlYXZlLmpzL2lzc3Vlcy8xNDdcblx0ICAgIGlzQW5kcm9pZEJhY2tzcGFjZUtleWRvd246IGZ1bmN0aW9uIChsYXN0SW5wdXRWYWx1ZSwgY3VycmVudElucHV0VmFsdWUpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuaXNBbmRyb2lkKCkgfHwgIWxhc3RJbnB1dFZhbHVlIHx8ICFjdXJyZW50SW5wdXRWYWx1ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnB1dFZhbHVlID09PSBsYXN0SW5wdXRWYWx1ZS5zbGljZSgwLCAtMSk7XG5cdCAgICB9XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBVdGlsO1xuXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIFByb3BzIEFzc2lnbm1lbnRcblx0ICpcblx0ICogU2VwYXJhdGUgdGhpcywgc28gcmVhY3QgbW9kdWxlIGNhbiBzaGFyZSB0aGUgdXNhZ2Vcblx0ICovXG5cdHZhciBEZWZhdWx0UHJvcGVydGllcyA9IHtcblx0ICAgIC8vIE1heWJlIGNoYW5nZSB0byBvYmplY3QtYXNzaWduXG5cdCAgICAvLyBmb3Igbm93IGp1c3Qga2VlcCBpdCBhcyBzaW1wbGVcblx0ICAgIGFzc2lnbjogZnVuY3Rpb24gKHRhcmdldCwgb3B0cykge1xuXHQgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcblx0ICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuXHQgICAgICAgIC8vIGNyZWRpdCBjYXJkXG5cdCAgICAgICAgdGFyZ2V0LmNyZWRpdENhcmQgPSAhIW9wdHMuY3JlZGl0Q2FyZDtcblx0ICAgICAgICB0YXJnZXQuY3JlZGl0Q2FyZFN0cmljdE1vZGUgPSAhIW9wdHMuY3JlZGl0Q2FyZFN0cmljdE1vZGU7XG5cdCAgICAgICAgdGFyZ2V0LmNyZWRpdENhcmRUeXBlID0gJyc7XG5cdCAgICAgICAgdGFyZ2V0Lm9uQ3JlZGl0Q2FyZFR5cGVDaGFuZ2VkID0gb3B0cy5vbkNyZWRpdENhcmRUeXBlQ2hhbmdlZCB8fCAoZnVuY3Rpb24gKCkge30pO1xuXG5cdCAgICAgICAgLy8gcGhvbmVcblx0ICAgICAgICB0YXJnZXQucGhvbmUgPSAhIW9wdHMucGhvbmU7XG5cdCAgICAgICAgdGFyZ2V0LnBob25lUmVnaW9uQ29kZSA9IG9wdHMucGhvbmVSZWdpb25Db2RlIHx8ICdBVSc7XG5cdCAgICAgICAgdGFyZ2V0LnBob25lRm9ybWF0dGVyID0ge307XG5cblx0ICAgICAgICAvLyB0aW1lXG5cdCAgICAgICAgdGFyZ2V0LnRpbWUgPSAhIW9wdHMudGltZTtcblx0ICAgICAgICB0YXJnZXQudGltZVBhdHRlcm4gPSBvcHRzLnRpbWVQYXR0ZXJuIHx8IFsnaCcsICdtJywgJ3MnXTtcblx0ICAgICAgICB0YXJnZXQudGltZUZvcm1hdCA9IG9wdHMudGltZUZvcm1hdCB8fCAnMjQnO1xuXHQgICAgICAgIHRhcmdldC50aW1lRm9ybWF0dGVyID0ge307XG5cblx0ICAgICAgICAvLyBkYXRlXG5cdCAgICAgICAgdGFyZ2V0LmRhdGUgPSAhIW9wdHMuZGF0ZTtcblx0ICAgICAgICB0YXJnZXQuZGF0ZVBhdHRlcm4gPSBvcHRzLmRhdGVQYXR0ZXJuIHx8IFsnZCcsICdtJywgJ1knXTtcblx0ICAgICAgICB0YXJnZXQuZGF0ZU1pbiA9IG9wdHMuZGF0ZU1pbiB8fCAnJztcblx0ICAgICAgICB0YXJnZXQuZGF0ZU1heCA9IG9wdHMuZGF0ZU1heCB8fCAnJztcblx0ICAgICAgICB0YXJnZXQuZGF0ZUZvcm1hdHRlciA9IHt9O1xuXG5cdCAgICAgICAgLy8gbnVtZXJhbFxuXHQgICAgICAgIHRhcmdldC5udW1lcmFsID0gISFvcHRzLm51bWVyYWw7XG5cdCAgICAgICAgdGFyZ2V0Lm51bWVyYWxJbnRlZ2VyU2NhbGUgPSBvcHRzLm51bWVyYWxJbnRlZ2VyU2NhbGUgPiAwID8gb3B0cy5udW1lcmFsSW50ZWdlclNjYWxlIDogMDtcblx0ICAgICAgICB0YXJnZXQubnVtZXJhbERlY2ltYWxTY2FsZSA9IG9wdHMubnVtZXJhbERlY2ltYWxTY2FsZSA+PSAwID8gb3B0cy5udW1lcmFsRGVjaW1hbFNjYWxlIDogMjtcblx0ICAgICAgICB0YXJnZXQubnVtZXJhbERlY2ltYWxNYXJrID0gb3B0cy5udW1lcmFsRGVjaW1hbE1hcmsgfHwgJy4nO1xuXHQgICAgICAgIHRhcmdldC5udW1lcmFsVGhvdXNhbmRzR3JvdXBTdHlsZSA9IG9wdHMubnVtZXJhbFRob3VzYW5kc0dyb3VwU3R5bGUgfHwgJ3Rob3VzYW5kJztcblx0ICAgICAgICB0YXJnZXQubnVtZXJhbFBvc2l0aXZlT25seSA9ICEhb3B0cy5udW1lcmFsUG9zaXRpdmVPbmx5O1xuXHQgICAgICAgIHRhcmdldC5zdHJpcExlYWRpbmdaZXJvZXMgPSBvcHRzLnN0cmlwTGVhZGluZ1plcm9lcyAhPT0gZmFsc2U7XG5cdCAgICAgICAgdGFyZ2V0LnNpZ25CZWZvcmVQcmVmaXggPSAhIW9wdHMuc2lnbkJlZm9yZVByZWZpeDtcblx0ICAgICAgICB0YXJnZXQudGFpbFByZWZpeCA9ICEhb3B0cy50YWlsUHJlZml4O1xuXG5cdCAgICAgICAgLy8gb3RoZXJzXG5cdCAgICAgICAgdGFyZ2V0LnN3YXBIaWRkZW5JbnB1dCA9ICEhb3B0cy5zd2FwSGlkZGVuSW5wdXQ7XG5cdCAgICAgICAgXG5cdCAgICAgICAgdGFyZ2V0Lm51bWVyaWNPbmx5ID0gdGFyZ2V0LmNyZWRpdENhcmQgfHwgdGFyZ2V0LmRhdGUgfHwgISFvcHRzLm51bWVyaWNPbmx5O1xuXG5cdCAgICAgICAgdGFyZ2V0LnVwcGVyY2FzZSA9ICEhb3B0cy51cHBlcmNhc2U7XG5cdCAgICAgICAgdGFyZ2V0Lmxvd2VyY2FzZSA9ICEhb3B0cy5sb3dlcmNhc2U7XG5cblx0ICAgICAgICB0YXJnZXQucHJlZml4ID0gKHRhcmdldC5jcmVkaXRDYXJkIHx8IHRhcmdldC5kYXRlKSA/ICcnIDogKG9wdHMucHJlZml4IHx8ICcnKTtcblx0ICAgICAgICB0YXJnZXQubm9JbW1lZGlhdGVQcmVmaXggPSAhIW9wdHMubm9JbW1lZGlhdGVQcmVmaXg7XG5cdCAgICAgICAgdGFyZ2V0LnByZWZpeExlbmd0aCA9IHRhcmdldC5wcmVmaXgubGVuZ3RoO1xuXHQgICAgICAgIHRhcmdldC5yYXdWYWx1ZVRyaW1QcmVmaXggPSAhIW9wdHMucmF3VmFsdWVUcmltUHJlZml4O1xuXHQgICAgICAgIHRhcmdldC5jb3B5RGVsaW1pdGVyID0gISFvcHRzLmNvcHlEZWxpbWl0ZXI7XG5cblx0ICAgICAgICB0YXJnZXQuaW5pdFZhbHVlID0gKG9wdHMuaW5pdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgb3B0cy5pbml0VmFsdWUgIT09IG51bGwpID8gb3B0cy5pbml0VmFsdWUudG9TdHJpbmcoKSA6ICcnO1xuXG5cdCAgICAgICAgdGFyZ2V0LmRlbGltaXRlciA9XG5cdCAgICAgICAgICAgIChvcHRzLmRlbGltaXRlciB8fCBvcHRzLmRlbGltaXRlciA9PT0gJycpID8gb3B0cy5kZWxpbWl0ZXIgOlxuXHQgICAgICAgICAgICAgICAgKG9wdHMuZGF0ZSA/ICcvJyA6XG5cdCAgICAgICAgICAgICAgICAgICAgKG9wdHMudGltZSA/ICc6JyA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChvcHRzLm51bWVyYWwgPyAnLCcgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdHMucGhvbmUgPyAnICcgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgJykpKSk7XG5cdCAgICAgICAgdGFyZ2V0LmRlbGltaXRlckxlbmd0aCA9IHRhcmdldC5kZWxpbWl0ZXIubGVuZ3RoO1xuXHQgICAgICAgIHRhcmdldC5kZWxpbWl0ZXJMYXp5U2hvdyA9ICEhb3B0cy5kZWxpbWl0ZXJMYXp5U2hvdztcblx0ICAgICAgICB0YXJnZXQuZGVsaW1pdGVycyA9IG9wdHMuZGVsaW1pdGVycyB8fCBbXTtcblxuXHQgICAgICAgIHRhcmdldC5ibG9ja3MgPSBvcHRzLmJsb2NrcyB8fCBbXTtcblx0ICAgICAgICB0YXJnZXQuYmxvY2tzTGVuZ3RoID0gdGFyZ2V0LmJsb2Nrcy5sZW5ndGg7XG5cblx0ICAgICAgICB0YXJnZXQucm9vdCA9ICh0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwpID8gZ2xvYmFsIDogd2luZG93O1xuXHQgICAgICAgIHRhcmdldC5kb2N1bWVudCA9IG9wdHMuZG9jdW1lbnQgfHwgdGFyZ2V0LnJvb3QuZG9jdW1lbnQ7XG5cblx0ICAgICAgICB0YXJnZXQubWF4TGVuZ3RoID0gMDtcblxuXHQgICAgICAgIHRhcmdldC5iYWNrc3BhY2UgPSBmYWxzZTtcblx0ICAgICAgICB0YXJnZXQucmVzdWx0ID0gJyc7XG5cblx0ICAgICAgICB0YXJnZXQub25WYWx1ZUNoYW5nZWQgPSBvcHRzLm9uVmFsdWVDaGFuZ2VkIHx8IChmdW5jdGlvbiAoKSB7fSk7XG5cblx0ICAgICAgICByZXR1cm4gdGFyZ2V0O1xuXHQgICAgfVxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gRGVmYXVsdFByb3BlcnRpZXM7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlcbn0pO1xuOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/cleave.js/dist/cleave.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/cleavejs/cleave.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});