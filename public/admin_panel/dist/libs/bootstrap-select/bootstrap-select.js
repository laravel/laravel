/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/bootstrap-select/bootstrap-select.js":
/*!***************************************************!*\
  !*** ./libs/bootstrap-select/bootstrap-select.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bootstrapSelect\": function() { return /* reexport default from dynamic */ bootstrap_select_js_bootstrap_select__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var bootstrap_select_js_bootstrap_select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bootstrap-select/js/bootstrap-select */ \"./node_modules/bootstrap-select/js/bootstrap-select.js\");\n/* harmony import */ var bootstrap_select_js_bootstrap_select__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bootstrap_select_js_bootstrap_select__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL2Jvb3RzdHJhcC1zZWxlY3QvYm9vdHN0cmFwLXNlbGVjdC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZXN0Ly4vbGlicy9ib290c3RyYXAtc2VsZWN0L2Jvb3RzdHJhcC1zZWxlY3QuanM/ZTA4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYm9vdHN0cmFwU2VsZWN0IGZyb20gJ2Jvb3RzdHJhcC1zZWxlY3QvanMvYm9vdHN0cmFwLXNlbGVjdCc7XHJcblxyXG5leHBvcnQgeyBib290c3RyYXBTZWxlY3QgfTtcclxuIl0sIm5hbWVzIjpbImJvb3RzdHJhcFNlbGVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/bootstrap-select/bootstrap-select.js\n");

/***/ }),

/***/ "./node_modules/bootstrap-select/js/bootstrap-select.js":
/*!**************************************************************!*\
  !*** ./node_modules/bootstrap-select/js/bootstrap-select.js ***!
  \**************************************************************/
/***/ (function() {

eval("(function ($) {\n  'use strict';\n\n  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];\n\n  var uriAttrs = [\n    'background',\n    'cite',\n    'href',\n    'itemtype',\n    'longdesc',\n    'poster',\n    'src',\n    'xlink:href'\n  ];\n\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n\n  var DefaultWhitelist = {\n    // Global attributes allowed on any supplied element below.\n    '*': ['class', 'dir', 'id', 'lang', 'role', 'tabindex', 'style', ARIA_ATTRIBUTE_PATTERN],\n    a: ['target', 'href', 'title', 'rel'],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: ['src', 'alt', 'title', 'width', 'height'],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n\n  /**\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\n   *\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n   */\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n\n  /**\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\n   *\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n   */\n  var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;\n\n  var ParseableAttributes = ['title', 'placeholder']; // attributes to use as settings, can add others in the future\n\n  function allowedAttribute (attr, allowedAttributeList) {\n    var attrName = attr.nodeName.toLowerCase();\n\n    if ($.inArray(attrName, allowedAttributeList) !== -1) {\n      if ($.inArray(attrName, uriAttrs) !== -1) {\n        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));\n      }\n\n      return true;\n    }\n\n    var regExp = $(allowedAttributeList).filter(function (index, value) {\n      return value instanceof RegExp;\n    });\n\n    // Check if a regular expression validates the attribute.\n    for (var i = 0, l = regExp.length; i < l; i++) {\n      if (attrName.match(regExp[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function sanitizeHtml (unsafeElements, whiteList, sanitizeFn) {\n    if (sanitizeFn && typeof sanitizeFn === 'function') {\n      return sanitizeFn(unsafeElements);\n    }\n\n    var whitelistKeys = Object.keys(whiteList);\n\n    for (var i = 0, len = unsafeElements.length; i < len; i++) {\n      var elements = unsafeElements[i].querySelectorAll('*');\n\n      for (var j = 0, len2 = elements.length; j < len2; j++) {\n        var el = elements[j];\n        var elName = el.nodeName.toLowerCase();\n\n        if (whitelistKeys.indexOf(elName) === -1) {\n          el.parentNode.removeChild(el);\n\n          continue;\n        }\n\n        var attributeList = [].slice.call(el.attributes);\n        var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);\n\n        for (var k = 0, len3 = attributeList.length; k < len3; k++) {\n          var attr = attributeList[k];\n\n          if (!allowedAttribute(attr, whitelistedAttributes)) {\n            el.removeAttribute(attr.nodeName);\n          }\n        }\n      }\n    }\n  }\n\n  function getAttributesObject ($select) {\n    var attributesObject = {},\n        attrVal;\n\n    ParseableAttributes.forEach(function (item) {\n      attrVal = $select.attr(item);\n      if (attrVal) attributesObject[item] = attrVal;\n    });\n\n    // for backwards compatibility\n    // (using title as placeholder is deprecated - remove in v2.0.0)\n    if (!attributesObject.placeholder && attributesObject.title) {\n      attributesObject.placeholder = attributesObject.title;\n    }\n\n    return attributesObject;\n  }\n\n  // Polyfill for browsers with no classList support\n  // Remove in v2\n  if (!('classList' in document.createElement('_'))) {\n    (function (view) {\n      if (!('Element' in view)) return;\n\n      var classListProp = 'classList',\n          protoProp = 'prototype',\n          elemCtrProto = view.Element[protoProp],\n          objCtr = Object,\n          classListGetter = function () {\n            var $elem = $(this);\n\n            return {\n              add: function (classes) {\n                classes = Array.prototype.slice.call(arguments).join(' ');\n                return $elem.addClass(classes);\n              },\n              remove: function (classes) {\n                classes = Array.prototype.slice.call(arguments).join(' ');\n                return $elem.removeClass(classes);\n              },\n              toggle: function (classes, force) {\n                return $elem.toggleClass(classes, force);\n              },\n              contains: function (classes) {\n                return $elem.hasClass(classes);\n              }\n            };\n          };\n\n      if (objCtr.defineProperty) {\n        var classListPropDesc = {\n          get: classListGetter,\n          enumerable: true,\n          configurable: true\n        };\n        try {\n          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n        } catch (ex) { // IE 8 doesn't support enumerable:true\n          // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36\n          // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected\n          if (ex.number === undefined || ex.number === -0x7FF5EC54) {\n            classListPropDesc.enumerable = false;\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n          }\n        }\n      } else if (objCtr[protoProp].__defineGetter__) {\n        elemCtrProto.__defineGetter__(classListProp, classListGetter);\n      }\n    }(window));\n  }\n\n  var testElement = document.createElement('_');\n\n  testElement.classList.add('c1', 'c2');\n\n  if (!testElement.classList.contains('c2')) {\n    var _add = DOMTokenList.prototype.add,\n        _remove = DOMTokenList.prototype.remove;\n\n    DOMTokenList.prototype.add = function () {\n      Array.prototype.forEach.call(arguments, _add.bind(this));\n    };\n\n    DOMTokenList.prototype.remove = function () {\n      Array.prototype.forEach.call(arguments, _remove.bind(this));\n    };\n  }\n\n  testElement.classList.toggle('c3', false);\n\n  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not\n  // support the second argument.\n  if (testElement.classList.contains('c3')) {\n    var _toggle = DOMTokenList.prototype.toggle;\n\n    DOMTokenList.prototype.toggle = function (token, force) {\n      if (1 in arguments && !this.contains(token) === !force) {\n        return force;\n      } else {\n        return _toggle.call(this, token);\n      }\n    };\n  }\n\n  testElement = null;\n\n  // Polyfill for IE (remove in v2)\n  Object.values = typeof Object.values === 'function' ? Object.values : function (obj) {\n    return Object.keys(obj).map(function (key) {\n      return obj[key];\n    });\n  };\n\n  // shallow array comparison\n  function isEqual (array1, array2) {\n    return array1.length === array2.length && array1.every(function (element, index) {\n      return element === array2[index];\n    });\n  };\n\n  // <editor-fold desc=\"Shims\">\n  if (!String.prototype.startsWith) {\n    (function () {\n      'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\n      var toString = {}.toString;\n      var startsWith = function (search) {\n        if (this == null) {\n          throw new TypeError();\n        }\n        var string = String(this);\n        if (search && toString.call(search) == '[object RegExp]') {\n          throw new TypeError();\n        }\n        var stringLength = string.length;\n        var searchString = String(search);\n        var searchLength = searchString.length;\n        var position = arguments.length > 1 ? arguments[1] : undefined;\n        // `ToInteger`\n        var pos = position ? Number(position) : 0;\n        if (pos != pos) { // better `isNaN`\n          pos = 0;\n        }\n        var start = Math.min(Math.max(pos, 0), stringLength);\n        // Avoid the `indexOf` call if no match is possible\n        if (searchLength + start > stringLength) {\n          return false;\n        }\n        var index = -1;\n        while (++index < searchLength) {\n          if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {\n            return false;\n          }\n        }\n        return true;\n      };\n      if (Object.defineProperty) {\n        Object.defineProperty(String.prototype, 'startsWith', {\n          'value': startsWith,\n          'configurable': true,\n          'writable': true\n        });\n      } else {\n        String.prototype.startsWith = startsWith;\n      }\n    }());\n  }\n\n  function toKebabCase (str) {\n    return str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, function ($, ofs) {\n      return (ofs ? '-' : '') + $.toLowerCase();\n    });\n  }\n\n  function getSelectedOptions () {\n    var options = this.selectpicker.main.data;\n\n    if (this.options.source.data || this.options.source.search) {\n      options = Object.values(this.selectpicker.optionValuesDataMap);\n    }\n\n    var selectedOptions = options.filter(function (item) {\n      if (item.selected) {\n        if (this.options.hideDisabled && item.disabled) return false;\n        return true;\n      }\n\n      return false;\n    }, this);\n\n    // ensure only 1 option is selected if multiple are set in the data source\n    if (this.options.source.data && !this.multiple && selectedOptions.length > 1) {\n      for (var i = 0; i < selectedOptions.length - 1; i++) {\n        selectedOptions[i].selected = false;\n      }\n\n      selectedOptions = [ selectedOptions[selectedOptions.length - 1] ];\n    }\n\n    return selectedOptions;\n  }\n\n  // much faster than $.val()\n  function getSelectValues (selectedOptions) {\n    var value = [],\n        options = selectedOptions || getSelectedOptions.call(this),\n        opt;\n\n    for (var i = 0, len = options.length; i < len; i++) {\n      opt = options[i];\n\n      if (!opt.disabled) {\n        value.push(opt.value === undefined ? opt.text : opt.value);\n      }\n    }\n\n    if (!this.multiple) {\n      return !value.length ? null : value[0];\n    }\n\n    return value;\n  }\n\n  // set data-selected on select element if the value has been programmatically selected\n  // prior to initialization of bootstrap-select\n  // * consider removing or replacing an alternative method *\n  var valHooks = {\n    useDefault: false,\n    _set: $.valHooks.select.set\n  };\n\n  $.valHooks.select.set = function (elem, value) {\n    if (value && !valHooks.useDefault) $(elem).data('selected', true);\n\n    return valHooks._set.apply(this, arguments);\n  };\n\n  var changedArguments = null;\n\n  var EventIsSupported = (function () {\n    try {\n      new Event('change');\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  $.fn.triggerNative = function (eventName) {\n    var el = this[0],\n        event;\n\n    if (el.dispatchEvent) { // for modern browsers & IE9+\n      if (EventIsSupported) {\n        // For modern browsers\n        event = new Event(eventName, {\n          bubbles: true\n        });\n      } else {\n        // For IE since it doesn't support Event constructor\n        event = document.createEvent('Event');\n        event.initEvent(eventName, true, false);\n      }\n\n      el.dispatchEvent(event);\n    }\n  };\n  // </editor-fold>\n\n  function stringSearch (li, searchString, method, normalize) {\n    var stringTypes = [\n          'display',\n          'subtext',\n          'tokens'\n        ],\n        searchSuccess = false;\n\n    for (var i = 0; i < stringTypes.length; i++) {\n      var stringType = stringTypes[i],\n          string = li[stringType];\n\n      if (string) {\n        string = string.toString();\n\n        // Strip HTML tags. This isn't perfect, but it's much faster than any other method\n        if (stringType === 'display') {\n          string = string.replace(/<[^>]+>/g, '');\n        }\n\n        if (normalize) string = normalizeToBase(string);\n        string = string.toUpperCase();\n\n        if (typeof method === 'function') {\n          searchSuccess = method(string, searchString);\n        } else if (method === 'contains') {\n          searchSuccess = string.indexOf(searchString) >= 0;\n        } else {\n          searchSuccess = string.startsWith(searchString);\n        }\n\n        if (searchSuccess) break;\n      }\n    }\n\n    return searchSuccess;\n  }\n\n  function toInteger (value) {\n    return parseInt(value, 10) || 0;\n  }\n\n  // Borrowed from Lodash (_.deburr)\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboMarksExtendedRange = '\\\\u1ab0-\\\\u1aff',\n      rsComboMarksSupplementRange = '\\\\u1dc0-\\\\u1dff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsCombo = '[' + rsComboRange + ']';\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  function deburrLetter (key) {\n    return deburredLetters[key];\n  };\n\n  function normalizeToBase (string) {\n    string = string.toString();\n    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n  }\n\n  // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function (map) {\n    var escaper = function (match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + Object.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function (string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n\n  var htmlEscape = createEscaper(escapeMap);\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var keyCodeMap = {\n    32: ' ',\n    48: '0',\n    49: '1',\n    50: '2',\n    51: '3',\n    52: '4',\n    53: '5',\n    54: '6',\n    55: '7',\n    56: '8',\n    57: '9',\n    59: ';',\n    65: 'A',\n    66: 'B',\n    67: 'C',\n    68: 'D',\n    69: 'E',\n    70: 'F',\n    71: 'G',\n    72: 'H',\n    73: 'I',\n    74: 'J',\n    75: 'K',\n    76: 'L',\n    77: 'M',\n    78: 'N',\n    79: 'O',\n    80: 'P',\n    81: 'Q',\n    82: 'R',\n    83: 'S',\n    84: 'T',\n    85: 'U',\n    86: 'V',\n    87: 'W',\n    88: 'X',\n    89: 'Y',\n    90: 'Z',\n    96: '0',\n    97: '1',\n    98: '2',\n    99: '3',\n    100: '4',\n    101: '5',\n    102: '6',\n    103: '7',\n    104: '8',\n    105: '9'\n  };\n\n  var keyCodes = {\n    ESCAPE: 27, // KeyboardEvent.which value for Escape (Esc) key\n    ENTER: 13, // KeyboardEvent.which value for Enter key\n    SPACE: 32, // KeyboardEvent.which value for space key\n    TAB: 9, // KeyboardEvent.which value for tab key\n    ARROW_UP: 38, // KeyboardEvent.which value for up arrow key\n    ARROW_DOWN: 40 // KeyboardEvent.which value for down arrow key\n  };\n\n  // eslint-disable-next-line no-undef\n  var Dropdown = window.Dropdown || bootstrap.Dropdown;\n\n  function getVersion () {\n    var version;\n\n    try {\n      version = $.fn.dropdown.Constructor.VERSION;\n    } catch (err) {\n      version = Dropdown.VERSION;\n    }\n\n    return version;\n  }\n\n  var version = {\n    success: false,\n    major: '3'\n  };\n\n  try {\n    version.full = (getVersion() || '').split(' ')[0].split('.');\n    version.major = version.full[0];\n    version.success = true;\n  } catch (err) {\n    // do nothing\n  }\n\n  var selectId = 0;\n\n  var EVENT_KEY = '.bs.select';\n\n  var classNames = {\n    DISABLED: 'disabled',\n    DIVIDER: 'divider',\n    SHOW: 'open',\n    DROPUP: 'dropup',\n    MENU: 'dropdown-menu',\n    MENURIGHT: 'dropdown-menu-right',\n    MENULEFT: 'dropdown-menu-left',\n    // to-do: replace with more advanced template/customization options\n    BUTTONCLASS: 'btn-default',\n    POPOVERHEADER: 'popover-title',\n    ICONBASE: 'glyphicon',\n    TICKICON: 'glyphicon-ok'\n  };\n\n  var Selector = {\n    MENU: '.' + classNames.MENU,\n    DATA_TOGGLE: 'data-toggle=\"dropdown\"'\n  };\n\n  var elementTemplates = {\n    div: document.createElement('div'),\n    span: document.createElement('span'),\n    i: document.createElement('i'),\n    subtext: document.createElement('small'),\n    a: document.createElement('a'),\n    li: document.createElement('li'),\n    whitespace: document.createTextNode('\\u00A0'),\n    fragment: document.createDocumentFragment(),\n    option: document.createElement('option')\n  };\n\n  elementTemplates.selectedOption = elementTemplates.option.cloneNode(false);\n  elementTemplates.selectedOption.setAttribute('selected', true);\n\n  elementTemplates.noResults = elementTemplates.li.cloneNode(false);\n  elementTemplates.noResults.className = 'no-results';\n\n  elementTemplates.a.setAttribute('role', 'option');\n  elementTemplates.a.className = 'dropdown-item';\n\n  elementTemplates.subtext.className = 'text-muted';\n\n  elementTemplates.text = elementTemplates.span.cloneNode(false);\n  elementTemplates.text.className = 'text';\n\n  elementTemplates.checkMark = elementTemplates.span.cloneNode(false);\n\n  var REGEXP_ARROW = new RegExp(keyCodes.ARROW_UP + '|' + keyCodes.ARROW_DOWN);\n  var REGEXP_TAB_OR_ESCAPE = new RegExp('^' + keyCodes.TAB + '$|' + keyCodes.ESCAPE);\n\n  var generateOption = {\n    li: function (content, classes, optgroup) {\n      var li = elementTemplates.li.cloneNode(false);\n\n      if (content) {\n        if (content.nodeType === 1 || content.nodeType === 11) {\n          li.appendChild(content);\n        } else {\n          li.innerHTML = content;\n        }\n      }\n\n      if (typeof classes !== 'undefined' && classes !== '') li.className = classes;\n      if (typeof optgroup !== 'undefined' && optgroup !== null) li.classList.add('optgroup-' + optgroup);\n\n      return li;\n    },\n\n    a: function (text, classes, inline) {\n      var a = elementTemplates.a.cloneNode(true);\n\n      if (text) {\n        if (text.nodeType === 11) {\n          a.appendChild(text);\n        } else {\n          a.insertAdjacentHTML('beforeend', text);\n        }\n      }\n\n      if (typeof classes !== 'undefined' && classes !== '') a.classList.add.apply(a.classList, classes.split(/\\s+/));\n      if (inline) a.setAttribute('style', inline);\n\n      return a;\n    },\n\n    text: function (options, useFragment) {\n      var textElement = elementTemplates.text.cloneNode(false),\n          subtextElement,\n          iconElement;\n\n      if (options.content) {\n        textElement.innerHTML = options.content;\n      } else {\n        textElement.textContent = options.text;\n\n        if (options.icon) {\n          var whitespace = elementTemplates.whitespace.cloneNode(false);\n\n          // need to use <i> for icons in the button to prevent a breaking change\n          // note: switch to span in next major release\n          iconElement = (useFragment === true ? elementTemplates.i : elementTemplates.span).cloneNode(false);\n          iconElement.className = this.options.iconBase + ' ' + options.icon;\n\n          elementTemplates.fragment.appendChild(iconElement);\n          elementTemplates.fragment.appendChild(whitespace);\n        }\n\n        if (options.subtext) {\n          subtextElement = elementTemplates.subtext.cloneNode(false);\n          subtextElement.textContent = options.subtext;\n          textElement.appendChild(subtextElement);\n        }\n      }\n\n      if (useFragment === true) {\n        while (textElement.childNodes.length > 0) {\n          elementTemplates.fragment.appendChild(textElement.childNodes[0]);\n        }\n      } else {\n        elementTemplates.fragment.appendChild(textElement);\n      }\n\n      return elementTemplates.fragment;\n    },\n\n    label: function (options) {\n      var textElement = elementTemplates.text.cloneNode(false),\n          subtextElement,\n          iconElement;\n\n      textElement.innerHTML = options.display;\n\n      if (options.icon) {\n        var whitespace = elementTemplates.whitespace.cloneNode(false);\n\n        iconElement = elementTemplates.span.cloneNode(false);\n        iconElement.className = this.options.iconBase + ' ' + options.icon;\n\n        elementTemplates.fragment.appendChild(iconElement);\n        elementTemplates.fragment.appendChild(whitespace);\n      }\n\n      if (options.subtext) {\n        subtextElement = elementTemplates.subtext.cloneNode(false);\n        subtextElement.textContent = options.subtext;\n        textElement.appendChild(subtextElement);\n      }\n\n      elementTemplates.fragment.appendChild(textElement);\n\n      return elementTemplates.fragment;\n    }\n  };\n\n  var getOptionData = {\n    fromOption: function (option, type) {\n      var value;\n\n      switch (type) {\n        case 'divider':\n          value = option.getAttribute('data-divider') === 'true';\n          break;\n\n        case 'text':\n          value = option.textContent;\n          break;\n\n        case 'label':\n          value = option.label;\n          break;\n\n        case 'style':\n          value = option.style.cssText;\n          break;\n\n        case 'title':\n          value = option.title;\n          break;\n\n        default:\n          value = option.getAttribute('data-' + toKebabCase(type));\n          break;\n      }\n\n      return value;\n    },\n    fromDataSource: function (option, type) {\n      var value;\n\n      switch (type) {\n        case 'text':\n        case 'label':\n          value = option.text || option.value || '';\n          break;\n\n        default:\n          value = option[type];\n          break;\n      }\n\n      return value;\n    }\n  };\n\n  function showNoResults (searchMatch, searchValue) {\n    if (!searchMatch.length) {\n      elementTemplates.noResults.innerHTML = this.options.noneResultsText.replace('{0}', '\"' + htmlEscape(searchValue) + '\"');\n      this.$menuInner[0].firstChild.appendChild(elementTemplates.noResults);\n    }\n  }\n\n  function filterHidden (item) {\n    return !(item.hidden || this.options.hideDisabled && item.disabled);\n  }\n\n  var Selectpicker = function (element, options) {\n    var that = this;\n\n    // bootstrap-select has been initialized - revert valHooks.select.set back to its original function\n    if (!valHooks.useDefault) {\n      $.valHooks.select.set = valHooks._set;\n      valHooks.useDefault = true;\n    }\n\n    this.$element = $(element);\n    this.$newElement = null;\n    this.$button = null;\n    this.$menu = null;\n    this.options = options;\n    this.selectpicker = {\n      main: {\n        data: [],\n        optionQueue: elementTemplates.fragment.cloneNode(false),\n        hasMore: false\n      },\n      search: {\n        data: [],\n        hasMore: false\n      },\n      current: {}, // current is either equal to main or search depending on if a search is in progress\n      view: {},\n      // map of option values and their respective data (only used in conjunction with options.source)\n      optionValuesDataMap: {},\n      isSearching: false,\n      keydown: {\n        keyHistory: '',\n        resetKeyHistory: {\n          start: function () {\n            return setTimeout(function () {\n              that.selectpicker.keydown.keyHistory = '';\n            }, 800);\n          }\n        }\n      }\n    };\n\n    this.sizeInfo = {};\n\n    // Format window padding\n    var winPad = this.options.windowPadding;\n    if (typeof winPad === 'number') {\n      this.options.windowPadding = [winPad, winPad, winPad, winPad];\n    }\n\n    // Expose public methods\n    this.val = Selectpicker.prototype.val;\n    this.render = Selectpicker.prototype.render;\n    this.refresh = Selectpicker.prototype.refresh;\n    this.setStyle = Selectpicker.prototype.setStyle;\n    this.selectAll = Selectpicker.prototype.selectAll;\n    this.deselectAll = Selectpicker.prototype.deselectAll;\n    this.destroy = Selectpicker.prototype.destroy;\n    this.remove = Selectpicker.prototype.remove;\n    this.show = Selectpicker.prototype.show;\n    this.hide = Selectpicker.prototype.hide;\n\n    this.init();\n  };\n\n  Selectpicker.VERSION = '1.14.0-beta3';\n\n  // part of this is duplicated in i18n/defaults-en_US.js. Make sure to update both.\n  Selectpicker.DEFAULTS = {\n    noneSelectedText: 'Nothing selected',\n    noneResultsText: 'No results matched {0}',\n    countSelectedText: function (numSelected, numTotal) {\n      return (numSelected == 1) ? '{0} item selected' : '{0} items selected';\n    },\n    maxOptionsText: function (numAll, numGroup) {\n      return [\n        (numAll == 1) ? 'Limit reached ({n} item max)' : 'Limit reached ({n} items max)',\n        (numGroup == 1) ? 'Group limit reached ({n} item max)' : 'Group limit reached ({n} items max)'\n      ];\n    },\n    selectAllText: 'Select All',\n    deselectAllText: 'Deselect All',\n    source: {\n      pageSize: 40\n    },\n    chunkSize: 40,\n    doneButton: false,\n    doneButtonText: 'Close',\n    multipleSeparator: ', ',\n    styleBase: 'btn',\n    style: classNames.BUTTONCLASS,\n    size: 'auto',\n    title: null,\n    placeholder: null,\n    allowClear: false,\n    selectedTextFormat: 'values',\n    width: false,\n    container: false,\n    hideDisabled: false,\n    showSubtext: false,\n    showIcon: true,\n    showContent: true,\n    dropupAuto: true,\n    header: false,\n    liveSearch: false,\n    liveSearchPlaceholder: null,\n    liveSearchNormalize: false,\n    liveSearchStyle: 'contains',\n    actionsBox: false,\n    iconBase: classNames.ICONBASE,\n    tickIcon: classNames.TICKICON,\n    showTick: false,\n    template: {\n      caret: '<span class=\"caret\"></span>'\n    },\n    maxOptions: false,\n    mobile: false,\n    selectOnTab: true,\n    dropdownAlignRight: false,\n    windowPadding: 0,\n    virtualScroll: 600,\n    display: false,\n    sanitize: true,\n    sanitizeFn: null,\n    whiteList: DefaultWhitelist\n  };\n\n  Selectpicker.prototype = {\n\n    constructor: Selectpicker,\n\n    init: function () {\n      var that = this,\n          id = this.$element.attr('id'),\n          element = this.$element[0],\n          form = element.form;\n\n      selectId++;\n      this.selectId = 'bs-select-' + selectId;\n\n      element.classList.add('bs-select-hidden');\n\n      this.multiple = this.$element.prop('multiple');\n      this.autofocus = this.$element.prop('autofocus');\n\n      if (element.classList.contains('show-tick')) {\n        this.options.showTick = true;\n      }\n\n      this.$newElement = this.createDropdown();\n\n      this.$element\n        .after(this.$newElement)\n        .prependTo(this.$newElement);\n\n      // ensure select is associated with form element if it got unlinked after moving it inside newElement\n      if (form && element.form === null) {\n        if (!form.id) form.id = 'form-' + this.selectId;\n        element.setAttribute('form', form.id);\n      }\n\n      this.$button = this.$newElement.children('button');\n      if (this.options.allowClear) this.$clearButton = this.$button.children('.bs-select-clear-selected');\n      this.$menu = this.$newElement.children(Selector.MENU);\n      this.$menuInner = this.$menu.children('.inner');\n      this.$searchbox = this.$menu.find('input');\n\n      element.classList.remove('bs-select-hidden');\n\n      this.fetchData(function () {\n        that.render(true);\n        that.buildList();\n\n        requestAnimationFrame(function () {\n          that.$element.trigger('loaded' + EVENT_KEY);\n        });\n      });\n\n      if (this.options.dropdownAlignRight === true) this.$menu[0].classList.add(classNames.MENURIGHT);\n\n      if (typeof id !== 'undefined') {\n        this.$button.attr('data-id', id);\n      }\n\n      this.checkDisabled();\n      this.clickListener();\n\n      if (version.major > 4) this.dropdown = new Dropdown(this.$button[0]);\n\n      if (this.options.liveSearch) {\n        this.liveSearchListener();\n        this.focusedParent = this.$searchbox[0];\n      } else {\n        this.focusedParent = this.$menuInner[0];\n      }\n\n      this.setStyle();\n      this.setWidth();\n      if (this.options.container) {\n        this.selectPosition();\n      } else {\n        this.$element.on('hide' + EVENT_KEY, function () {\n          if (that.isVirtual()) {\n            // empty menu on close\n            var menuInner = that.$menuInner[0],\n                emptyMenu = menuInner.firstChild.cloneNode(false);\n\n            // replace the existing UL with an empty one - this is faster than $.empty() or innerHTML = ''\n            menuInner.replaceChild(emptyMenu, menuInner.firstChild);\n            menuInner.scrollTop = 0;\n          }\n        });\n      }\n      this.$menu.data('this', this);\n      this.$newElement.data('this', this);\n      if (this.options.mobile) this.mobile();\n\n      this.$newElement.on({\n        'hide.bs.dropdown': function (e) {\n          that.$element.trigger('hide' + EVENT_KEY, e);\n        },\n        'hidden.bs.dropdown': function (e) {\n          that.$element.trigger('hidden' + EVENT_KEY, e);\n        },\n        'show.bs.dropdown': function (e) {\n          that.$element.trigger('show' + EVENT_KEY, e);\n        },\n        'shown.bs.dropdown': function (e) {\n          that.$element.trigger('shown' + EVENT_KEY, e);\n        }\n      });\n\n      if (element.hasAttribute('required')) {\n        this.$element.on('invalid' + EVENT_KEY, function () {\n          that.$button[0].classList.add('bs-invalid');\n\n          that.$element\n            .on('shown' + EVENT_KEY + '.invalid', function () {\n              that.$element\n                .val(that.$element.val()) // set the value to hide the validation message in Chrome when menu is opened\n                .off('shown' + EVENT_KEY + '.invalid');\n            })\n            .on('rendered' + EVENT_KEY, function () {\n              // if select is no longer invalid, remove the bs-invalid class\n              if (this.validity.valid) that.$button[0].classList.remove('bs-invalid');\n              that.$element.off('rendered' + EVENT_KEY);\n            });\n\n          that.$button.on('blur' + EVENT_KEY, function () {\n            that.$element.trigger('focus').trigger('blur');\n            that.$button.off('blur' + EVENT_KEY);\n          });\n        });\n      }\n\n      if (form) {\n        $(form).on('reset' + EVENT_KEY, function () {\n          requestAnimationFrame(function () {\n            that.render();\n          });\n        });\n      }\n    },\n\n    createDropdown: function () {\n      // Options\n      // If we are multiple or showTick option is set, then add the show-tick class\n      var showTick = (this.multiple || this.options.showTick) ? ' show-tick' : '',\n          multiselectable = this.multiple ? ' aria-multiselectable=\"true\"' : '',\n          inputGroup = '',\n          autofocus = this.autofocus ? ' autofocus' : '';\n\n      if (version.major < 4 && this.$element.parent().hasClass('input-group')) {\n        inputGroup = ' input-group-btn';\n      }\n\n      // Elements\n      var drop,\n          header = '',\n          searchbox = '',\n          actionsbox = '',\n          donebutton = '',\n          clearButton = '';\n\n      if (this.options.header) {\n        header =\n          '<div class=\"' + classNames.POPOVERHEADER + '\">' +\n            '<button type=\"button\" class=\"close\" aria-hidden=\"true\">&times;</button>' +\n              this.options.header +\n          '</div>';\n      }\n\n      if (this.options.liveSearch) {\n        searchbox =\n          '<div class=\"bs-searchbox\">' +\n            '<input type=\"search\" class=\"form-control\" autocomplete=\"off\"' +\n              (\n                this.options.liveSearchPlaceholder === null ? ''\n                :\n                ' placeholder=\"' + htmlEscape(this.options.liveSearchPlaceholder) + '\"'\n              ) +\n              ' role=\"combobox\" aria-label=\"Search\" aria-controls=\"' + this.selectId + '\" aria-autocomplete=\"list\">' +\n          '</div>';\n      }\n\n      if (this.multiple && this.options.actionsBox) {\n        actionsbox =\n          '<div class=\"bs-actionsbox\">' +\n            '<div class=\"btn-group btn-group-sm\">' +\n              '<button type=\"button\" class=\"actions-btn bs-select-all btn ' + classNames.BUTTONCLASS + '\">' +\n                this.options.selectAllText +\n              '</button>' +\n              '<button type=\"button\" class=\"actions-btn bs-deselect-all btn ' + classNames.BUTTONCLASS + '\">' +\n                this.options.deselectAllText +\n              '</button>' +\n            '</div>' +\n          '</div>';\n      }\n\n      if (this.multiple && this.options.doneButton) {\n        donebutton =\n          '<div class=\"bs-donebutton\">' +\n            '<div class=\"btn-group\">' +\n              '<button type=\"button\" class=\"btn btn-sm ' + classNames.BUTTONCLASS + '\">' +\n                this.options.doneButtonText +\n              '</button>' +\n            '</div>' +\n          '</div>';\n      }\n\n      if (this.options.allowClear) {\n        clearButton = '<span class=\"close bs-select-clear-selected\" title=\"' + this.options.deselectAllText + '\"><span>&times;</span>';\n      }\n\n      drop =\n        '<div class=\"dropdown bootstrap-select' + showTick + inputGroup + '\">' +\n          '<button type=\"button\" tabindex=\"-1\" class=\"' +\n            this.options.styleBase +\n            ' dropdown-toggle\" ' +\n            (this.options.display === 'static' ? 'data-display=\"static\"' : '') +\n            Selector.DATA_TOGGLE +\n            autofocus +\n            ' role=\"combobox\" aria-owns=\"' +\n            this.selectId +\n            '\" aria-haspopup=\"listbox\" aria-expanded=\"false\">' +\n            '<div class=\"filter-option\">' +\n              '<div class=\"filter-option-inner\">' +\n                '<div class=\"filter-option-inner-inner\">&nbsp;</div>' +\n              '</div> ' +\n            '</div>' +\n            clearButton +\n            '</span>' +\n            (\n              version.major >= '4' ? ''\n              :\n              '<span class=\"bs-caret\">' +\n                this.options.template.caret +\n              '</span>'\n            ) +\n          '</button>' +\n          '<div class=\"' + classNames.MENU + ' ' + (version.major >= '4' ? '' : classNames.SHOW) + '\">' +\n            header +\n            searchbox +\n            actionsbox +\n            '<div class=\"inner ' + classNames.SHOW + '\" role=\"listbox\" id=\"' + this.selectId + '\" tabindex=\"-1\" ' + multiselectable + '>' +\n                '<ul class=\"' + classNames.MENU + ' inner ' + (version.major >= '4' ? classNames.SHOW : '') + '\" role=\"presentation\">' +\n                '</ul>' +\n            '</div>' +\n            donebutton +\n          '</div>' +\n        '</div>';\n\n      return $(drop);\n    },\n\n    setPositionData: function () {\n      this.selectpicker.view.canHighlight = [];\n      this.selectpicker.view.size = 0;\n      this.selectpicker.view.firstHighlightIndex = false;\n\n      for (var i = 0; i < this.selectpicker.current.data.length; i++) {\n        var li = this.selectpicker.current.data[i],\n            canHighlight = true;\n\n        if (li.type === 'divider') {\n          canHighlight = false;\n          li.height = this.sizeInfo.dividerHeight;\n        } else if (li.type === 'optgroup-label') {\n          canHighlight = false;\n          li.height = this.sizeInfo.dropdownHeaderHeight;\n        } else {\n          li.height = this.sizeInfo.liHeight;\n        }\n\n        if (li.disabled) canHighlight = false;\n\n        this.selectpicker.view.canHighlight.push(canHighlight);\n\n        if (canHighlight) {\n          this.selectpicker.view.size++;\n          li.posinset = this.selectpicker.view.size;\n          if (this.selectpicker.view.firstHighlightIndex === false) this.selectpicker.view.firstHighlightIndex = i;\n        }\n\n        li.position = (i === 0 ? 0 : this.selectpicker.current.data[i - 1].position) + li.height;\n      }\n    },\n\n    isVirtual: function () {\n      return (this.options.virtualScroll !== false) && (this.selectpicker.main.data.length >= this.options.virtualScroll) || this.options.virtualScroll === true;\n    },\n\n    createView: function (isSearching, setSize, refresh) {\n      var that = this,\n          scrollTop = 0;\n\n      this.selectpicker.isSearching = isSearching;\n      this.selectpicker.current = isSearching ? this.selectpicker.search : this.selectpicker.main;\n\n      this.setPositionData();\n\n      if (setSize) {\n        if (refresh) {\n          scrollTop = this.$menuInner[0].scrollTop;\n        } else if (!that.multiple) {\n          var element = that.$element[0],\n              selectedIndex = (element.options[element.selectedIndex] || {}).liIndex;\n\n          if (typeof selectedIndex === 'number' && that.options.size !== false) {\n            var selectedData = that.selectpicker.main.data[selectedIndex],\n                position = selectedData && selectedData.position;\n\n            if (position) {\n              scrollTop = position - ((that.sizeInfo.menuInnerHeight + that.sizeInfo.liHeight) / 2);\n            }\n          }\n        }\n      }\n\n      scroll(scrollTop, true);\n\n      this.$menuInner.off('scroll.createView').on('scroll.createView', function (e, updateValue) {\n        if (!that.noScroll) scroll(this.scrollTop, updateValue);\n        that.noScroll = false;\n      });\n\n      function scroll (scrollTop, init) {\n        var size = that.selectpicker.current.data.length,\n            chunks = [],\n            chunkSize,\n            chunkCount,\n            firstChunk,\n            lastChunk,\n            currentChunk,\n            prevPositions,\n            positionIsDifferent,\n            previousElements,\n            menuIsDifferent = true,\n            isVirtual = that.isVirtual();\n\n        that.selectpicker.view.scrollTop = scrollTop;\n\n        chunkSize = that.options.chunkSize; // number of options in a chunk\n        chunkCount = Math.ceil(size / chunkSize) || 1; // number of chunks\n\n        for (var i = 0; i < chunkCount; i++) {\n          var endOfChunk = (i + 1) * chunkSize;\n\n          if (i === chunkCount - 1) {\n            endOfChunk = size;\n          }\n\n          chunks[i] = [\n            (i) * chunkSize + (!i ? 0 : 1),\n            endOfChunk\n          ];\n\n          if (!size) break;\n\n          if (currentChunk === undefined && scrollTop - 1 <= that.selectpicker.current.data[endOfChunk - 1].position - that.sizeInfo.menuInnerHeight) {\n            currentChunk = i;\n          }\n        }\n\n        if (currentChunk === undefined) currentChunk = 0;\n\n        prevPositions = [that.selectpicker.view.position0, that.selectpicker.view.position1];\n\n        // always display previous, current, and next chunks\n        firstChunk = Math.max(0, currentChunk - 1);\n        lastChunk = Math.min(chunkCount - 1, currentChunk + 1);\n\n        that.selectpicker.view.position0 = isVirtual === false ? 0 : (Math.max(0, chunks[firstChunk][0]) || 0);\n        that.selectpicker.view.position1 = isVirtual === false ? size : (Math.min(size, chunks[lastChunk][1]) || 0);\n\n        positionIsDifferent = prevPositions[0] !== that.selectpicker.view.position0 || prevPositions[1] !== that.selectpicker.view.position1;\n\n        if (that.activeElement !== undefined) {\n          if (init) {\n            if (that.activeElement !== that.selectedElement) {\n              that.defocusItem(that.activeElement);\n            }\n            that.activeElement = undefined;\n          }\n\n          if (that.activeElement !== that.selectedElement) {\n            that.defocusItem(that.selectedElement);\n          }\n        }\n\n        if (that.prevActiveElement !== undefined && that.prevActiveElement !== that.activeElement && that.prevActiveElement !== that.selectedElement) {\n          that.defocusItem(that.prevActiveElement);\n        }\n\n        if (init || positionIsDifferent || that.selectpicker.current.hasMore) {\n          previousElements = that.selectpicker.view.visibleElements ? that.selectpicker.view.visibleElements.slice() : [];\n\n          if (isVirtual === false) {\n            that.selectpicker.view.visibleElements = that.selectpicker.current.elements;\n          } else {\n            that.selectpicker.view.visibleElements = that.selectpicker.current.elements.slice(that.selectpicker.view.position0, that.selectpicker.view.position1);\n          }\n\n          that.setOptionStatus();\n\n          // if searching, check to make sure the list has actually been updated before updating DOM\n          // this prevents unnecessary repaints\n          if (isSearching || (isVirtual === false && init)) menuIsDifferent = !isEqual(previousElements, that.selectpicker.view.visibleElements);\n\n          // if virtual scroll is disabled and not searching,\n          // menu should never need to be updated more than once\n          if ((init || isVirtual === true) && menuIsDifferent) {\n            var menuInner = that.$menuInner[0],\n                menuFragment = document.createDocumentFragment(),\n                emptyMenu = menuInner.firstChild.cloneNode(false),\n                marginTop,\n                marginBottom,\n                elements = that.selectpicker.view.visibleElements,\n                toSanitize = [];\n\n            // replace the existing UL with an empty one - this is faster than $.empty()\n            menuInner.replaceChild(emptyMenu, menuInner.firstChild);\n\n            for (var i = 0, visibleElementsLen = elements.length; i < visibleElementsLen; i++) {\n              var element = elements[i],\n                  elText,\n                  elementData;\n\n              if (that.options.sanitize) {\n                elText = element.lastChild;\n\n                if (elText) {\n                  elementData = that.selectpicker.current.data[i + that.selectpicker.view.position0];\n\n                  if (elementData && elementData.content && !elementData.sanitized) {\n                    toSanitize.push(elText);\n                    elementData.sanitized = true;\n                  }\n                }\n              }\n\n              menuFragment.appendChild(element);\n            }\n\n            if (that.options.sanitize && toSanitize.length) {\n              sanitizeHtml(toSanitize, that.options.whiteList, that.options.sanitizeFn);\n            }\n\n            if (isVirtual === true) {\n              marginTop = (that.selectpicker.view.position0 === 0 ? 0 : that.selectpicker.current.data[that.selectpicker.view.position0 - 1].position);\n              marginBottom = (that.selectpicker.view.position1 > size - 1 ? 0 : that.selectpicker.current.data[size - 1].position - that.selectpicker.current.data[that.selectpicker.view.position1 - 1].position);\n\n              menuInner.firstChild.style.marginTop = marginTop + 'px';\n              menuInner.firstChild.style.marginBottom = marginBottom + 'px';\n            } else {\n              menuInner.firstChild.style.marginTop = 0;\n              menuInner.firstChild.style.marginBottom = 0;\n            }\n\n            menuInner.firstChild.appendChild(menuFragment);\n\n            // if an option is encountered that is wider than the current menu width, update the menu width accordingly\n            // switch to ResizeObserver with increased browser support\n            if (isVirtual === true && that.sizeInfo.hasScrollBar) {\n              var menuInnerInnerWidth = menuInner.firstChild.offsetWidth;\n\n              if (init && menuInnerInnerWidth < that.sizeInfo.menuInnerInnerWidth && that.sizeInfo.totalMenuWidth > that.sizeInfo.selectWidth) {\n                menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';\n              } else if (menuInnerInnerWidth > that.sizeInfo.menuInnerInnerWidth) {\n                // set to 0 to get actual width of menu\n                that.$menu[0].style.minWidth = 0;\n\n                var actualMenuWidth = menuInner.firstChild.offsetWidth;\n\n                if (actualMenuWidth > that.sizeInfo.menuInnerInnerWidth) {\n                  that.sizeInfo.menuInnerInnerWidth = actualMenuWidth;\n                  menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';\n                }\n\n                // reset to default CSS styling\n                that.$menu[0].style.minWidth = '';\n              }\n            }\n          }\n\n          if ((!isSearching && that.options.source.data || isSearching && that.options.source.search) && that.selectpicker.current.hasMore && currentChunk === chunkCount - 1) {\n            // Don't load the next chunk until scrolling has started\n            // This prevents unnecessary requests while the user is typing if pageSize is <= chunkSize\n            if (scrollTop > 0) {\n              // Chunks use 0-based indexing, but pages use 1-based. Add 1 to convert and add 1 again to get next page\n              var page = Math.floor((currentChunk * that.options.chunkSize) / that.options.source.pageSize) + 2;\n\n              that.fetchData(function () {\n                that.render();\n                that.buildList(size, isSearching);\n                that.setPositionData();\n                scroll(scrollTop);\n              }, isSearching ? 'search' : 'data', page, isSearching ? that.selectpicker.search.previousValue : undefined);\n            }\n          }\n        }\n\n        that.prevActiveElement = that.activeElement;\n\n        if (!that.options.liveSearch) {\n          that.$menuInner.trigger('focus');\n        } else if (isSearching && init) {\n          var index = 0,\n              newActive;\n\n          if (!that.selectpicker.view.canHighlight[index]) {\n            index = 1 + that.selectpicker.view.canHighlight.slice(1).indexOf(true);\n          }\n\n          newActive = that.selectpicker.view.visibleElements[index];\n\n          that.defocusItem(that.selectpicker.view.currentActive);\n\n          that.activeElement = (that.selectpicker.current.data[index] || {}).element;\n\n          that.focusItem(newActive);\n        }\n      }\n\n      $(window)\n        .off('resize' + EVENT_KEY + '.' + this.selectId + '.createView')\n        .on('resize' + EVENT_KEY + '.' + this.selectId + '.createView', function () {\n          var isActive = that.$newElement.hasClass(classNames.SHOW);\n\n          if (isActive) scroll(that.$menuInner[0].scrollTop);\n        });\n    },\n\n    focusItem: function (li, liData, noStyle) {\n      if (li) {\n        liData = liData || this.selectpicker.current.data[this.selectpicker.current.elements.indexOf(this.activeElement)];\n        var a = li.firstChild;\n\n        if (a) {\n          a.setAttribute('aria-setsize', this.selectpicker.view.size);\n          a.setAttribute('aria-posinset', liData.posinset);\n\n          if (noStyle !== true) {\n            this.focusedParent.setAttribute('aria-activedescendant', a.id);\n            li.classList.add('active');\n            a.classList.add('active');\n          }\n        }\n      }\n    },\n\n    defocusItem: function (li) {\n      if (li) {\n        li.classList.remove('active');\n        if (li.firstChild) li.firstChild.classList.remove('active');\n      }\n    },\n\n    setPlaceholder: function () {\n      var that = this,\n          updateIndex = false;\n\n      if ((this.options.placeholder || this.options.allowClear) && !this.multiple) {\n        if (!this.selectpicker.view.titleOption) this.selectpicker.view.titleOption = document.createElement('option');\n\n        // this option doesn't create a new <li> element, but does add a new option at the start,\n        // so startIndex should increase to prevent having to check every option for the bs-title-option class\n        updateIndex = true;\n\n        var element = this.$element[0],\n            selectTitleOption = false,\n            titleNotAppended = !this.selectpicker.view.titleOption.parentNode,\n            selectedIndex = element.selectedIndex,\n            selectedOption = element.options[selectedIndex],\n            firstSelectable = element.querySelector('select > *:not(:disabled)'),\n            firstSelectableIndex = firstSelectable ? firstSelectable.index : 0,\n            navigation = window.performance && window.performance.getEntriesByType('navigation'),\n            // Safari doesn't support getEntriesByType('navigation') - fall back to performance.navigation\n            isNotBackForward = (navigation && navigation.length) ? navigation[0].type !== 'back_forward' : window.performance.navigation.type !== 2;\n\n        if (titleNotAppended) {\n          // Use native JS to prepend option (faster)\n          this.selectpicker.view.titleOption.className = 'bs-title-option';\n          this.selectpicker.view.titleOption.value = '';\n\n          // Check if selected or data-selected attribute is already set on an option. If not, select the titleOption option.\n          // the selected item may have been changed by user or programmatically before the bootstrap select plugin runs,\n          // if so, the select will have the data-selected attribute\n          selectTitleOption = !selectedOption || (selectedIndex === firstSelectableIndex && selectedOption.defaultSelected === false && this.$element.data('selected') === undefined);\n        }\n\n        if (titleNotAppended || this.selectpicker.view.titleOption.index !== 0) {\n          element.insertBefore(this.selectpicker.view.titleOption, element.firstChild);\n        }\n\n        // Set selected *after* appending to select,\n        // otherwise the option doesn't get selected in IE\n        // set using selectedIndex, as setting the selected attr to true here doesn't work in IE11\n        if (selectTitleOption && isNotBackForward) {\n          element.selectedIndex = 0;\n        } else if (document.readyState !== 'complete') {\n          // if navigation type is back_forward, there's a chance the select will have its value set by BFCache\n          // wait for that value to be set, then run render again\n          window.addEventListener('pageshow', function () {\n            if (that.selectpicker.view.displayedValue !== element.value) that.render();\n          });\n        }\n      }\n\n      return updateIndex;\n    },\n\n    fetchData: function (callback, type, page, searchValue) {\n      page = page || 1;\n      type = type || 'data';\n\n      var that = this,\n          data = this.options.source[type],\n          builtData;\n\n      if (data) {\n        this.options.virtualScroll = true;\n\n        if (typeof data === 'function') {\n          data.call(\n            this,\n            function (data, more, totalItems) {\n              var current = that.selectpicker[type === 'search' ? 'search' : 'main'];\n              current.hasMore = more;\n              current.totalItems = totalItems;\n              builtData = that.buildData(data, type);\n              callback.call(that, builtData);\n              that.$element.trigger('fetched' + EVENT_KEY);\n            },\n            page,\n            searchValue\n          );\n        } else if (Array.isArray(data)) {\n          builtData = that.buildData(data, type);\n          callback.call(that, builtData);\n        }\n      } else {\n        builtData = this.buildData(false, type);\n        callback.call(that, builtData);\n      }\n    },\n\n    buildData: function (data, type) {\n      var that = this;\n      var dataGetter = data === false ? getOptionData.fromOption : getOptionData.fromDataSource;\n\n      var optionSelector = ':not([hidden]):not([data-hidden=\"true\"]):not([style*=\"display: none\"])',\n          mainData = [],\n          startLen = this.selectpicker.main.data ? this.selectpicker.main.data.length : 0,\n          optID = 0,\n          startIndex = this.setPlaceholder() && !data ? 1 : 0; // append the titleOption if necessary and skip the first option in the loop\n\n      if (type === 'search') {\n        startLen = this.selectpicker.search.data.length;\n      }\n\n      if (this.options.hideDisabled) optionSelector += ':not(:disabled)';\n\n      var selectOptions = data ? data.filter(filterHidden, this) : this.$element[0].querySelectorAll('select > *' + optionSelector);\n\n      function addDivider (config) {\n        var previousData = mainData[mainData.length - 1];\n\n        // ensure optgroup doesn't create back-to-back dividers\n        if (\n          previousData &&\n          previousData.type === 'divider' &&\n          (previousData.optID || config.optID)\n        ) {\n          return;\n        }\n\n        config = config || {};\n        config.type = 'divider';\n\n        mainData.push(config);\n      }\n\n      function addOption (item, config) {\n        config = config || {};\n\n        config.divider = dataGetter(item, 'divider');\n\n        if (config.divider === true) {\n          addDivider({\n            optID: config.optID\n          });\n        } else {\n          var liIndex = mainData.length + startLen,\n              cssText = dataGetter(item, 'style'),\n              inlineStyle = cssText ? htmlEscape(cssText) : '',\n              optionClass = (item.className || '') + (config.optgroupClass || '');\n\n          if (config.optID) optionClass = 'opt ' + optionClass;\n\n          config.optionClass = optionClass.trim();\n          config.inlineStyle = inlineStyle;\n\n          config.text = dataGetter(item, 'text');\n          config.title = dataGetter(item, 'title');\n          config.content = dataGetter(item, 'content');\n          config.tokens = dataGetter(item, 'tokens');\n          config.subtext = dataGetter(item, 'subtext');\n          config.icon = dataGetter(item, 'icon');\n\n          config.display = config.content || config.text;\n          config.value = item.value === undefined ? item.text : item.value;\n          config.type = 'option';\n          config.index = liIndex;\n\n          config.option = !item.option ? item : item.option; // reference option element if it exists\n          config.option.liIndex = liIndex;\n          config.selected = !!item.selected;\n          config.disabled = config.disabled || !!item.disabled;\n\n          if (data !== false) {\n            if (that.selectpicker.optionValuesDataMap[config.value]) {\n              config = $.extend(that.selectpicker.optionValuesDataMap[config.value], config);\n            } else {\n              that.selectpicker.optionValuesDataMap[config.value] = config;\n            }\n          }\n\n          mainData.push(config);\n        }\n      }\n\n      function addOptgroup (index, selectOptions) {\n        var optgroup = selectOptions[index],\n            // skip placeholder option\n            previous = index - 1 < startIndex ? false : selectOptions[index - 1],\n            next = selectOptions[index + 1],\n            options = data ? optgroup.children.filter(filterHidden, this) : optgroup.querySelectorAll('option' + optionSelector);\n\n        if (!options.length) return;\n\n        var config = {\n              display: htmlEscape(dataGetter(item, 'label')),\n              subtext: dataGetter(optgroup, 'subtext'),\n              icon: dataGetter(optgroup, 'icon'),\n              type: 'optgroup-label',\n              optgroupClass: ' ' + (optgroup.className || ''),\n              optgroup: optgroup\n            },\n            headerIndex,\n            lastIndex;\n\n        optID++;\n\n        if (previous) {\n          addDivider({ optID: optID });\n        }\n\n        config.optID = optID;\n\n        mainData.push(config);\n\n        for (var j = 0, len = options.length; j < len; j++) {\n          var option = options[j];\n\n          if (j === 0) {\n            headerIndex = mainData.length - 1;\n            lastIndex = headerIndex + len;\n          }\n\n          addOption(option, {\n            headerIndex: headerIndex,\n            lastIndex: lastIndex,\n            optID: config.optID,\n            optgroupClass: config.optgroupClass,\n            disabled: optgroup.disabled\n          });\n        }\n\n        if (next) {\n          addDivider({ optID: optID });\n        }\n      }\n\n      for (var len = selectOptions.length, i = startIndex; i < len; i++) {\n        var item = selectOptions[i],\n            children = item.children;\n\n        if (children && children.length) {\n          addOptgroup.call(this, i, selectOptions);\n        } else {\n          addOption.call(this, item, {});\n        }\n      }\n\n      switch (type) {\n        case 'data': {\n          if (!this.selectpicker.main.data) {\n            this.selectpicker.main.data = [];\n          }\n          Array.prototype.push.apply(this.selectpicker.main.data, mainData);\n          this.selectpicker.current.data = this.selectpicker.main.data;\n          break;\n        }\n        case 'search': {\n          Array.prototype.push.apply(this.selectpicker.search.data, mainData);\n          break;\n        }\n      }\n\n      return mainData;\n    },\n\n    buildList: function (size, searching) {\n      var that = this,\n          selectData = searching ? this.selectpicker.search.data : this.selectpicker.main.data,\n          mainElements = [],\n          widestOptionLength = 0;\n\n      if ((that.options.showTick || that.multiple) && !elementTemplates.checkMark.parentNode) {\n        elementTemplates.checkMark.className = this.options.iconBase + ' ' + that.options.tickIcon + ' check-mark';\n        elementTemplates.a.appendChild(elementTemplates.checkMark);\n      }\n\n      function buildElement (mainElements, item) {\n        var liElement,\n            combinedLength = 0;\n\n        switch (item.type) {\n          case 'divider':\n            liElement = generateOption.li(\n              false,\n              classNames.DIVIDER,\n              (item.optID ? item.optID + 'div' : undefined)\n            );\n\n            break;\n\n          case 'option':\n            liElement = generateOption.li(\n              generateOption.a(\n                generateOption.text.call(that, item),\n                item.optionClass,\n                item.inlineStyle\n              ),\n              '',\n              item.optID\n            );\n\n            if (liElement.firstChild) {\n              liElement.firstChild.id = that.selectId + '-' + item.index;\n            }\n\n            break;\n\n          case 'optgroup-label':\n            liElement = generateOption.li(\n              generateOption.label.call(that, item),\n              'dropdown-header' + item.optgroupClass,\n              item.optID\n            );\n\n            break;\n        }\n\n        if (!item.element) {\n          item.element = liElement;\n        } else {\n          item.element.innerHTML = liElement.innerHTML;\n        }\n        mainElements.push(item.element);\n\n        // count the number of characters in the option - not perfect, but should work in most cases\n        if (item.display) combinedLength += item.display.length;\n        if (item.subtext) combinedLength += item.subtext.length;\n        // if there is an icon, ensure this option's width is checked\n        if (item.icon) combinedLength += 1;\n\n        if (combinedLength > widestOptionLength) {\n          widestOptionLength = combinedLength;\n\n          // guess which option is the widest\n          // use this when calculating menu width\n          // not perfect, but it's fast, and the width will be updating accordingly when scrolling\n          that.selectpicker.view.widestOption = mainElements[mainElements.length - 1];\n        }\n      }\n\n      var startIndex = size || 0;\n\n      for (var len = selectData.length, i = startIndex; i < len; i++) {\n        var item = selectData[i];\n\n        buildElement(mainElements, item);\n      }\n\n      if (size) {\n        if (searching) {\n          Array.prototype.push.apply(this.selectpicker.search.elements, mainElements);\n        } else {\n          Array.prototype.push.apply(this.selectpicker.main.elements, mainElements);\n          this.selectpicker.current.elements = this.selectpicker.main.elements;\n        }\n      } else {\n        if (searching) {\n          this.selectpicker.search.elements = mainElements;\n        } else {\n          this.selectpicker.main.elements = this.selectpicker.current.elements = mainElements;\n        }\n      }\n    },\n\n    findLis: function () {\n      return this.$menuInner.find('.inner > li');\n    },\n\n    render: function (init) {\n      var that = this,\n          element = this.$element[0],\n          // ensure titleOption is appended and selected (if necessary) before getting selectedOptions\n          placeholderSelected = this.setPlaceholder() && element.selectedIndex === 0,\n          selectedOptions = getSelectedOptions.call(this),\n          selectedCount = selectedOptions.length,\n          selectedValues = getSelectValues.call(this, selectedOptions),\n          button = this.$button[0],\n          buttonInner = button.querySelector('.filter-option-inner-inner'),\n          multipleSeparator = document.createTextNode(this.options.multipleSeparator),\n          titleFragment = elementTemplates.fragment.cloneNode(false),\n          showCount,\n          countMax,\n          hasContent = false;\n\n      function createSelected (item) {\n        if (item.selected) {\n          that.createOption(item, true);\n        } else if (item.children && item.children.length) {\n          item.children.map(createSelected);\n        }\n      }\n\n      // create selected option elements to ensure select value is correct\n      if (this.options.source.data && init) {\n        selectedOptions.map(createSelected);\n        element.appendChild(this.selectpicker.main.optionQueue);\n\n        if (placeholderSelected) placeholderSelected = element.selectedIndex === 0;\n      }\n\n      button.classList.toggle('bs-placeholder', that.multiple ? !selectedCount : !selectedValues && selectedValues !== 0);\n\n      if (!that.multiple && selectedOptions.length === 1) {\n        that.selectpicker.view.displayedValue = selectedValues;\n      }\n\n      if (this.options.selectedTextFormat === 'static') {\n        titleFragment = generateOption.text.call(this, { text: this.options.placeholder }, true);\n      } else {\n        showCount = this.multiple && this.options.selectedTextFormat.indexOf('count') !== -1 && selectedCount > 0;\n\n        // determine if the number of selected options will be shown (showCount === true)\n        if (showCount) {\n          countMax = this.options.selectedTextFormat.split('>');\n          showCount = (countMax.length > 1 && selectedCount > countMax[1]) || (countMax.length === 1 && selectedCount >= 2);\n        }\n\n        // only loop through all selected options if the count won't be shown\n        if (showCount === false) {\n          if (!placeholderSelected) {\n            for (var selectedIndex = 0; selectedIndex < selectedCount; selectedIndex++) {\n              if (selectedIndex < 50) {\n                var option = selectedOptions[selectedIndex],\n                    titleOptions = {};\n\n                if (option) {\n                  if (this.multiple && selectedIndex > 0) {\n                    titleFragment.appendChild(multipleSeparator.cloneNode(false));\n                  }\n\n                  if (option.title) {\n                    titleOptions.text = option.title;\n                  } else if (option.content && that.options.showContent) {\n                    titleOptions.content = option.content.toString();\n                    hasContent = true;\n                  } else {\n                    if (that.options.showIcon) {\n                      titleOptions.icon = option.icon;\n                    }\n                    if (that.options.showSubtext && !that.multiple && option.subtext) titleOptions.subtext = ' ' + option.subtext;\n                    titleOptions.text = option.text.trim();\n                  }\n\n                  titleFragment.appendChild(generateOption.text.call(this, titleOptions, true));\n                }\n              } else {\n                break;\n              }\n            }\n\n            // add ellipsis\n            if (selectedCount > 49) {\n              titleFragment.appendChild(document.createTextNode('...'));\n            }\n          }\n        } else {\n          var optionSelector = ':not([hidden]):not([data-hidden=\"true\"]):not([data-divider=\"true\"]):not([style*=\"display: none\"])';\n          if (this.options.hideDisabled) optionSelector += ':not(:disabled)';\n\n          // If this is a multiselect, and selectedTextFormat is count, then show 1 of 2 selected, etc.\n          var totalCount = this.$element[0].querySelectorAll('select > option' + optionSelector + ', optgroup' + optionSelector + ' option' + optionSelector).length,\n              tr8nText = (typeof this.options.countSelectedText === 'function') ? this.options.countSelectedText(selectedCount, totalCount) : this.options.countSelectedText;\n\n          titleFragment = generateOption.text.call(this, {\n            text: tr8nText.replace('{0}', selectedCount.toString()).replace('{1}', totalCount.toString())\n          }, true);\n        }\n      }\n\n      // If the select doesn't have a title, then use the default, or if nothing is set at all, use noneSelectedText\n      if (!titleFragment.childNodes.length) {\n        titleFragment = generateOption.text.call(this, {\n          text: this.options.placeholder ? this.options.placeholder : this.options.noneSelectedText\n        }, true);\n      }\n\n      // if the select has a title, apply it to the button, and if not, apply titleFragment text\n      // strip all HTML tags and trim the result, then unescape any escaped tags\n      button.title = titleFragment.textContent.replace(/<[^>]*>?/g, '').trim();\n\n      if (this.options.sanitize && hasContent) {\n        sanitizeHtml([titleFragment], that.options.whiteList, that.options.sanitizeFn);\n      }\n\n      buttonInner.innerHTML = '';\n      buttonInner.appendChild(titleFragment);\n\n      if (version.major < 4 && this.$newElement[0].classList.contains('bs3-has-addon')) {\n        var filterExpand = button.querySelector('.filter-expand'),\n            clone = buttonInner.cloneNode(true);\n\n        clone.className = 'filter-expand';\n\n        if (filterExpand) {\n          button.replaceChild(clone, filterExpand);\n        } else {\n          button.appendChild(clone);\n        }\n      }\n\n      this.$element.trigger('rendered' + EVENT_KEY);\n    },\n\n    /**\n     * @param [style]\n     * @param [status]\n     */\n    setStyle: function (newStyle, status) {\n      var button = this.$button[0],\n          newElement = this.$newElement[0],\n          style = this.options.style.trim(),\n          buttonClass;\n\n      if (this.$element.attr('class')) {\n        this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|bs-select-hidden|validate\\[.*\\]/gi, ''));\n      }\n\n      if (version.major < 4) {\n        newElement.classList.add('bs3');\n\n        if (newElement.parentNode.classList && newElement.parentNode.classList.contains('input-group') &&\n            (newElement.previousElementSibling || newElement.nextElementSibling) &&\n            (newElement.previousElementSibling || newElement.nextElementSibling).classList.contains('input-group-addon')\n        ) {\n          newElement.classList.add('bs3-has-addon');\n        }\n      }\n\n      if (newStyle) {\n        buttonClass = newStyle.trim();\n      } else {\n        buttonClass = style;\n      }\n\n      if (status == 'add') {\n        if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));\n      } else if (status == 'remove') {\n        if (buttonClass) button.classList.remove.apply(button.classList, buttonClass.split(' '));\n      } else {\n        if (style) button.classList.remove.apply(button.classList, style.split(' '));\n        if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));\n      }\n    },\n\n    liHeight: function (refresh) {\n      if (!refresh && (this.options.size === false || Object.keys(this.sizeInfo).length)) return;\n\n      var newElement = elementTemplates.div.cloneNode(false),\n          menu = elementTemplates.div.cloneNode(false),\n          menuInner = elementTemplates.div.cloneNode(false),\n          menuInnerInner = document.createElement('ul'),\n          divider = elementTemplates.li.cloneNode(false),\n          dropdownHeader = elementTemplates.li.cloneNode(false),\n          li,\n          a = elementTemplates.a.cloneNode(false),\n          text = elementTemplates.span.cloneNode(false),\n          header = this.options.header && this.$menu.find('.' + classNames.POPOVERHEADER).length > 0 ? this.$menu.find('.' + classNames.POPOVERHEADER)[0].cloneNode(true) : null,\n          search = this.options.liveSearch ? elementTemplates.div.cloneNode(false) : null,\n          actions = this.options.actionsBox && this.multiple && this.$menu.find('.bs-actionsbox').length > 0 ? this.$menu.find('.bs-actionsbox')[0].cloneNode(true) : null,\n          doneButton = this.options.doneButton && this.multiple && this.$menu.find('.bs-donebutton').length > 0 ? this.$menu.find('.bs-donebutton')[0].cloneNode(true) : null,\n          firstOption = this.$element[0].options[0];\n\n      this.sizeInfo.selectWidth = this.$newElement[0].offsetWidth;\n\n      text.className = 'text';\n      a.className = 'dropdown-item ' + (firstOption ? firstOption.className : '');\n      newElement.className = this.$menu[0].parentNode.className + ' ' + classNames.SHOW;\n      newElement.style.width = 0; // ensure button width doesn't affect natural width of menu when calculating\n      if (this.options.width === 'auto') menu.style.minWidth = 0;\n      menu.className = classNames.MENU + ' ' + classNames.SHOW;\n      menuInner.className = 'inner ' + classNames.SHOW;\n      menuInnerInner.className = classNames.MENU + ' inner ' + (version.major >= '4' ? classNames.SHOW : '');\n      divider.className = classNames.DIVIDER;\n      dropdownHeader.className = 'dropdown-header';\n\n      text.appendChild(document.createTextNode('\\u200b'));\n\n      if (this.selectpicker.current.data.length) {\n        for (var i = 0; i < this.selectpicker.current.data.length; i++) {\n          var data = this.selectpicker.current.data[i];\n          if (data.type === 'option' && $(data.element.firstChild).css('display') !== 'none') {\n            li = data.element;\n            break;\n          }\n        }\n      } else {\n        li = elementTemplates.li.cloneNode(false);\n        a.appendChild(text);\n        li.appendChild(a);\n      }\n\n      dropdownHeader.appendChild(text.cloneNode(true));\n\n      if (this.selectpicker.view.widestOption) {\n        menuInnerInner.appendChild(this.selectpicker.view.widestOption.cloneNode(true));\n      }\n\n      menuInnerInner.appendChild(li);\n      menuInnerInner.appendChild(divider);\n      menuInnerInner.appendChild(dropdownHeader);\n      if (header) menu.appendChild(header);\n      if (search) {\n        var input = document.createElement('input');\n        search.className = 'bs-searchbox';\n        input.className = 'form-control';\n        search.appendChild(input);\n        menu.appendChild(search);\n      }\n      if (actions) menu.appendChild(actions);\n      menuInner.appendChild(menuInnerInner);\n      menu.appendChild(menuInner);\n      if (doneButton) menu.appendChild(doneButton);\n      newElement.appendChild(menu);\n\n      document.body.appendChild(newElement);\n\n      var liHeight = li.offsetHeight,\n          dropdownHeaderHeight = dropdownHeader ? dropdownHeader.offsetHeight : 0,\n          headerHeight = header ? header.offsetHeight : 0,\n          searchHeight = search ? search.offsetHeight : 0,\n          actionsHeight = actions ? actions.offsetHeight : 0,\n          doneButtonHeight = doneButton ? doneButton.offsetHeight : 0,\n          dividerHeight = $(divider).outerHeight(true),\n          menuStyle = window.getComputedStyle(menu),\n          menuWidth = menu.offsetWidth,\n          menuPadding = {\n            vert: toInteger(menuStyle.paddingTop) +\n                  toInteger(menuStyle.paddingBottom) +\n                  toInteger(menuStyle.borderTopWidth) +\n                  toInteger(menuStyle.borderBottomWidth),\n            horiz: toInteger(menuStyle.paddingLeft) +\n                  toInteger(menuStyle.paddingRight) +\n                  toInteger(menuStyle.borderLeftWidth) +\n                  toInteger(menuStyle.borderRightWidth)\n          },\n          menuExtras = {\n            vert: menuPadding.vert +\n                  toInteger(menuStyle.marginTop) +\n                  toInteger(menuStyle.marginBottom) + 2,\n            horiz: menuPadding.horiz +\n                  toInteger(menuStyle.marginLeft) +\n                  toInteger(menuStyle.marginRight) + 2\n          },\n          scrollBarWidth;\n\n      menuInner.style.overflowY = 'scroll';\n\n      scrollBarWidth = menu.offsetWidth - menuWidth;\n\n      document.body.removeChild(newElement);\n\n      this.sizeInfo.liHeight = liHeight;\n      this.sizeInfo.dropdownHeaderHeight = dropdownHeaderHeight;\n      this.sizeInfo.headerHeight = headerHeight;\n      this.sizeInfo.searchHeight = searchHeight;\n      this.sizeInfo.actionsHeight = actionsHeight;\n      this.sizeInfo.doneButtonHeight = doneButtonHeight;\n      this.sizeInfo.dividerHeight = dividerHeight;\n      this.sizeInfo.menuPadding = menuPadding;\n      this.sizeInfo.menuExtras = menuExtras;\n      this.sizeInfo.menuWidth = menuWidth;\n      this.sizeInfo.menuInnerInnerWidth = menuWidth - menuPadding.horiz;\n      this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth;\n      this.sizeInfo.scrollBarWidth = scrollBarWidth;\n      this.sizeInfo.selectHeight = this.$newElement[0].offsetHeight;\n\n      this.setPositionData();\n    },\n\n    getSelectPosition: function () {\n      var that = this,\n          $window = $(window),\n          pos = that.$newElement.offset(),\n          $container = $(that.options.container),\n          containerPos;\n\n      if (that.options.container && $container.length && !$container.is('body')) {\n        containerPos = $container.offset();\n        containerPos.top += parseInt($container.css('borderTopWidth'));\n        containerPos.left += parseInt($container.css('borderLeftWidth'));\n      } else {\n        containerPos = { top: 0, left: 0 };\n      }\n\n      var winPad = that.options.windowPadding;\n\n      this.sizeInfo.selectOffsetTop = pos.top - containerPos.top - $window.scrollTop();\n      this.sizeInfo.selectOffsetBot = $window.height() - this.sizeInfo.selectOffsetTop - this.sizeInfo.selectHeight - containerPos.top - winPad[2];\n      this.sizeInfo.selectOffsetLeft = pos.left - containerPos.left - $window.scrollLeft();\n      this.sizeInfo.selectOffsetRight = $window.width() - this.sizeInfo.selectOffsetLeft - this.sizeInfo.selectWidth - containerPos.left - winPad[1];\n      this.sizeInfo.selectOffsetTop -= winPad[0];\n      this.sizeInfo.selectOffsetLeft -= winPad[3];\n    },\n\n    setMenuSize: function (isAuto) {\n      this.getSelectPosition();\n\n      var selectWidth = this.sizeInfo.selectWidth,\n          liHeight = this.sizeInfo.liHeight,\n          headerHeight = this.sizeInfo.headerHeight,\n          searchHeight = this.sizeInfo.searchHeight,\n          actionsHeight = this.sizeInfo.actionsHeight,\n          doneButtonHeight = this.sizeInfo.doneButtonHeight,\n          divHeight = this.sizeInfo.dividerHeight,\n          menuPadding = this.sizeInfo.menuPadding,\n          menuInnerHeight,\n          menuHeight,\n          divLength = 0,\n          minHeight,\n          _minHeight,\n          maxHeight,\n          menuInnerMinHeight,\n          estimate,\n          isDropup;\n\n      if (this.options.dropupAuto) {\n        // Get the estimated height of the menu without scrollbars.\n        // This is useful for smaller menus, where there might be plenty of room\n        // below the button without setting dropup, but we can't know\n        // the exact height of the menu until createView is called later\n        estimate = liHeight * this.selectpicker.current.data.length + menuPadding.vert;\n\n        isDropup = this.sizeInfo.selectOffsetTop - this.sizeInfo.selectOffsetBot > this.sizeInfo.menuExtras.vert && estimate + this.sizeInfo.menuExtras.vert + 50 > this.sizeInfo.selectOffsetBot;\n\n        // ensure dropup doesn't change while searching (so menu doesn't bounce back and forth)\n        if (this.selectpicker.isSearching === true) {\n          isDropup = this.selectpicker.dropup;\n        }\n\n        this.$newElement.toggleClass(classNames.DROPUP, isDropup);\n        this.selectpicker.dropup = isDropup;\n      }\n\n      if (this.options.size === 'auto') {\n        _minHeight = this.selectpicker.current.data.length > 3 ? this.sizeInfo.liHeight * 3 + this.sizeInfo.menuExtras.vert - 2 : 0;\n        menuHeight = this.sizeInfo.selectOffsetBot - this.sizeInfo.menuExtras.vert;\n        minHeight = _minHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;\n        menuInnerMinHeight = Math.max(_minHeight - menuPadding.vert, 0);\n\n        if (this.$newElement.hasClass(classNames.DROPUP)) {\n          menuHeight = this.sizeInfo.selectOffsetTop - this.sizeInfo.menuExtras.vert;\n        }\n\n        maxHeight = menuHeight;\n        menuInnerHeight = menuHeight - headerHeight - searchHeight - actionsHeight - doneButtonHeight - menuPadding.vert;\n      } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {\n        for (var i = 0; i < this.options.size; i++) {\n          if (this.selectpicker.current.data[i].type === 'divider') divLength++;\n        }\n\n        menuHeight = liHeight * this.options.size + divLength * divHeight + menuPadding.vert;\n        menuInnerHeight = menuHeight - menuPadding.vert;\n        maxHeight = menuHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;\n        minHeight = menuInnerMinHeight = '';\n      }\n\n      this.$menu.css({\n        'max-height': maxHeight + 'px',\n        'overflow': 'hidden',\n        'min-height': minHeight + 'px'\n      });\n\n      this.$menuInner.css({\n        'max-height': menuInnerHeight + 'px',\n        'overflow': 'hidden auto',\n        'min-height': menuInnerMinHeight + 'px'\n      });\n\n      // ensure menuInnerHeight is always a positive number to prevent issues calculating chunkSize in createView\n      this.sizeInfo.menuInnerHeight = Math.max(menuInnerHeight, 1);\n\n      if (this.selectpicker.current.data.length && this.selectpicker.current.data[this.selectpicker.current.data.length - 1].position > this.sizeInfo.menuInnerHeight) {\n        this.sizeInfo.hasScrollBar = true;\n        this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth + this.sizeInfo.scrollBarWidth;\n      }\n\n      if (this.options.dropdownAlignRight === 'auto') {\n        this.$menu.toggleClass(classNames.MENURIGHT, this.sizeInfo.selectOffsetLeft > this.sizeInfo.selectOffsetRight && this.sizeInfo.selectOffsetRight < (this.sizeInfo.totalMenuWidth - selectWidth));\n      }\n\n      if (this.dropdown && this.dropdown._popper) this.dropdown._popper.update();\n    },\n\n    setSize: function (refresh) {\n      this.liHeight(refresh);\n\n      if (this.options.header) this.$menu.css('padding-top', 0);\n\n      if (this.options.size !== false) {\n        var that = this,\n            $window = $(window);\n\n        this.setMenuSize();\n\n        if (this.options.liveSearch) {\n          this.$searchbox\n            .off('input.setMenuSize propertychange.setMenuSize')\n            .on('input.setMenuSize propertychange.setMenuSize', function () {\n              return that.setMenuSize();\n            });\n        }\n\n        if (this.options.size === 'auto') {\n          $window\n            .off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize')\n            .on('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize', function () {\n              return that.setMenuSize();\n            });\n        } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {\n          $window.off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize');\n        }\n      }\n\n      this.createView(false, true, refresh);\n    },\n\n    setWidth: function () {\n      var that = this;\n\n      if (this.options.width === 'auto') {\n        requestAnimationFrame(function () {\n          that.$menu.css('min-width', '0');\n\n          that.$element.on('loaded' + EVENT_KEY, function () {\n            that.liHeight();\n            that.setMenuSize();\n\n            // Get correct width if element is hidden\n            var $selectClone = that.$newElement.clone().appendTo('body'),\n                btnWidth = $selectClone.css('width', 'auto').children('button').outerWidth();\n\n            $selectClone.remove();\n\n            // Set width to whatever's larger, button title or longest option\n            that.sizeInfo.selectWidth = Math.max(that.sizeInfo.totalMenuWidth, btnWidth);\n            that.$newElement.css('width', that.sizeInfo.selectWidth + 'px');\n          });\n        });\n      } else if (this.options.width === 'fit') {\n        // Remove inline min-width so width can be changed from 'auto'\n        this.$menu.css('min-width', '');\n        this.$newElement.css('width', '').addClass('fit-width');\n      } else if (this.options.width) {\n        // Remove inline min-width so width can be changed from 'auto'\n        this.$menu.css('min-width', '');\n        this.$newElement.css('width', this.options.width);\n      } else {\n        // Remove inline min-width/width so width can be changed\n        this.$menu.css('min-width', '');\n        this.$newElement.css('width', '');\n      }\n      // Remove fit-width class if width is changed programmatically\n      if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {\n        this.$newElement[0].classList.remove('fit-width');\n      }\n    },\n\n    selectPosition: function () {\n      this.$bsContainer = $('<div class=\"bs-container\" />');\n\n      var that = this,\n          $container = $(this.options.container),\n          pos,\n          containerPos,\n          actualHeight,\n          getPlacement = function ($element) {\n            var containerPosition = {},\n                // fall back to dropdown's default display setting if display is not manually set\n                display = that.options.display || (\n                  // Bootstrap 3 doesn't have $.fn.dropdown.Constructor.Default\n                  $.fn.dropdown.Constructor.Default ? $.fn.dropdown.Constructor.Default.display\n                  : false\n                );\n\n            that.$bsContainer.addClass($element.attr('class').replace(/form-control|fit-width/gi, '')).toggleClass(classNames.DROPUP, $element.hasClass(classNames.DROPUP));\n            pos = $element.offset();\n\n            if (!$container.is('body')) {\n              containerPos = $container.offset();\n              containerPos.top += parseInt($container.css('borderTopWidth')) - $container.scrollTop();\n              containerPos.left += parseInt($container.css('borderLeftWidth')) - $container.scrollLeft();\n            } else {\n              containerPos = { top: 0, left: 0 };\n            }\n\n            actualHeight = $element.hasClass(classNames.DROPUP) ? 0 : $element[0].offsetHeight;\n\n            // Bootstrap 4+ uses Popper for menu positioning\n            if (version.major < 4 || display === 'static') {\n              containerPosition.top = pos.top - containerPos.top + actualHeight;\n              containerPosition.left = pos.left - containerPos.left;\n            }\n\n            containerPosition.width = $element[0].offsetWidth;\n\n            that.$bsContainer.css(containerPosition);\n          };\n\n      this.$button.on('click.bs.dropdown.data-api', function () {\n        if (that.isDisabled()) {\n          return;\n        }\n\n        getPlacement(that.$newElement);\n\n        that.$bsContainer\n          .appendTo(that.options.container)\n          .toggleClass(classNames.SHOW, !that.$button.hasClass(classNames.SHOW))\n          .append(that.$menu);\n      });\n\n      $(window)\n        .off('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId)\n        .on('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId, function () {\n          var isActive = that.$newElement.hasClass(classNames.SHOW);\n\n          if (isActive) getPlacement(that.$newElement);\n        });\n\n      this.$element.on('hide' + EVENT_KEY, function () {\n        that.$menu.data('height', that.$menu.height());\n        that.$bsContainer.detach();\n      });\n    },\n\n    createOption: function (data, init) {\n      var optionData = !data.option ? data : data.option;\n\n      if (optionData && optionData.nodeType !== 1) {\n        var option = (init ? elementTemplates.selectedOption : elementTemplates.option).cloneNode(true);\n        if (optionData.value !== undefined) option.value = optionData.value;\n        option.textContent = optionData.text;\n\n        option.selected = true;\n\n        if (optionData.liIndex !== undefined) {\n          option.liIndex = optionData.liIndex;\n        } else if (!init) {\n          option.liIndex = data.index;\n        }\n\n        data.option = option;\n\n        this.selectpicker.main.optionQueue.appendChild(option);\n      }\n    },\n\n    setOptionStatus: function (selectedOnly) {\n      var that = this;\n\n      that.noScroll = false;\n\n      if (that.selectpicker.view.visibleElements && that.selectpicker.view.visibleElements.length) {\n        for (var i = 0; i < that.selectpicker.view.visibleElements.length; i++) {\n          var liData = that.selectpicker.current.data[i + that.selectpicker.view.position0],\n              option = liData.option;\n\n          if (option) {\n            if (selectedOnly !== true) {\n              that.setDisabled(liData);\n            }\n\n            that.setSelected(liData);\n          }\n        }\n\n        // append optionQueue (documentFragment with option elements for select options)\n        if (this.options.source.data) this.$element[0].appendChild(this.selectpicker.main.optionQueue);\n      }\n    },\n\n    /**\n     * @param {Object} liData - the option object that is being changed\n     * @param {boolean} selected - true if the option is being selected, false if being deselected\n     */\n    setSelected: function (liData, selected) {\n      selected = selected === undefined ? liData.selected : selected;\n\n      var li = liData.element,\n          activeElementIsSet = this.activeElement !== undefined,\n          thisIsActive = this.activeElement === li,\n          prevActive,\n          a,\n          // if current option is already active\n          // OR\n          // if the current option is being selected, it's NOT multiple, and\n          // activeElement is undefined:\n          //  - when the menu is first being opened, OR\n          //  - after a search has been performed, OR\n          //  - when retainActive is false when selecting a new option (i.e. index of the newly selected option is not the same as the current activeElement)\n          keepActive = thisIsActive || (selected && !this.multiple && !activeElementIsSet);\n\n      if (!li) return;\n\n      if (selected !== undefined) {\n        liData.selected = selected;\n        if (liData.option) liData.option.selected = selected;\n      }\n\n      if (selected && this.options.source.data) {\n        this.createOption(liData, false);\n      }\n\n      a = li.firstChild;\n\n      if (selected) {\n        this.selectedElement = li;\n      }\n\n      li.classList.toggle('selected', selected);\n\n      if (keepActive) {\n        this.focusItem(li, liData);\n        this.selectpicker.view.currentActive = li;\n        this.activeElement = li;\n      } else {\n        this.defocusItem(li);\n      }\n\n      if (a) {\n        a.classList.toggle('selected', selected);\n\n        if (selected) {\n          a.setAttribute('aria-selected', true);\n        } else {\n          if (this.multiple) {\n            a.setAttribute('aria-selected', false);\n          } else {\n            a.removeAttribute('aria-selected');\n          }\n        }\n      }\n\n      if (!keepActive && !activeElementIsSet && selected && this.prevActiveElement !== undefined) {\n        prevActive = this.prevActiveElement;\n\n        this.defocusItem(prevActive);\n      }\n    },\n\n    /**\n     * @param {number} index - the index of the option that is being disabled\n     * @param {boolean} disabled - true if the option is being disabled, false if being enabled\n     */\n    setDisabled: function (liData) {\n      var disabled = liData.disabled,\n          li = liData.element,\n          a;\n\n      if (!li) return;\n\n      a = li.firstChild;\n\n      li.classList.toggle(classNames.DISABLED, disabled);\n\n      if (a) {\n        if (version.major >= '4') a.classList.toggle(classNames.DISABLED, disabled);\n\n        if (disabled) {\n          a.setAttribute('aria-disabled', disabled);\n          a.setAttribute('tabindex', -1);\n        } else {\n          a.removeAttribute('aria-disabled');\n          a.setAttribute('tabindex', 0);\n        }\n      }\n    },\n\n    isDisabled: function () {\n      return this.$element[0].disabled;\n    },\n\n    checkDisabled: function () {\n      if (this.isDisabled()) {\n        this.$newElement[0].classList.add(classNames.DISABLED);\n        this.$button.addClass(classNames.DISABLED).attr('aria-disabled', true);\n      } else {\n        if (this.$button[0].classList.contains(classNames.DISABLED)) {\n          this.$newElement[0].classList.remove(classNames.DISABLED);\n          this.$button.removeClass(classNames.DISABLED).attr('aria-disabled', false);\n        }\n      }\n    },\n\n    clickListener: function () {\n      var that = this,\n          $document = $(document);\n\n      $document.data('spaceSelect', false);\n\n      this.$button.on('keyup', function (e) {\n        if (/(32)/.test(e.keyCode.toString(10)) && $document.data('spaceSelect')) {\n          e.preventDefault();\n          $document.data('spaceSelect', false);\n        }\n      });\n\n      this.$newElement.on('show.bs.dropdown', function () {\n        if (!that.dropdown && version.major === '4') {\n          that.dropdown = that.$button.data('bs.dropdown');\n          that.dropdown._menu = that.$menu[0];\n        }\n      });\n\n      function clearSelection (e) {\n        if (that.multiple) {\n          that.deselectAll();\n        } else {\n          var element = that.$element[0],\n              prevValue = element.value,\n              prevIndex = element.selectedIndex,\n              prevOption = element.options[prevIndex],\n              prevData = prevOption ? that.selectpicker.main.data[prevOption.liIndex] : false;\n\n          if (prevData) {\n            that.setSelected(prevData, false);\n          }\n\n          element.selectedIndex = 0;\n\n          changedArguments = [prevIndex, false, prevValue];\n          that.$element.triggerNative('change');\n        }\n\n        // remove selected styling if menu is open\n        if (that.$newElement.hasClass(classNames.SHOW)) {\n          if (that.options.liveSearch) {\n            that.$searchbox.trigger('focus');\n          }\n\n          that.createView(false);\n        }\n      }\n\n      this.$button.on('click.bs.dropdown.data-api', function (e) {\n        if (that.options.allowClear) {\n          var target = e.target,\n              clearButton = that.$clearButton[0];\n\n          // IE doesn't support event listeners on child elements of buttons\n          if (/MSIE|Trident/.test(window.navigator.userAgent)) {\n            target = document.elementFromPoint(e.clientX, e.clientY);\n          }\n\n          if (target === clearButton || target.parentElement === clearButton) {\n            e.stopImmediatePropagation();\n            clearSelection(e);\n          }\n        }\n\n        if (!that.$newElement.hasClass(classNames.SHOW)) {\n          that.setSize();\n        }\n      });\n\n      function setFocus () {\n        if (that.options.liveSearch) {\n          that.$searchbox.trigger('focus');\n        } else {\n          that.$menuInner.trigger('focus');\n        }\n      }\n\n      function checkPopperExists () {\n        if (that.dropdown && that.dropdown._popper && that.dropdown._popper.state) {\n          setFocus();\n        } else {\n          requestAnimationFrame(checkPopperExists);\n        }\n      }\n\n      this.$element.on('shown' + EVENT_KEY, function () {\n        if (that.$menuInner[0].scrollTop !== that.selectpicker.view.scrollTop) {\n          that.$menuInner[0].scrollTop = that.selectpicker.view.scrollTop;\n        }\n\n        if (version.major > 3) {\n          requestAnimationFrame(checkPopperExists);\n        } else {\n          setFocus();\n        }\n      });\n\n      // ensure posinset and setsize are correct before selecting an option via a click\n      this.$menuInner.on('mouseenter', 'li a', function (e) {\n        var hoverLi = this.parentElement,\n            position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,\n            index = Array.prototype.indexOf.call(hoverLi.parentElement.children, hoverLi),\n            hoverData = that.selectpicker.current.data[index + position0];\n\n        that.focusItem(hoverLi, hoverData, true);\n      });\n\n      this.$menuInner.on('click', 'li a', function (e, retainActive) {\n        var $this = $(this),\n            element = that.$element[0],\n            position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,\n            clickedData = that.selectpicker.current.data[$this.parent().index() + position0],\n            clickedElement = clickedData.element,\n            prevValue = getSelectValues.call(that),\n            prevIndex = element.selectedIndex,\n            prevOption = element.options[prevIndex],\n            prevData = prevOption ? that.selectpicker.main.data[prevOption.liIndex] : false,\n            triggerChange = true;\n\n        // Don't close on multi choice menu\n        if (that.multiple && that.options.maxOptions !== 1) {\n          e.stopPropagation();\n        }\n\n        e.preventDefault();\n\n        // Don't run if the select is disabled\n        if (!that.isDisabled() && !$this.parent().hasClass(classNames.DISABLED)) {\n          var option = clickedData.option,\n              $option = $(option),\n              state = option.selected,\n              optgroupData = that.selectpicker.current.data.find(function (datum) {\n                return datum.optID === clickedData.optID && datum.type === 'optgroup-label';\n              }),\n              optgroup = optgroupData ? optgroupData.optgroup : undefined,\n              dataGetter = optgroup instanceof Element ? getOptionData.fromOption : getOptionData.fromDataSource,\n              optgroupOptions = optgroup && optgroup.children,\n              maxOptions = parseInt(that.options.maxOptions),\n              maxOptionsGrp = optgroup && parseInt(dataGetter(optgroup, 'maxOptions')) || false;\n\n          if (clickedElement === that.activeElement) retainActive = true;\n\n          if (!retainActive) {\n            that.prevActiveElement = that.activeElement;\n            that.activeElement = undefined;\n          }\n\n          if (!that.multiple || maxOptions === 1) { // Deselect previous option if not multi select\n            if (prevData) that.setSelected(prevData, false);\n            that.setSelected(clickedData, true);\n          } else { // Toggle the clicked option if multi select.\n            that.setSelected(clickedData, !state);\n            that.focusedParent.focus();\n\n            if (maxOptions !== false || maxOptionsGrp !== false) {\n              var maxReached = maxOptions < getSelectedOptions.call(that).length,\n                  selectedGroupOptions = 0;\n\n              if (optgroup && optgroup.children) {\n                for (var i = 0; i < optgroup.children.length; i++) {\n                  if (optgroup.children[i].selected) selectedGroupOptions++;\n                }\n              }\n\n              var maxReachedGrp = maxOptionsGrp < selectedGroupOptions;\n\n              if ((maxOptions && maxReached) || (maxOptionsGrp && maxReachedGrp)) {\n                if (maxOptions && maxOptions === 1) {\n                  element.selectedIndex = -1;\n                  that.setOptionStatus(true);\n                } else if (maxOptionsGrp && maxOptionsGrp === 1) {\n                  for (var i = 0; i < optgroupOptions.length; i++) {\n                    var _option = optgroupOptions[i];\n                    that.setSelected(that.selectpicker.current.data[_option.liIndex], false);\n                  }\n\n                  that.setSelected(clickedData, true);\n                } else {\n                  var maxOptionsText = typeof that.options.maxOptionsText === 'string' ? [that.options.maxOptionsText, that.options.maxOptionsText] : that.options.maxOptionsText,\n                      maxOptionsArr = typeof maxOptionsText === 'function' ? maxOptionsText(maxOptions, maxOptionsGrp) : maxOptionsText,\n                      maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),\n                      maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),\n                      $notify = $('<div class=\"notify\"></div>');\n                  // If {var} is set in array, replace it\n                  /** @deprecated */\n                  if (maxOptionsArr[2]) {\n                    maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);\n                    maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);\n                  }\n\n                  that.$menu.append($notify);\n\n                  if (maxOptions && maxReached) {\n                    $notify.append($('<div>' + maxTxt + '</div>'));\n                    triggerChange = false;\n                    that.$element.trigger('maxReached' + EVENT_KEY);\n                  }\n\n                  if (maxOptionsGrp && maxReachedGrp) {\n                    $notify.append($('<div>' + maxTxtGrp + '</div>'));\n                    triggerChange = false;\n                    that.$element.trigger('maxReachedGrp' + EVENT_KEY);\n                  }\n\n                  setTimeout(function () {\n                    that.setSelected(clickedData, false);\n                  }, 10);\n\n                  $notify[0].classList.add('fadeOut');\n\n                  setTimeout(function () {\n                    $notify.remove();\n                  }, 1050);\n                }\n              }\n            }\n          }\n\n          if (that.options.source.data) that.$element[0].appendChild(that.selectpicker.main.optionQueue);\n\n          if (!that.multiple || (that.multiple && that.options.maxOptions === 1)) {\n            that.$button.trigger('focus');\n          } else if (that.options.liveSearch) {\n            that.$searchbox.trigger('focus');\n          }\n\n          // Trigger select 'change'\n          if (triggerChange) {\n            if (that.multiple || prevIndex !== element.selectedIndex) {\n              // $option.prop('selected') is current option state (selected/unselected). prevValue is the value of the select prior to being changed.\n              changedArguments = [option.index, $option.prop('selected'), prevValue];\n              that.$element\n                .triggerNative('change');\n            }\n          }\n        }\n      });\n\n      this.$menu.on('click', 'li.' + classNames.DISABLED + ' a, .' + classNames.POPOVERHEADER + ', .' + classNames.POPOVERHEADER + ' :not(.close)', function (e) {\n        if (e.currentTarget == this) {\n          e.preventDefault();\n          e.stopPropagation();\n          if (that.options.liveSearch && !$(e.target).hasClass('close')) {\n            that.$searchbox.trigger('focus');\n          } else {\n            that.$button.trigger('focus');\n          }\n        }\n      });\n\n      this.$menuInner.on('click', '.divider, .dropdown-header', function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n        if (that.options.liveSearch) {\n          that.$searchbox.trigger('focus');\n        } else {\n          that.$button.trigger('focus');\n        }\n      });\n\n      this.$menu.on('click', '.' + classNames.POPOVERHEADER + ' .close', function () {\n        that.$button.trigger('click');\n      });\n\n      this.$searchbox.on('click', function (e) {\n        e.stopPropagation();\n      });\n\n      this.$menu.on('click', '.actions-btn', function (e) {\n        if (that.options.liveSearch) {\n          that.$searchbox.trigger('focus');\n        } else {\n          that.$button.trigger('focus');\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n\n        if ($(this).hasClass('bs-select-all')) {\n          that.selectAll();\n        } else {\n          that.deselectAll();\n        }\n      });\n\n      this.$button\n        .on('focus' + EVENT_KEY, function (e) {\n          var tabindex = that.$element[0].getAttribute('tabindex');\n\n          // only change when button is actually focused\n          if (tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {\n            // apply select element's tabindex to ensure correct order is followed when tabbing to the next element\n            this.setAttribute('tabindex', tabindex);\n            // set element's tabindex to -1 to allow for reverse tabbing\n            that.$element[0].setAttribute('tabindex', -1);\n            that.selectpicker.view.tabindex = tabindex;\n          }\n        })\n        .on('blur' + EVENT_KEY, function (e) {\n          // revert everything to original tabindex\n          if (that.selectpicker.view.tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {\n            that.$element[0].setAttribute('tabindex', that.selectpicker.view.tabindex);\n            this.setAttribute('tabindex', -1);\n            that.selectpicker.view.tabindex = undefined;\n          }\n        });\n\n      this.$element\n        .on('change' + EVENT_KEY, function () {\n          that.render();\n          that.$element.trigger('changed' + EVENT_KEY, changedArguments);\n          changedArguments = null;\n        })\n        .on('focus' + EVENT_KEY, function () {\n          if (!that.options.mobile) that.$button[0].focus();\n        });\n    },\n\n    liveSearchListener: function () {\n      var that = this;\n\n      this.$button.on('click.bs.dropdown.data-api', function () {\n        if (!!that.$searchbox.val()) {\n          that.$searchbox.val('');\n          that.selectpicker.search.previousValue = undefined;\n        }\n      });\n\n      this.$searchbox.on('click.bs.dropdown.data-api focus.bs.dropdown.data-api touchend.bs.dropdown.data-api', function (e) {\n        e.stopPropagation();\n      });\n\n      this.$searchbox.on('input propertychange', function () {\n        var searchValue = that.$searchbox[0].value;\n\n        that.selectpicker.search.elements = [];\n        that.selectpicker.search.data = [];\n\n        if (searchValue) {\n          that.selectpicker.search.previousValue = searchValue;\n\n          if (that.options.source.search) {\n            that.fetchData(function (builtData) {\n              that.render();\n              that.buildList(undefined, true);\n              that.noScroll = true;\n              that.$menuInner.scrollTop(0);\n              that.createView(true);\n              showNoResults.call(that, builtData, searchValue);\n            }, 'search', 0, searchValue);\n          } else {\n            var i,\n                searchMatch = [],\n                q = searchValue.toUpperCase(),\n                cache = {},\n                cacheArr = [],\n                searchStyle = that._searchStyle(),\n                normalizeSearch = that.options.liveSearchNormalize;\n\n            if (normalizeSearch) q = normalizeToBase(q);\n\n            for (var i = 0; i < that.selectpicker.main.data.length; i++) {\n              var li = that.selectpicker.main.data[i];\n\n              if (!cache[i]) {\n                cache[i] = stringSearch(li, q, searchStyle, normalizeSearch);\n              }\n\n              if (cache[i] && li.headerIndex !== undefined && cacheArr.indexOf(li.headerIndex) === -1) {\n                if (li.headerIndex > 0) {\n                  cache[li.headerIndex - 1] = true;\n                  cacheArr.push(li.headerIndex - 1);\n                }\n\n                cache[li.headerIndex] = true;\n                cacheArr.push(li.headerIndex);\n\n                cache[li.lastIndex + 1] = true;\n              }\n\n              if (cache[i] && li.type !== 'optgroup-label') cacheArr.push(i);\n            }\n\n            for (var i = 0, cacheLen = cacheArr.length; i < cacheLen; i++) {\n              var index = cacheArr[i],\n                  prevIndex = cacheArr[i - 1],\n                  li = that.selectpicker.main.data[index],\n                  liPrev = that.selectpicker.main.data[prevIndex];\n\n              if (li.type !== 'divider' || (li.type === 'divider' && liPrev && liPrev.type !== 'divider' && cacheLen - 1 !== i)) {\n                that.selectpicker.search.data.push(li);\n                searchMatch.push(that.selectpicker.main.elements[index]);\n              }\n            }\n\n            that.activeElement = undefined;\n            that.noScroll = true;\n            that.$menuInner.scrollTop(0);\n            that.selectpicker.search.elements = searchMatch;\n            that.createView(true);\n            showNoResults.call(that, searchMatch, searchValue);\n          }\n        } else if (that.selectpicker.search.previousValue) { // for IE11 (#2402)\n          that.$menuInner.scrollTop(0);\n          that.createView(false);\n        }\n      });\n    },\n\n    _searchStyle: function () {\n      return this.options.liveSearchStyle || 'contains';\n    },\n\n    val: function (value) {\n      var element = this.$element[0];\n\n      if (typeof value !== 'undefined') {\n        var selectedOptions = getSelectedOptions.call(this),\n            prevValue = getSelectValues.call(this, selectedOptions);\n\n        changedArguments = [null, null, prevValue];\n\n        if (!Array.isArray(value)) value = [ value ];\n\n        value.map(String);\n\n        for (var i = 0; i < selectedOptions.length; i++) {\n          var item = selectedOptions[i];\n\n          if (item && value.indexOf(String(item.value)) === -1) {\n            this.setSelected(item, false);\n          }\n        }\n\n        // only update selected value if it matches an existing option\n        this.selectpicker.main.data.filter(function (item) {\n          if (value.indexOf(String(item.value)) !== -1) {\n            this.setSelected(item, true);\n            return true;\n          }\n\n          return false;\n        }, this);\n\n        if (this.options.source.data) element.appendChild(this.selectpicker.main.optionQueue);\n\n        this.$element.trigger('changed' + EVENT_KEY, changedArguments);\n\n        if (this.$newElement.hasClass(classNames.SHOW)) {\n          if (this.multiple) {\n            this.setOptionStatus(true);\n          } else {\n            var liSelectedIndex = (element.options[element.selectedIndex] || {}).liIndex;\n\n            if (typeof liSelectedIndex === 'number') {\n              this.setSelected(this.selectpicker.current.data[liSelectedIndex], true);\n            }\n          }\n        }\n\n        this.render();\n\n        changedArguments = null;\n\n        return this.$element;\n      } else {\n        return this.$element.val();\n      }\n    },\n\n    changeAll: function (status) {\n      if (!this.multiple) return;\n      if (typeof status === 'undefined') status = true;\n\n      var element = this.$element[0],\n          previousSelected = 0,\n          currentSelected = 0,\n          prevValue = getSelectValues.call(this);\n\n      element.classList.add('bs-select-hidden');\n\n      for (var i = 0, data = this.selectpicker.current.data, len = data.length; i < len; i++) {\n        var liData = data[i],\n            option = liData.option;\n\n        if (option && !liData.disabled && liData.type !== 'divider') {\n          if (liData.selected) previousSelected++;\n          option.selected = status;\n          liData.selected = status;\n          if (status === true) currentSelected++;\n        }\n      }\n\n      element.classList.remove('bs-select-hidden');\n\n      if (previousSelected === currentSelected) return;\n\n      this.setOptionStatus();\n\n      changedArguments = [null, null, prevValue];\n\n      this.$element\n        .triggerNative('change');\n    },\n\n    selectAll: function () {\n      return this.changeAll(true);\n    },\n\n    deselectAll: function () {\n      return this.changeAll(false);\n    },\n\n    toggle: function (e, state) {\n      var isActive,\n          triggerClick = state === undefined;\n\n      e = e || window.event;\n\n      if (e) e.stopPropagation();\n\n      if (triggerClick === false) {\n        isActive = this.$newElement[0].classList.contains(classNames.SHOW);\n        triggerClick = state === true && isActive === false || state === false && isActive === true;\n      }\n\n      if (triggerClick) this.$button.trigger('click.bs.dropdown.data-api');\n    },\n\n    open: function (e) {\n      this.toggle(e, true);\n    },\n\n    close: function (e) {\n      this.toggle(e, false);\n    },\n\n    keydown: function (e) {\n      var $this = $(this),\n          isToggle = $this.hasClass('dropdown-toggle'),\n          $parent = isToggle ? $this.closest('.dropdown') : $this.closest(Selector.MENU),\n          that = $parent.data('this'),\n          $items = that.findLis(),\n          index,\n          isActive,\n          liActive,\n          activeLi,\n          offset,\n          updateScroll = false,\n          downOnTab = e.which === keyCodes.TAB && !isToggle && !that.options.selectOnTab,\n          isArrowKey = REGEXP_ARROW.test(e.which) || downOnTab,\n          scrollTop = that.$menuInner[0].scrollTop,\n          isVirtual = that.isVirtual(),\n          position0 = isVirtual === true ? that.selectpicker.view.position0 : 0;\n\n      // do nothing if a function key is pressed\n      if (e.which >= 112 && e.which <= 123) return;\n\n      isActive = that.$menu.hasClass(classNames.SHOW);\n\n      if (\n        !isActive &&\n        (\n          isArrowKey ||\n          (e.which >= 48 && e.which <= 57) ||\n          (e.which >= 96 && e.which <= 105) ||\n          (e.which >= 65 && e.which <= 90)\n        )\n      ) {\n        that.$button.trigger('click.bs.dropdown.data-api');\n\n        if (that.options.liveSearch) {\n          that.$searchbox.trigger('focus');\n          return;\n        }\n      }\n\n      if (e.which === keyCodes.ESCAPE && isActive) {\n        e.preventDefault();\n        that.$button.trigger('click.bs.dropdown.data-api').trigger('focus');\n      }\n\n      if (isArrowKey) { // if up or down\n        if (!$items.length) return;\n\n        liActive = that.activeElement;\n        index = liActive ? Array.prototype.indexOf.call(liActive.parentElement.children, liActive) : -1;\n\n        if (index !== -1) {\n          that.defocusItem(liActive);\n        }\n\n        if (e.which === keyCodes.ARROW_UP) { // up\n          if (index !== -1) index--;\n          if (index + position0 < 0) index += $items.length;\n\n          if (!that.selectpicker.view.canHighlight[index + position0]) {\n            index = that.selectpicker.view.canHighlight.slice(0, index + position0).lastIndexOf(true) - position0;\n            if (index === -1) index = $items.length - 1;\n          }\n        } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) { // down\n          index++;\n          if (index + position0 >= that.selectpicker.view.canHighlight.length) index = that.selectpicker.view.firstHighlightIndex;\n\n          if (!that.selectpicker.view.canHighlight[index + position0]) {\n            index = index + 1 + that.selectpicker.view.canHighlight.slice(index + position0 + 1).indexOf(true);\n          }\n        }\n\n        e.preventDefault();\n\n        var liActiveIndex = position0 + index;\n\n        if (e.which === keyCodes.ARROW_UP) { // up\n          // scroll to bottom and highlight last option\n          if (position0 === 0 && index === $items.length - 1) {\n            that.$menuInner[0].scrollTop = that.$menuInner[0].scrollHeight;\n\n            liActiveIndex = that.selectpicker.current.elements.length - 1;\n          } else {\n            activeLi = that.selectpicker.current.data[liActiveIndex];\n\n            // could be undefined if no results exist\n            if (activeLi) {\n              offset = activeLi.position - activeLi.height;\n\n              updateScroll = offset < scrollTop;\n            }\n          }\n        } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) { // down\n          // scroll to top and highlight first option\n          if (index === that.selectpicker.view.firstHighlightIndex) {\n            that.$menuInner[0].scrollTop = 0;\n\n            liActiveIndex = that.selectpicker.view.firstHighlightIndex;\n          } else {\n            activeLi = that.selectpicker.current.data[liActiveIndex];\n\n            // could be undefined if no results exist\n            if (activeLi) {\n              offset = activeLi.position - that.sizeInfo.menuInnerHeight;\n\n              updateScroll = offset > scrollTop;\n            }\n          }\n        }\n\n        liActive = that.selectpicker.current.elements[liActiveIndex];\n\n        that.activeElement = (that.selectpicker.current.data[liActiveIndex] || {}).element;\n\n        that.focusItem(liActive);\n\n        that.selectpicker.view.currentActive = liActive;\n\n        if (updateScroll) that.$menuInner[0].scrollTop = offset;\n\n        if (that.options.liveSearch) {\n          that.$searchbox.trigger('focus');\n        } else {\n          $this.trigger('focus');\n        }\n      } else if (\n        (!$this.is('input') && !REGEXP_TAB_OR_ESCAPE.test(e.which)) ||\n        (e.which === keyCodes.SPACE && that.selectpicker.keydown.keyHistory)\n      ) {\n        var searchMatch,\n            matches = [],\n            keyHistory;\n\n        e.preventDefault();\n\n        that.selectpicker.keydown.keyHistory += keyCodeMap[e.which];\n\n        if (that.selectpicker.keydown.resetKeyHistory.cancel) clearTimeout(that.selectpicker.keydown.resetKeyHistory.cancel);\n        that.selectpicker.keydown.resetKeyHistory.cancel = that.selectpicker.keydown.resetKeyHistory.start();\n\n        keyHistory = that.selectpicker.keydown.keyHistory;\n\n        // if all letters are the same, set keyHistory to just the first character when searching\n        if (/^(.)\\1+$/.test(keyHistory)) {\n          keyHistory = keyHistory.charAt(0);\n        }\n\n        // find matches\n        for (var i = 0; i < that.selectpicker.current.data.length; i++) {\n          var li = that.selectpicker.current.data[i],\n              hasMatch;\n\n          hasMatch = stringSearch(li, keyHistory, 'startsWith', true);\n\n          if (hasMatch && that.selectpicker.view.canHighlight[i]) {\n            matches.push(li.element);\n          }\n        }\n\n        if (matches.length) {\n          var matchIndex = 0;\n\n          $items.removeClass('active').find('a').removeClass('active');\n\n          // either only one key has been pressed or they are all the same key\n          if (keyHistory.length === 1) {\n            matchIndex = matches.indexOf(that.activeElement);\n\n            if (matchIndex === -1 || matchIndex === matches.length - 1) {\n              matchIndex = 0;\n            } else {\n              matchIndex++;\n            }\n          }\n\n          searchMatch = matches[matchIndex];\n\n          activeLi = that.selectpicker.main.data[searchMatch];\n\n          if (scrollTop - activeLi.position > 0) {\n            offset = activeLi.position - activeLi.height;\n            updateScroll = true;\n          } else {\n            offset = activeLi.position - that.sizeInfo.menuInnerHeight;\n            // if the option is already visible at the current scroll position, just keep it the same\n            updateScroll = activeLi.position > scrollTop + that.sizeInfo.menuInnerHeight;\n          }\n\n          liActive = that.selectpicker.main.elements[searchMatch];\n\n          that.activeElement = liActive;\n\n          that.focusItem(liActive);\n\n          if (liActive) liActive.firstChild.focus();\n\n          if (updateScroll) that.$menuInner[0].scrollTop = offset;\n\n          $this.trigger('focus');\n        }\n      }\n\n      // Select focused option if \"Enter\", \"Spacebar\" or \"Tab\" (when selectOnTab is true) are pressed inside the menu.\n      if (\n        isActive &&\n        (\n          (e.which === keyCodes.SPACE && !that.selectpicker.keydown.keyHistory) ||\n          e.which === keyCodes.ENTER ||\n          (e.which === keyCodes.TAB && that.options.selectOnTab)\n        )\n      ) {\n        if (e.which !== keyCodes.SPACE) e.preventDefault();\n\n        if (!that.options.liveSearch || e.which !== keyCodes.SPACE) {\n          that.$menuInner.find('.active a').trigger('click', true); // retain active class\n          $this.trigger('focus');\n\n          if (!that.options.liveSearch) {\n            // Prevent screen from scrolling if the user hits the spacebar\n            e.preventDefault();\n            // Fixes spacebar selection of dropdown items in FF & IE\n            $(document).data('spaceSelect', true);\n          }\n        }\n      }\n    },\n\n    mobile: function () {\n      // ensure mobile is set to true if mobile function is called after init\n      this.options.mobile = true;\n      this.$element[0].classList.add('mobile-device');\n    },\n\n    refresh: function () {\n      var that = this;\n      // update options if data attributes have been changed\n      var config = $.extend({}, this.options, getAttributesObject(this.$element), this.$element.data()); // in this order on refresh, as user may change attributes on select, and options object is not passed on refresh\n      this.options = config;\n\n      if (this.options.source.data) {\n        this.render();\n        this.buildList();\n      } else {\n        this.fetchData(function () {\n          that.render();\n          that.buildList();\n        });\n      }\n\n      this.checkDisabled();\n      this.setStyle();\n      this.setWidth();\n\n      this.setSize(true);\n\n      this.$element.trigger('refreshed' + EVENT_KEY);\n    },\n\n    hide: function () {\n      this.$newElement.hide();\n    },\n\n    show: function () {\n      this.$newElement.show();\n    },\n\n    remove: function () {\n      this.$newElement.remove();\n      this.$element.remove();\n    },\n\n    destroy: function () {\n      this.$newElement.before(this.$element).remove();\n\n      if (this.$bsContainer) {\n        this.$bsContainer.remove();\n      } else {\n        this.$menu.remove();\n      }\n\n      if (this.selectpicker.view.titleOption && this.selectpicker.view.titleOption.parentNode) {\n        this.selectpicker.view.titleOption.parentNode.removeChild(this.selectpicker.view.titleOption);\n      }\n\n      this.$element\n        .off(EVENT_KEY)\n        .removeData('selectpicker')\n        .removeClass('bs-select-hidden selectpicker mobile-device');\n\n      $(window).off(EVENT_KEY + '.' + this.selectId);\n    }\n  };\n\n  // SELECTPICKER PLUGIN DEFINITION\n  // ==============================\n  function Plugin (option) {\n    // get the args of the outer function..\n    var args = arguments;\n    // The arguments of the function are explicitly re-defined from the argument list, because the shift causes them\n    // to get lost/corrupted in android 2.3 and IE9 #715 #775\n    var _option = option;\n\n    [].shift.apply(args);\n\n    // if the version was not set successfully\n    if (!version.success) {\n      // try to retreive it again\n      try {\n        version.full = (getVersion() || '').split(' ')[0].split('.');\n      } catch (err) {\n        // fall back to use BootstrapVersion if set\n        if (Selectpicker.BootstrapVersion) {\n          version.full = Selectpicker.BootstrapVersion.split(' ')[0].split('.');\n        } else {\n          version.full = [version.major, '0', '0'];\n\n          console.warn(\n            'There was an issue retrieving Bootstrap\\'s version. ' +\n            'Ensure Bootstrap is being loaded before bootstrap-select and there is no namespace collision. ' +\n            'If loading Bootstrap asynchronously, the version may need to be manually specified via $.fn.selectpicker.Constructor.BootstrapVersion.',\n            err\n          );\n        }\n      }\n\n      version.major = version.full[0];\n      version.success = true;\n    }\n\n    if (version.major >= '4') {\n      // some defaults need to be changed if using Bootstrap 4\n      // check to see if they have already been manually changed before forcing them to update\n      var toUpdate = [];\n\n      if (Selectpicker.DEFAULTS.style === classNames.BUTTONCLASS) toUpdate.push({ name: 'style', className: 'BUTTONCLASS' });\n      if (Selectpicker.DEFAULTS.iconBase === classNames.ICONBASE) toUpdate.push({ name: 'iconBase', className: 'ICONBASE' });\n      if (Selectpicker.DEFAULTS.tickIcon === classNames.TICKICON) toUpdate.push({ name: 'tickIcon', className: 'TICKICON' });\n\n      classNames.DIVIDER = 'dropdown-divider';\n      classNames.SHOW = 'show';\n      classNames.BUTTONCLASS = 'btn-light';\n      classNames.POPOVERHEADER = 'popover-header';\n      classNames.ICONBASE = '';\n      classNames.TICKICON = 'bs-ok-default';\n\n      for (var i = 0; i < toUpdate.length; i++) {\n        var option = toUpdate[i];\n        Selectpicker.DEFAULTS[option.name] = classNames[option.className];\n      }\n    }\n\n    if (version.major > '4') {\n      Selector.DATA_TOGGLE = 'data-bs-toggle=\"dropdown\"';\n    }\n\n    var value;\n    var chain = this.each(function () {\n      var $this = $(this);\n      if ($this.is('select')) {\n        var data = $this.data('selectpicker'),\n            options = typeof _option == 'object' && _option;\n\n        // for backwards compatibility\n        // (using title as placeholder is deprecated - remove in v2.0.0)\n        if (options.title) options.placeholder = options.title;\n\n        if (!data) {\n          var dataAttributes = $this.data();\n\n          for (var dataAttr in dataAttributes) {\n            if (Object.prototype.hasOwnProperty.call(dataAttributes, dataAttr) && $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) !== -1) {\n              delete dataAttributes[dataAttr];\n            }\n          }\n\n          var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, getAttributesObject($this), dataAttributes, options); // this is correct order on initial render\n          config.template = $.extend({}, Selectpicker.DEFAULTS.template, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}), dataAttributes.template, options.template);\n          config.source = $.extend({}, Selectpicker.DEFAULTS.source, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.source : {}), options.source);\n          $this.data('selectpicker', (data = new Selectpicker(this, config)));\n        } else if (options) {\n          for (var i in options) {\n            if (Object.prototype.hasOwnProperty.call(options, i)) {\n              data.options[i] = options[i];\n            }\n          }\n        }\n\n        if (typeof _option == 'string') {\n          if (data[_option] instanceof Function) {\n            value = data[_option].apply(data, args);\n          } else {\n            value = data.options[_option];\n          }\n        }\n      }\n    });\n\n    if (typeof value !== 'undefined') {\n      // noinspection JSUnusedAssignment\n      return value;\n    } else {\n      return chain;\n    }\n  }\n\n  var old = $.fn.selectpicker;\n  $.fn.selectpicker = Plugin;\n  $.fn.selectpicker.Constructor = Selectpicker;\n\n  // SELECTPICKER NO CONFLICT\n  // ========================\n  $.fn.selectpicker.noConflict = function () {\n    $.fn.selectpicker = old;\n    return this;\n  };\n\n  // get Bootstrap's keydown event handler for either Bootstrap 4 or Bootstrap 3\n  function keydownHandler () {\n    if (version.major < 5) {\n      if ($.fn.dropdown) {\n        // wait to define until function is called in case Bootstrap isn't loaded yet\n        var bootstrapKeydown = $.fn.dropdown.Constructor._dataApiKeydownHandler || $.fn.dropdown.Constructor.prototype.keydown;\n        return bootstrapKeydown.apply(this, arguments);\n      }\n    } else {\n      return Dropdown.dataApiKeydownHandler;\n    }\n  }\n\n  $(document)\n    .off('keydown.bs.dropdown.data-api')\n    .on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > [' + Selector.DATA_TOGGLE + ']', keydownHandler)\n    .on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > .dropdown-menu', keydownHandler)\n    .on('keydown' + EVENT_KEY, '.bootstrap-select [' + Selector.DATA_TOGGLE + '], .bootstrap-select [role=\"listbox\"], .bootstrap-select .bs-searchbox input', Selectpicker.prototype.keydown)\n    .on('focusin.modal', '.bootstrap-select [' + Selector.DATA_TOGGLE + '], .bootstrap-select [role=\"listbox\"], .bootstrap-select .bs-searchbox input', function (e) {\n      e.stopPropagation();\n    });\n\n  // SELECTPICKER DATA-API\n  // =====================\n  document.addEventListener('DOMContentLoaded', function () {\n    $('.selectpicker').each(function () {\n      var $selectpicker = $(this);\n      Plugin.call($selectpicker, $selectpicker.data());\n    });\n  });\n})(jQuery);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLXNlbGVjdC9qcy9ib290c3RyYXAtc2VsZWN0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJOztBQUV2SSxzREFBc0Q7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaURBQWlELFNBQVM7QUFDMUQ7O0FBRUEsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBcUQsVUFBVTtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvRkFBb0YsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBLG9DQUFvQyxHQUFHLG1CQUFtQixHQUFHO0FBQzdELEtBQUs7QUFDTDtBQUNBO0FBQ0EseUNBQXlDLEdBQUcsOEJBQThCLEdBQUc7QUFDN0UsaURBQWlELEdBQUcsb0NBQW9DLEdBQUc7QUFDM0Y7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4SEFBOEg7QUFDOUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDJDQUEyQztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0Q0FBNEM7QUFDNUMsdURBQXVEOztBQUV2RCx3QkFBd0IsZ0JBQWdCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0VBQWtFLHdCQUF3QjtBQUMxRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkVBQTJFOztBQUUzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7O0FBRUEsMkRBQTJELFNBQVM7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdEQUF3RCxTQUFTO0FBQ2pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQsZ0NBQWdDO0FBQ3pGLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxFQUFFLHVDQUF1QyxFQUFFO0FBQ2hGLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLDJDQUEyQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUJBQXlCO0FBQ3pCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLCtCQUErQjtBQUMvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLG1EQUFtRDtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtDQUFrQyw0QkFBNEI7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSwwREFBMEQsRUFBRTtBQUM1RCw2REFBNkQsRUFBRTtBQUMvRDtBQUNBLHlCQUF5QixLQUFLO0FBQzlCO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRCxvREFBb0QsSUFBSTtBQUN4RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLHdDQUF3QztBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3REFBd0QsY0FBYztBQUN0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtREFBbUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLDRCQUE0QjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwrRUFBK0U7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdGQUFnRixTQUFTO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlEQUF5RDtBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseURBQXlEO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUZBQWlGOztBQUVqRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsMkNBQTJDO0FBQ25FO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJFQUEyRTtBQUN6Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0ZBQWtGLHlDQUF5QztBQUMzSCxrRkFBa0YseUNBQXlDO0FBQzNILGtGQUFrRix5Q0FBeUM7O0FBRTNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MseURBQXlELHdEQUF3RDtBQUNuSix1Q0FBdUMsd0dBQXdHO0FBQy9JLHFDQUFxQyxvR0FBb0c7QUFDekk7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVzdC8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAtc2VsZWN0L2pzL2Jvb3RzdHJhcC1zZWxlY3QuanM/NzViNyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBESVNBTExPV0VEX0FUVFJJQlVURVMgPSBbJ3Nhbml0aXplJywgJ3doaXRlTGlzdCcsICdzYW5pdGl6ZUZuJ107XG5cbiAgdmFyIHVyaUF0dHJzID0gW1xuICAgICdiYWNrZ3JvdW5kJyxcbiAgICAnY2l0ZScsXG4gICAgJ2hyZWYnLFxuICAgICdpdGVtdHlwZScsXG4gICAgJ2xvbmdkZXNjJyxcbiAgICAncG9zdGVyJyxcbiAgICAnc3JjJyxcbiAgICAneGxpbms6aHJlZidcbiAgXTtcblxuICB2YXIgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFx3LV0qJC9pO1xuXG4gIHZhciBEZWZhdWx0V2hpdGVsaXN0ID0ge1xuICAgIC8vIEdsb2JhbCBhdHRyaWJ1dGVzIGFsbG93ZWQgb24gYW55IHN1cHBsaWVkIGVsZW1lbnQgYmVsb3cuXG4gICAgJyonOiBbJ2NsYXNzJywgJ2RpcicsICdpZCcsICdsYW5nJywgJ3JvbGUnLCAndGFiaW5kZXgnLCAnc3R5bGUnLCBBUklBX0FUVFJJQlVURV9QQVRURVJOXSxcbiAgICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxuICAgIGFyZWE6IFtdLFxuICAgIGI6IFtdLFxuICAgIGJyOiBbXSxcbiAgICBjb2w6IFtdLFxuICAgIGNvZGU6IFtdLFxuICAgIGRpdjogW10sXG4gICAgZW06IFtdLFxuICAgIGhyOiBbXSxcbiAgICBoMTogW10sXG4gICAgaDI6IFtdLFxuICAgIGgzOiBbXSxcbiAgICBoNDogW10sXG4gICAgaDU6IFtdLFxuICAgIGg2OiBbXSxcbiAgICBpOiBbXSxcbiAgICBpbWc6IFsnc3JjJywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnXSxcbiAgICBsaTogW10sXG4gICAgb2w6IFtdLFxuICAgIHA6IFtdLFxuICAgIHByZTogW10sXG4gICAgczogW10sXG4gICAgc21hbGw6IFtdLFxuICAgIHNwYW46IFtdLFxuICAgIHN1YjogW10sXG4gICAgc3VwOiBbXSxcbiAgICBzdHJvbmc6IFtdLFxuICAgIHU6IFtdLFxuICAgIHVsOiBbXVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIGEgY29tbW9ubHkgdXNlZnVsIHN1YnNldCBvZiBVUkxzIHRoYXQgYXJlIHNhZmUuXG4gICAqXG4gICAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgNyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNy4yLjQvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcbiAgICovXG4gIHZhciBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZSk6fFteJjovPyNdKig/OlsvPyNdfCQpKS9naTtcblxuICAvKipcbiAgICogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuXG4gICAqXG4gICAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgNyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNy4yLjQvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcbiAgICovXG4gIHZhciBEQVRBX1VSTF9QQVRURVJOID0gL15kYXRhOig/OmltYWdlXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW2EtejAtOSsvXSs9KiQvaTtcblxuICB2YXIgUGFyc2VhYmxlQXR0cmlidXRlcyA9IFsndGl0bGUnLCAncGxhY2Vob2xkZXInXTsgLy8gYXR0cmlidXRlcyB0byB1c2UgYXMgc2V0dGluZ3MsIGNhbiBhZGQgb3RoZXJzIGluIHRoZSBmdXR1cmVcblxuICBmdW5jdGlvbiBhbGxvd2VkQXR0cmlidXRlIChhdHRyLCBhbGxvd2VkQXR0cmlidXRlTGlzdCkge1xuICAgIHZhciBhdHRyTmFtZSA9IGF0dHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICgkLmluQXJyYXkoYXR0ck5hbWUsIGFsbG93ZWRBdHRyaWJ1dGVMaXN0KSAhPT0gLTEpIHtcbiAgICAgIGlmICgkLmluQXJyYXkoYXR0ck5hbWUsIHVyaUF0dHJzKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oYXR0ci5ub2RlVmFsdWUubWF0Y2goU0FGRV9VUkxfUEFUVEVSTikgfHwgYXR0ci5ub2RlVmFsdWUubWF0Y2goREFUQV9VUkxfUEFUVEVSTikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcmVnRXhwID0gJChhbGxvd2VkQXR0cmlidXRlTGlzdCkuZmlsdGVyKGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICB9KTtcblxuICAgIC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVnRXhwLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGF0dHJOYW1lLm1hdGNoKHJlZ0V4cFtpXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2FuaXRpemVIdG1sICh1bnNhZmVFbGVtZW50cywgd2hpdGVMaXN0LCBzYW5pdGl6ZUZuKSB7XG4gICAgaWYgKHNhbml0aXplRm4gJiYgdHlwZW9mIHNhbml0aXplRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBzYW5pdGl6ZUZuKHVuc2FmZUVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgd2hpdGVsaXN0S2V5cyA9IE9iamVjdC5rZXlzKHdoaXRlTGlzdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdW5zYWZlRWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IHVuc2FmZUVsZW1lbnRzW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbjIgPSBlbGVtZW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgdmFyIGVsID0gZWxlbWVudHNbal07XG4gICAgICAgIHZhciBlbE5hbWUgPSBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmICh3aGl0ZWxpc3RLZXlzLmluZGV4T2YoZWxOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZUxpc3QgPSBbXS5zbGljZS5jYWxsKGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgICB2YXIgd2hpdGVsaXN0ZWRBdHRyaWJ1dGVzID0gW10uY29uY2F0KHdoaXRlTGlzdFsnKiddIHx8IFtdLCB3aGl0ZUxpc3RbZWxOYW1lXSB8fCBbXSk7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDAsIGxlbjMgPSBhdHRyaWJ1dGVMaXN0Lmxlbmd0aDsgayA8IGxlbjM7IGsrKykge1xuICAgICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlTGlzdFtrXTtcblxuICAgICAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZShhdHRyLCB3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlc09iamVjdCAoJHNlbGVjdCkge1xuICAgIHZhciBhdHRyaWJ1dGVzT2JqZWN0ID0ge30sXG4gICAgICAgIGF0dHJWYWw7XG5cbiAgICBQYXJzZWFibGVBdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGF0dHJWYWwgPSAkc2VsZWN0LmF0dHIoaXRlbSk7XG4gICAgICBpZiAoYXR0clZhbCkgYXR0cmlidXRlc09iamVjdFtpdGVtXSA9IGF0dHJWYWw7XG4gICAgfSk7XG5cbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAvLyAodXNpbmcgdGl0bGUgYXMgcGxhY2Vob2xkZXIgaXMgZGVwcmVjYXRlZCAtIHJlbW92ZSBpbiB2Mi4wLjApXG4gICAgaWYgKCFhdHRyaWJ1dGVzT2JqZWN0LnBsYWNlaG9sZGVyICYmIGF0dHJpYnV0ZXNPYmplY3QudGl0bGUpIHtcbiAgICAgIGF0dHJpYnV0ZXNPYmplY3QucGxhY2Vob2xkZXIgPSBhdHRyaWJ1dGVzT2JqZWN0LnRpdGxlO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRyaWJ1dGVzT2JqZWN0O1xuICB9XG5cbiAgLy8gUG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGggbm8gY2xhc3NMaXN0IHN1cHBvcnRcbiAgLy8gUmVtb3ZlIGluIHYyXG4gIGlmICghKCdjbGFzc0xpc3QnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ18nKSkpIHtcbiAgICAoZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgIGlmICghKCdFbGVtZW50JyBpbiB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICB2YXIgY2xhc3NMaXN0UHJvcCA9ICdjbGFzc0xpc3QnLFxuICAgICAgICAgIHByb3RvUHJvcCA9ICdwcm90b3R5cGUnLFxuICAgICAgICAgIGVsZW1DdHJQcm90byA9IHZpZXcuRWxlbWVudFtwcm90b1Byb3BdLFxuICAgICAgICAgIG9iakN0ciA9IE9iamVjdCxcbiAgICAgICAgICBjbGFzc0xpc3RHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIChjbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpO1xuICAgICAgICAgICAgICAgIHJldHVybiAkZWxlbS5hZGRDbGFzcyhjbGFzc2VzKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGVsZW0ucmVtb3ZlQ2xhc3MoY2xhc3Nlcyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gKGNsYXNzZXMsIGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRlbGVtLnRvZ2dsZUNsYXNzKGNsYXNzZXMsIGZvcmNlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uIChjbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRlbGVtLmhhc0NsYXNzKGNsYXNzZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgIGlmIChvYmpDdHIuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIGNsYXNzTGlzdFByb3BEZXNjID0ge1xuICAgICAgICAgIGdldDogY2xhc3NMaXN0R2V0dGVyLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xuICAgICAgICB9IGNhdGNoIChleCkgeyAvLyBJRSA4IGRvZXNuJ3Qgc3VwcG9ydCBlbnVtZXJhYmxlOnRydWVcbiAgICAgICAgICAvLyBhZGRpbmcgdW5kZWZpbmVkIHRvIGZpZ2h0IHRoaXMgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvY2xhc3NMaXN0LmpzL2lzc3Vlcy8zNlxuICAgICAgICAgIC8vIG1vZGVybmllIElFOC1NU1c3IG1hY2hpbmUgaGFzIElFOCA4LjAuNjAwMS4xODcwMiBhbmQgaXMgYWZmZWN0ZWRcbiAgICAgICAgICBpZiAoZXgubnVtYmVyID09PSB1bmRlZmluZWQgfHwgZXgubnVtYmVyID09PSAtMHg3RkY1RUM1NCkge1xuICAgICAgICAgICAgY2xhc3NMaXN0UHJvcERlc2MuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvYmpDdHJbcHJvdG9Qcm9wXS5fX2RlZmluZUdldHRlcl9fKSB7XG4gICAgICAgIGVsZW1DdHJQcm90by5fX2RlZmluZUdldHRlcl9fKGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdEdldHRlcik7XG4gICAgICB9XG4gICAgfSh3aW5kb3cpKTtcbiAgfVxuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ18nKTtcblxuICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjMScsICdjMicpO1xuXG4gIGlmICghdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdjMicpKSB7XG4gICAgdmFyIF9hZGQgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLmFkZCxcbiAgICAgICAgX3JlbW92ZSA9IERPTVRva2VuTGlzdC5wcm90b3R5cGUucmVtb3ZlO1xuXG4gICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgX2FkZC5iaW5kKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgX3JlbW92ZS5iaW5kKHRoaXMpKTtcbiAgICB9O1xuICB9XG5cbiAgdGVzdEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSgnYzMnLCBmYWxzZSk7XG5cbiAgLy8gUG9seWZpbGwgZm9yIElFIDEwIGFuZCBGaXJlZm94IDwyNCwgd2hlcmUgY2xhc3NMaXN0LnRvZ2dsZSBkb2VzIG5vdFxuICAvLyBzdXBwb3J0IHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gIGlmICh0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2MzJykpIHtcbiAgICB2YXIgX3RvZ2dsZSA9IERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlO1xuXG4gICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAodG9rZW4sIGZvcmNlKSB7XG4gICAgICBpZiAoMSBpbiBhcmd1bWVudHMgJiYgIXRoaXMuY29udGFpbnModG9rZW4pID09PSAhZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF90b2dnbGUuY2FsbCh0aGlzLCB0b2tlbik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcblxuICAvLyBQb2x5ZmlsbCBmb3IgSUUgKHJlbW92ZSBpbiB2MilcbiAgT2JqZWN0LnZhbHVlcyA9IHR5cGVvZiBPYmplY3QudmFsdWVzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LnZhbHVlcyA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIHNoYWxsb3cgYXJyYXkgY29tcGFyaXNvblxuICBmdW5jdGlvbiBpc0VxdWFsIChhcnJheTEsIGFycmF5Mikge1xuICAgIHJldHVybiBhcnJheTEubGVuZ3RoID09PSBhcnJheTIubGVuZ3RoICYmIGFycmF5MS5ldmVyeShmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBlbGVtZW50ID09PSBhcnJheTJbaW5kZXhdO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIDxlZGl0b3ItZm9sZCBkZXNjPVwiU2hpbXNcIj5cbiAgaWYgKCFTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgJ3VzZSBzdHJpY3QnOyAvLyBuZWVkZWQgdG8gc3VwcG9ydCBgYXBwbHlgL2BjYWxsYCB3aXRoIGB1bmRlZmluZWRgL2BudWxsYFxuICAgICAgdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG4gICAgICB2YXIgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzZWFyY2gpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgICBpZiAoc2VhcmNoICYmIHRvU3RyaW5nLmNhbGwoc2VhcmNoKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgdmFyIHNlYXJjaFN0cmluZyA9IFN0cmluZyhzZWFyY2gpO1xuICAgICAgICB2YXIgc2VhcmNoTGVuZ3RoID0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGBUb0ludGVnZXJgXG4gICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbiA/IE51bWJlcihwb3NpdGlvbikgOiAwO1xuICAgICAgICBpZiAocG9zICE9IHBvcykgeyAvLyBiZXR0ZXIgYGlzTmFOYFxuICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5taW4oTWF0aC5tYXgocG9zLCAwKSwgc3RyaW5nTGVuZ3RoKTtcbiAgICAgICAgLy8gQXZvaWQgdGhlIGBpbmRleE9mYCBjYWxsIGlmIG5vIG1hdGNoIGlzIHBvc3NpYmxlXG4gICAgICAgIGlmIChzZWFyY2hMZW5ndGggKyBzdGFydCA+IHN0cmluZ0xlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzZWFyY2hMZW5ndGgpIHtcbiAgICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoc3RhcnQgKyBpbmRleCkgIT0gc2VhcmNoU3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdzdGFydHNXaXRoJywge1xuICAgICAgICAgICd2YWx1ZSc6IHN0YXJ0c1dpdGgsXG4gICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG4gICAgICB9XG4gICAgfSgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvS2ViYWJDYXNlIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tBLVpdKyg/IVthLXpdKXxbQS1aXS9nLCBmdW5jdGlvbiAoJCwgb2ZzKSB7XG4gICAgICByZXR1cm4gKG9mcyA/ICctJyA6ICcnKSArICQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlbGVjdGVkT3B0aW9ucyAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLnNlbGVjdHBpY2tlci5tYWluLmRhdGE7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZS5kYXRhIHx8IHRoaXMub3B0aW9ucy5zb3VyY2Uuc2VhcmNoKSB7XG4gICAgICBvcHRpb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLnNlbGVjdHBpY2tlci5vcHRpb25WYWx1ZXNEYXRhTWFwKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ZWRPcHRpb25zID0gb3B0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtLnNlbGVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlkZURpc2FibGVkICYmIGl0ZW0uZGlzYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIGVuc3VyZSBvbmx5IDEgb3B0aW9uIGlzIHNlbGVjdGVkIGlmIG11bHRpcGxlIGFyZSBzZXQgaW4gdGhlIGRhdGEgc291cmNlXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2UuZGF0YSAmJiAhdGhpcy5tdWx0aXBsZSAmJiBzZWxlY3RlZE9wdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZE9wdGlvbnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHNlbGVjdGVkT3B0aW9uc1tpXS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RlZE9wdGlvbnMgPSBbIHNlbGVjdGVkT3B0aW9uc1tzZWxlY3RlZE9wdGlvbnMubGVuZ3RoIC0gMV0gXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0ZWRPcHRpb25zO1xuICB9XG5cbiAgLy8gbXVjaCBmYXN0ZXIgdGhhbiAkLnZhbCgpXG4gIGZ1bmN0aW9uIGdldFNlbGVjdFZhbHVlcyAoc2VsZWN0ZWRPcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gW10sXG4gICAgICAgIG9wdGlvbnMgPSBzZWxlY3RlZE9wdGlvbnMgfHwgZ2V0U2VsZWN0ZWRPcHRpb25zLmNhbGwodGhpcyksXG4gICAgICAgIG9wdDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcHRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvcHQgPSBvcHRpb25zW2ldO1xuXG4gICAgICBpZiAoIW9wdC5kaXNhYmxlZCkge1xuICAgICAgICB2YWx1ZS5wdXNoKG9wdC52YWx1ZSA9PT0gdW5kZWZpbmVkID8gb3B0LnRleHQgOiBvcHQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5tdWx0aXBsZSkge1xuICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGggPyBudWxsIDogdmFsdWVbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gc2V0IGRhdGEtc2VsZWN0ZWQgb24gc2VsZWN0IGVsZW1lbnQgaWYgdGhlIHZhbHVlIGhhcyBiZWVuIHByb2dyYW1tYXRpY2FsbHkgc2VsZWN0ZWRcbiAgLy8gcHJpb3IgdG8gaW5pdGlhbGl6YXRpb24gb2YgYm9vdHN0cmFwLXNlbGVjdFxuICAvLyAqIGNvbnNpZGVyIHJlbW92aW5nIG9yIHJlcGxhY2luZyBhbiBhbHRlcm5hdGl2ZSBtZXRob2QgKlxuICB2YXIgdmFsSG9va3MgPSB7XG4gICAgdXNlRGVmYXVsdDogZmFsc2UsXG4gICAgX3NldDogJC52YWxIb29rcy5zZWxlY3Quc2V0XG4gIH07XG5cbiAgJC52YWxIb29rcy5zZWxlY3Quc2V0ID0gZnVuY3Rpb24gKGVsZW0sIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICF2YWxIb29rcy51c2VEZWZhdWx0KSAkKGVsZW0pLmRhdGEoJ3NlbGVjdGVkJywgdHJ1ZSk7XG5cbiAgICByZXR1cm4gdmFsSG9va3MuX3NldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBjaGFuZ2VkQXJndW1lbnRzID0gbnVsbDtcblxuICB2YXIgRXZlbnRJc1N1cHBvcnRlZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBFdmVudCgnY2hhbmdlJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSgpO1xuXG4gICQuZm4udHJpZ2dlck5hdGl2ZSA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICB2YXIgZWwgPSB0aGlzWzBdLFxuICAgICAgICBldmVudDtcblxuICAgIGlmIChlbC5kaXNwYXRjaEV2ZW50KSB7IC8vIGZvciBtb2Rlcm4gYnJvd3NlcnMgJiBJRTkrXG4gICAgICBpZiAoRXZlbnRJc1N1cHBvcnRlZCkge1xuICAgICAgICAvLyBGb3IgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50KGV2ZW50TmFtZSwge1xuICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgSUUgc2luY2UgaXQgZG9lc24ndCBzdXBwb3J0IEV2ZW50IGNvbnN0cnVjdG9yXG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgIGV2ZW50LmluaXRFdmVudChldmVudE5hbWUsIHRydWUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuICB9O1xuICAvLyA8L2VkaXRvci1mb2xkPlxuXG4gIGZ1bmN0aW9uIHN0cmluZ1NlYXJjaCAobGksIHNlYXJjaFN0cmluZywgbWV0aG9kLCBub3JtYWxpemUpIHtcbiAgICB2YXIgc3RyaW5nVHlwZXMgPSBbXG4gICAgICAgICAgJ2Rpc3BsYXknLFxuICAgICAgICAgICdzdWJ0ZXh0JyxcbiAgICAgICAgICAndG9rZW5zJ1xuICAgICAgICBdLFxuICAgICAgICBzZWFyY2hTdWNjZXNzID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1R5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RyaW5nVHlwZSA9IHN0cmluZ1R5cGVzW2ldLFxuICAgICAgICAgIHN0cmluZyA9IGxpW3N0cmluZ1R5cGVdO1xuXG4gICAgICBpZiAoc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy50b1N0cmluZygpO1xuXG4gICAgICAgIC8vIFN0cmlwIEhUTUwgdGFncy4gVGhpcyBpc24ndCBwZXJmZWN0LCBidXQgaXQncyBtdWNoIGZhc3RlciB0aGFuIGFueSBvdGhlciBtZXRob2RcbiAgICAgICAgaWYgKHN0cmluZ1R5cGUgPT09ICdkaXNwbGF5Jykge1xuICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC88W14+XSs+L2csICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub3JtYWxpemUpIHN0cmluZyA9IG5vcm1hbGl6ZVRvQmFzZShzdHJpbmcpO1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcudG9VcHBlckNhc2UoKTtcblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHNlYXJjaFN1Y2Nlc3MgPSBtZXRob2Qoc3RyaW5nLCBzZWFyY2hTdHJpbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gJ2NvbnRhaW5zJykge1xuICAgICAgICAgIHNlYXJjaFN1Y2Nlc3MgPSBzdHJpbmcuaW5kZXhPZihzZWFyY2hTdHJpbmcpID49IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VhcmNoU3VjY2VzcyA9IHN0cmluZy5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VhcmNoU3VjY2VzcykgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlYXJjaFN1Y2Nlc3M7XG4gIH1cblxuICBmdW5jdGlvbiB0b0ludGVnZXIgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCkgfHwgMDtcbiAgfVxuXG4gIC8vIEJvcnJvd2VkIGZyb20gTG9kYXNoIChfLmRlYnVycilcbiAgLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJyxcbiAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAgICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAgICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAgICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAgICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAgICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAgICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAgICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAgICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAgICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAgICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuICB2YXIgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgICAgcnNDb21ib01hcmtzRXh0ZW5kZWRSYW5nZSA9ICdcXFxcdTFhYjAtXFxcXHUxYWZmJyxcbiAgICAgIHJzQ29tYm9NYXJrc1N1cHBsZW1lbnRSYW5nZSA9ICdcXFxcdTFkYzAtXFxcXHUxZGZmJyxcbiAgICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSArIHJzQ29tYm9NYXJrc0V4dGVuZGVkUmFuZ2UgKyByc0NvbWJvTWFya3NTdXBwbGVtZW50UmFuZ2U7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuICB2YXIgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICAgKi9cbiAgdmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbiAgZnVuY3Rpb24gZGVidXJyTGV0dGVyIChrZXkpIHtcbiAgICByZXR1cm4gZGVidXJyZWRMZXR0ZXJzW2tleV07XG4gIH07XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVG9CYXNlIChzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSBzdHJpbmcudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuICB9XG5cbiAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24gKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZC5cbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBPYmplY3Qua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaHRtbEVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIGtleUNvZGVNYXAgPSB7XG4gICAgMzI6ICcgJyxcbiAgICA0ODogJzAnLFxuICAgIDQ5OiAnMScsXG4gICAgNTA6ICcyJyxcbiAgICA1MTogJzMnLFxuICAgIDUyOiAnNCcsXG4gICAgNTM6ICc1JyxcbiAgICA1NDogJzYnLFxuICAgIDU1OiAnNycsXG4gICAgNTY6ICc4JyxcbiAgICA1NzogJzknLFxuICAgIDU5OiAnOycsXG4gICAgNjU6ICdBJyxcbiAgICA2NjogJ0InLFxuICAgIDY3OiAnQycsXG4gICAgNjg6ICdEJyxcbiAgICA2OTogJ0UnLFxuICAgIDcwOiAnRicsXG4gICAgNzE6ICdHJyxcbiAgICA3MjogJ0gnLFxuICAgIDczOiAnSScsXG4gICAgNzQ6ICdKJyxcbiAgICA3NTogJ0snLFxuICAgIDc2OiAnTCcsXG4gICAgNzc6ICdNJyxcbiAgICA3ODogJ04nLFxuICAgIDc5OiAnTycsXG4gICAgODA6ICdQJyxcbiAgICA4MTogJ1EnLFxuICAgIDgyOiAnUicsXG4gICAgODM6ICdTJyxcbiAgICA4NDogJ1QnLFxuICAgIDg1OiAnVScsXG4gICAgODY6ICdWJyxcbiAgICA4NzogJ1cnLFxuICAgIDg4OiAnWCcsXG4gICAgODk6ICdZJyxcbiAgICA5MDogJ1onLFxuICAgIDk2OiAnMCcsXG4gICAgOTc6ICcxJyxcbiAgICA5ODogJzInLFxuICAgIDk5OiAnMycsXG4gICAgMTAwOiAnNCcsXG4gICAgMTAxOiAnNScsXG4gICAgMTAyOiAnNicsXG4gICAgMTAzOiAnNycsXG4gICAgMTA0OiAnOCcsXG4gICAgMTA1OiAnOSdcbiAgfTtcblxuICB2YXIga2V5Q29kZXMgPSB7XG4gICAgRVNDQVBFOiAyNywgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgRXNjYXBlIChFc2MpIGtleVxuICAgIEVOVEVSOiAxMywgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgRW50ZXIga2V5XG4gICAgU1BBQ0U6IDMyLCAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBzcGFjZSBrZXlcbiAgICBUQUI6IDksIC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIHRhYiBrZXlcbiAgICBBUlJPV19VUDogMzgsIC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIHVwIGFycm93IGtleVxuICAgIEFSUk9XX0RPV046IDQwIC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIGRvd24gYXJyb3cga2V5XG4gIH07XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBEcm9wZG93biA9IHdpbmRvdy5Ecm9wZG93biB8fCBib290c3RyYXAuRHJvcGRvd247XG5cbiAgZnVuY3Rpb24gZ2V0VmVyc2lvbiAoKSB7XG4gICAgdmFyIHZlcnNpb247XG5cbiAgICB0cnkge1xuICAgICAgdmVyc2lvbiA9ICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IuVkVSU0lPTjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHZlcnNpb24gPSBEcm9wZG93bi5WRVJTSU9OO1xuICAgIH1cblxuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgbWFqb3I6ICczJ1xuICB9O1xuXG4gIHRyeSB7XG4gICAgdmVyc2lvbi5mdWxsID0gKGdldFZlcnNpb24oKSB8fCAnJykuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpO1xuICAgIHZlcnNpb24ubWFqb3IgPSB2ZXJzaW9uLmZ1bGxbMF07XG4gICAgdmVyc2lvbi5zdWNjZXNzID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgdmFyIHNlbGVjdElkID0gMDtcblxuICB2YXIgRVZFTlRfS0VZID0gJy5icy5zZWxlY3QnO1xuXG4gIHZhciBjbGFzc05hbWVzID0ge1xuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIERJVklERVI6ICdkaXZpZGVyJyxcbiAgICBTSE9XOiAnb3BlbicsXG4gICAgRFJPUFVQOiAnZHJvcHVwJyxcbiAgICBNRU5VOiAnZHJvcGRvd24tbWVudScsXG4gICAgTUVOVVJJR0hUOiAnZHJvcGRvd24tbWVudS1yaWdodCcsXG4gICAgTUVOVUxFRlQ6ICdkcm9wZG93bi1tZW51LWxlZnQnLFxuICAgIC8vIHRvLWRvOiByZXBsYWNlIHdpdGggbW9yZSBhZHZhbmNlZCB0ZW1wbGF0ZS9jdXN0b21pemF0aW9uIG9wdGlvbnNcbiAgICBCVVRUT05DTEFTUzogJ2J0bi1kZWZhdWx0JyxcbiAgICBQT1BPVkVSSEVBREVSOiAncG9wb3Zlci10aXRsZScsXG4gICAgSUNPTkJBU0U6ICdnbHlwaGljb24nLFxuICAgIFRJQ0tJQ09OOiAnZ2x5cGhpY29uLW9rJ1xuICB9O1xuXG4gIHZhciBTZWxlY3RvciA9IHtcbiAgICBNRU5VOiAnLicgKyBjbGFzc05hbWVzLk1FTlUsXG4gICAgREFUQV9UT0dHTEU6ICdkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCInXG4gIH07XG5cbiAgdmFyIGVsZW1lbnRUZW1wbGF0ZXMgPSB7XG4gICAgZGl2OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICBzcGFuOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyksXG4gICAgaTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpLFxuICAgIHN1YnRleHQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NtYWxsJyksXG4gICAgYTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpLFxuICAgIGxpOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpLFxuICAgIHdoaXRlc3BhY2U6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUwMEEwJyksXG4gICAgZnJhZ21lbnQ6IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICBvcHRpb246IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpXG4gIH07XG5cbiAgZWxlbWVudFRlbXBsYXRlcy5zZWxlY3RlZE9wdGlvbiA9IGVsZW1lbnRUZW1wbGF0ZXMub3B0aW9uLmNsb25lTm9kZShmYWxzZSk7XG4gIGVsZW1lbnRUZW1wbGF0ZXMuc2VsZWN0ZWRPcHRpb24uc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsIHRydWUpO1xuXG4gIGVsZW1lbnRUZW1wbGF0ZXMubm9SZXN1bHRzID0gZWxlbWVudFRlbXBsYXRlcy5saS5jbG9uZU5vZGUoZmFsc2UpO1xuICBlbGVtZW50VGVtcGxhdGVzLm5vUmVzdWx0cy5jbGFzc05hbWUgPSAnbm8tcmVzdWx0cyc7XG5cbiAgZWxlbWVudFRlbXBsYXRlcy5hLnNldEF0dHJpYnV0ZSgncm9sZScsICdvcHRpb24nKTtcbiAgZWxlbWVudFRlbXBsYXRlcy5hLmNsYXNzTmFtZSA9ICdkcm9wZG93bi1pdGVtJztcblxuICBlbGVtZW50VGVtcGxhdGVzLnN1YnRleHQuY2xhc3NOYW1lID0gJ3RleHQtbXV0ZWQnO1xuXG4gIGVsZW1lbnRUZW1wbGF0ZXMudGV4dCA9IGVsZW1lbnRUZW1wbGF0ZXMuc3Bhbi5jbG9uZU5vZGUoZmFsc2UpO1xuICBlbGVtZW50VGVtcGxhdGVzLnRleHQuY2xhc3NOYW1lID0gJ3RleHQnO1xuXG4gIGVsZW1lbnRUZW1wbGF0ZXMuY2hlY2tNYXJrID0gZWxlbWVudFRlbXBsYXRlcy5zcGFuLmNsb25lTm9kZShmYWxzZSk7XG5cbiAgdmFyIFJFR0VYUF9BUlJPVyA9IG5ldyBSZWdFeHAoa2V5Q29kZXMuQVJST1dfVVAgKyAnfCcgKyBrZXlDb2Rlcy5BUlJPV19ET1dOKTtcbiAgdmFyIFJFR0VYUF9UQUJfT1JfRVNDQVBFID0gbmV3IFJlZ0V4cCgnXicgKyBrZXlDb2Rlcy5UQUIgKyAnJHwnICsga2V5Q29kZXMuRVNDQVBFKTtcblxuICB2YXIgZ2VuZXJhdGVPcHRpb24gPSB7XG4gICAgbGk6IGZ1bmN0aW9uIChjb250ZW50LCBjbGFzc2VzLCBvcHRncm91cCkge1xuICAgICAgdmFyIGxpID0gZWxlbWVudFRlbXBsYXRlcy5saS5jbG9uZU5vZGUoZmFsc2UpO1xuXG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBpZiAoY29udGVudC5ub2RlVHlwZSA9PT0gMSB8fCBjb250ZW50Lm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgIGxpLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjbGFzc2VzICE9PSAndW5kZWZpbmVkJyAmJiBjbGFzc2VzICE9PSAnJykgbGkuY2xhc3NOYW1lID0gY2xhc3NlcztcbiAgICAgIGlmICh0eXBlb2Ygb3B0Z3JvdXAgIT09ICd1bmRlZmluZWQnICYmIG9wdGdyb3VwICE9PSBudWxsKSBsaS5jbGFzc0xpc3QuYWRkKCdvcHRncm91cC0nICsgb3B0Z3JvdXApO1xuXG4gICAgICByZXR1cm4gbGk7XG4gICAgfSxcblxuICAgIGE6IGZ1bmN0aW9uICh0ZXh0LCBjbGFzc2VzLCBpbmxpbmUpIHtcbiAgICAgIHZhciBhID0gZWxlbWVudFRlbXBsYXRlcy5hLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQubm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgYS5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjbGFzc2VzICE9PSAndW5kZWZpbmVkJyAmJiBjbGFzc2VzICE9PSAnJykgYS5jbGFzc0xpc3QuYWRkLmFwcGx5KGEuY2xhc3NMaXN0LCBjbGFzc2VzLnNwbGl0KC9cXHMrLykpO1xuICAgICAgaWYgKGlubGluZSkgYS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgaW5saW5lKTtcblxuICAgICAgcmV0dXJuIGE7XG4gICAgfSxcblxuICAgIHRleHQ6IGZ1bmN0aW9uIChvcHRpb25zLCB1c2VGcmFnbWVudCkge1xuICAgICAgdmFyIHRleHRFbGVtZW50ID0gZWxlbWVudFRlbXBsYXRlcy50ZXh0LmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgc3VidGV4dEVsZW1lbnQsXG4gICAgICAgICAgaWNvbkVsZW1lbnQ7XG5cbiAgICAgIGlmIChvcHRpb25zLmNvbnRlbnQpIHtcbiAgICAgICAgdGV4dEVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9ucy5jb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dEVsZW1lbnQudGV4dENvbnRlbnQgPSBvcHRpb25zLnRleHQ7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaWNvbikge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlID0gZWxlbWVudFRlbXBsYXRlcy53aGl0ZXNwYWNlLmNsb25lTm9kZShmYWxzZSk7XG5cbiAgICAgICAgICAvLyBuZWVkIHRvIHVzZSA8aT4gZm9yIGljb25zIGluIHRoZSBidXR0b24gdG8gcHJldmVudCBhIGJyZWFraW5nIGNoYW5nZVxuICAgICAgICAgIC8vIG5vdGU6IHN3aXRjaCB0byBzcGFuIGluIG5leHQgbWFqb3IgcmVsZWFzZVxuICAgICAgICAgIGljb25FbGVtZW50ID0gKHVzZUZyYWdtZW50ID09PSB0cnVlID8gZWxlbWVudFRlbXBsYXRlcy5pIDogZWxlbWVudFRlbXBsYXRlcy5zcGFuKS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgIGljb25FbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMub3B0aW9ucy5pY29uQmFzZSArICcgJyArIG9wdGlvbnMuaWNvbjtcblxuICAgICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQoaWNvbkVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQod2hpdGVzcGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zdWJ0ZXh0KSB7XG4gICAgICAgICAgc3VidGV4dEVsZW1lbnQgPSBlbGVtZW50VGVtcGxhdGVzLnN1YnRleHQuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICBzdWJ0ZXh0RWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbnMuc3VidGV4dDtcbiAgICAgICAgICB0ZXh0RWxlbWVudC5hcHBlbmRDaGlsZChzdWJ0ZXh0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHVzZUZyYWdtZW50ID09PSB0cnVlKSB7XG4gICAgICAgIHdoaWxlICh0ZXh0RWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmFwcGVuZENoaWxkKHRleHRFbGVtZW50LmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmFwcGVuZENoaWxkKHRleHRFbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQ7XG4gICAgfSxcblxuICAgIGxhYmVsOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIHRleHRFbGVtZW50ID0gZWxlbWVudFRlbXBsYXRlcy50ZXh0LmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgc3VidGV4dEVsZW1lbnQsXG4gICAgICAgICAgaWNvbkVsZW1lbnQ7XG5cbiAgICAgIHRleHRFbGVtZW50LmlubmVySFRNTCA9IG9wdGlvbnMuZGlzcGxheTtcblxuICAgICAgaWYgKG9wdGlvbnMuaWNvbikge1xuICAgICAgICB2YXIgd2hpdGVzcGFjZSA9IGVsZW1lbnRUZW1wbGF0ZXMud2hpdGVzcGFjZS5jbG9uZU5vZGUoZmFsc2UpO1xuXG4gICAgICAgIGljb25FbGVtZW50ID0gZWxlbWVudFRlbXBsYXRlcy5zcGFuLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIGljb25FbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMub3B0aW9ucy5pY29uQmFzZSArICcgJyArIG9wdGlvbnMuaWNvbjtcblxuICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmFwcGVuZENoaWxkKGljb25FbGVtZW50KTtcbiAgICAgICAgZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudC5hcHBlbmRDaGlsZCh3aGl0ZXNwYWNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuc3VidGV4dCkge1xuICAgICAgICBzdWJ0ZXh0RWxlbWVudCA9IGVsZW1lbnRUZW1wbGF0ZXMuc3VidGV4dC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBzdWJ0ZXh0RWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbnMuc3VidGV4dDtcbiAgICAgICAgdGV4dEVsZW1lbnQuYXBwZW5kQ2hpbGQoc3VidGV4dEVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmFwcGVuZENoaWxkKHRleHRFbGVtZW50KTtcblxuICAgICAgcmV0dXJuIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRPcHRpb25EYXRhID0ge1xuICAgIGZyb21PcHRpb246IGZ1bmN0aW9uIChvcHRpb24sIHR5cGUpIHtcbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RpdmlkZXInOlxuICAgICAgICAgIHZhbHVlID0gb3B0aW9uLmdldEF0dHJpYnV0ZSgnZGF0YS1kaXZpZGVyJykgPT09ICd0cnVlJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICB2YWx1ZSA9IG9wdGlvbi50ZXh0Q29udGVudDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsYWJlbCc6XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb24ubGFiZWw7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgIHZhbHVlID0gb3B0aW9uLnN0eWxlLmNzc1RleHQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgICAgIHZhbHVlID0gb3B0aW9uLnRpdGxlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCdkYXRhLScgKyB0b0tlYmFiQ2FzZSh0eXBlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGZyb21EYXRhU291cmNlOiBmdW5jdGlvbiAob3B0aW9uLCB0eXBlKSB7XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgY2FzZSAnbGFiZWwnOlxuICAgICAgICAgIHZhbHVlID0gb3B0aW9uLnRleHQgfHwgb3B0aW9uLnZhbHVlIHx8ICcnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25bdHlwZV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gc2hvd05vUmVzdWx0cyAoc2VhcmNoTWF0Y2gsIHNlYXJjaFZhbHVlKSB7XG4gICAgaWYgKCFzZWFyY2hNYXRjaC5sZW5ndGgpIHtcbiAgICAgIGVsZW1lbnRUZW1wbGF0ZXMubm9SZXN1bHRzLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5ub25lUmVzdWx0c1RleHQucmVwbGFjZSgnezB9JywgJ1wiJyArIGh0bWxFc2NhcGUoc2VhcmNoVmFsdWUpICsgJ1wiJyk7XG4gICAgICB0aGlzLiRtZW51SW5uZXJbMF0uZmlyc3RDaGlsZC5hcHBlbmRDaGlsZChlbGVtZW50VGVtcGxhdGVzLm5vUmVzdWx0cyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVySGlkZGVuIChpdGVtKSB7XG4gICAgcmV0dXJuICEoaXRlbS5oaWRkZW4gfHwgdGhpcy5vcHRpb25zLmhpZGVEaXNhYmxlZCAmJiBpdGVtLmRpc2FibGVkKTtcbiAgfVxuXG4gIHZhciBTZWxlY3RwaWNrZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIC8vIGJvb3RzdHJhcC1zZWxlY3QgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgLSByZXZlcnQgdmFsSG9va3Muc2VsZWN0LnNldCBiYWNrIHRvIGl0cyBvcmlnaW5hbCBmdW5jdGlvblxuICAgIGlmICghdmFsSG9va3MudXNlRGVmYXVsdCkge1xuICAgICAgJC52YWxIb29rcy5zZWxlY3Quc2V0ID0gdmFsSG9va3MuX3NldDtcbiAgICAgIHZhbEhvb2tzLnVzZURlZmF1bHQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgIHRoaXMuJG5ld0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuJGJ1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4kbWVudSA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNlbGVjdHBpY2tlciA9IHtcbiAgICAgIG1haW46IHtcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIG9wdGlvblF1ZXVlOiBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgIGhhc01vcmU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc2VhcmNoOiB7XG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICBoYXNNb3JlOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGN1cnJlbnQ6IHt9LCAvLyBjdXJyZW50IGlzIGVpdGhlciBlcXVhbCB0byBtYWluIG9yIHNlYXJjaCBkZXBlbmRpbmcgb24gaWYgYSBzZWFyY2ggaXMgaW4gcHJvZ3Jlc3NcbiAgICAgIHZpZXc6IHt9LFxuICAgICAgLy8gbWFwIG9mIG9wdGlvbiB2YWx1ZXMgYW5kIHRoZWlyIHJlc3BlY3RpdmUgZGF0YSAob25seSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggb3B0aW9ucy5zb3VyY2UpXG4gICAgICBvcHRpb25WYWx1ZXNEYXRhTWFwOiB7fSxcbiAgICAgIGlzU2VhcmNoaW5nOiBmYWxzZSxcbiAgICAgIGtleWRvd246IHtcbiAgICAgICAga2V5SGlzdG9yeTogJycsXG4gICAgICAgIHJlc2V0S2V5SGlzdG9yeToge1xuICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ua2V5SGlzdG9yeSA9ICcnO1xuICAgICAgICAgICAgfSwgODAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5zaXplSW5mbyA9IHt9O1xuXG4gICAgLy8gRm9ybWF0IHdpbmRvdyBwYWRkaW5nXG4gICAgdmFyIHdpblBhZCA9IHRoaXMub3B0aW9ucy53aW5kb3dQYWRkaW5nO1xuICAgIGlmICh0eXBlb2Ygd2luUGFkID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5vcHRpb25zLndpbmRvd1BhZGRpbmcgPSBbd2luUGFkLCB3aW5QYWQsIHdpblBhZCwgd2luUGFkXTtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgcHVibGljIG1ldGhvZHNcbiAgICB0aGlzLnZhbCA9IFNlbGVjdHBpY2tlci5wcm90b3R5cGUudmFsO1xuICAgIHRoaXMucmVuZGVyID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5yZW5kZXI7XG4gICAgdGhpcy5yZWZyZXNoID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5yZWZyZXNoO1xuICAgIHRoaXMuc2V0U3R5bGUgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnNldFN0eWxlO1xuICAgIHRoaXMuc2VsZWN0QWxsID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5zZWxlY3RBbGw7XG4gICAgdGhpcy5kZXNlbGVjdEFsbCA9IFNlbGVjdHBpY2tlci5wcm90b3R5cGUuZGVzZWxlY3RBbGw7XG4gICAgdGhpcy5kZXN0cm95ID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5kZXN0cm95O1xuICAgIHRoaXMucmVtb3ZlID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5yZW1vdmU7XG4gICAgdGhpcy5zaG93ID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5zaG93O1xuICAgIHRoaXMuaGlkZSA9IFNlbGVjdHBpY2tlci5wcm90b3R5cGUuaGlkZTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9O1xuXG4gIFNlbGVjdHBpY2tlci5WRVJTSU9OID0gJzEuMTQuMC1iZXRhMyc7XG5cbiAgLy8gcGFydCBvZiB0aGlzIGlzIGR1cGxpY2F0ZWQgaW4gaTE4bi9kZWZhdWx0cy1lbl9VUy5qcy4gTWFrZSBzdXJlIHRvIHVwZGF0ZSBib3RoLlxuICBTZWxlY3RwaWNrZXIuREVGQVVMVFMgPSB7XG4gICAgbm9uZVNlbGVjdGVkVGV4dDogJ05vdGhpbmcgc2VsZWN0ZWQnLFxuICAgIG5vbmVSZXN1bHRzVGV4dDogJ05vIHJlc3VsdHMgbWF0Y2hlZCB7MH0nLFxuICAgIGNvdW50U2VsZWN0ZWRUZXh0OiBmdW5jdGlvbiAobnVtU2VsZWN0ZWQsIG51bVRvdGFsKSB7XG4gICAgICByZXR1cm4gKG51bVNlbGVjdGVkID09IDEpID8gJ3swfSBpdGVtIHNlbGVjdGVkJyA6ICd7MH0gaXRlbXMgc2VsZWN0ZWQnO1xuICAgIH0sXG4gICAgbWF4T3B0aW9uc1RleHQ6IGZ1bmN0aW9uIChudW1BbGwsIG51bUdyb3VwKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAobnVtQWxsID09IDEpID8gJ0xpbWl0IHJlYWNoZWQgKHtufSBpdGVtIG1heCknIDogJ0xpbWl0IHJlYWNoZWQgKHtufSBpdGVtcyBtYXgpJyxcbiAgICAgICAgKG51bUdyb3VwID09IDEpID8gJ0dyb3VwIGxpbWl0IHJlYWNoZWQgKHtufSBpdGVtIG1heCknIDogJ0dyb3VwIGxpbWl0IHJlYWNoZWQgKHtufSBpdGVtcyBtYXgpJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIHNlbGVjdEFsbFRleHQ6ICdTZWxlY3QgQWxsJyxcbiAgICBkZXNlbGVjdEFsbFRleHQ6ICdEZXNlbGVjdCBBbGwnLFxuICAgIHNvdXJjZToge1xuICAgICAgcGFnZVNpemU6IDQwXG4gICAgfSxcbiAgICBjaHVua1NpemU6IDQwLFxuICAgIGRvbmVCdXR0b246IGZhbHNlLFxuICAgIGRvbmVCdXR0b25UZXh0OiAnQ2xvc2UnLFxuICAgIG11bHRpcGxlU2VwYXJhdG9yOiAnLCAnLFxuICAgIHN0eWxlQmFzZTogJ2J0bicsXG4gICAgc3R5bGU6IGNsYXNzTmFtZXMuQlVUVE9OQ0xBU1MsXG4gICAgc2l6ZTogJ2F1dG8nLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIGFsbG93Q2xlYXI6IGZhbHNlLFxuICAgIHNlbGVjdGVkVGV4dEZvcm1hdDogJ3ZhbHVlcycsXG4gICAgd2lkdGg6IGZhbHNlLFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgaGlkZURpc2FibGVkOiBmYWxzZSxcbiAgICBzaG93U3VidGV4dDogZmFsc2UsXG4gICAgc2hvd0ljb246IHRydWUsXG4gICAgc2hvd0NvbnRlbnQ6IHRydWUsXG4gICAgZHJvcHVwQXV0bzogdHJ1ZSxcbiAgICBoZWFkZXI6IGZhbHNlLFxuICAgIGxpdmVTZWFyY2g6IGZhbHNlLFxuICAgIGxpdmVTZWFyY2hQbGFjZWhvbGRlcjogbnVsbCxcbiAgICBsaXZlU2VhcmNoTm9ybWFsaXplOiBmYWxzZSxcbiAgICBsaXZlU2VhcmNoU3R5bGU6ICdjb250YWlucycsXG4gICAgYWN0aW9uc0JveDogZmFsc2UsXG4gICAgaWNvbkJhc2U6IGNsYXNzTmFtZXMuSUNPTkJBU0UsXG4gICAgdGlja0ljb246IGNsYXNzTmFtZXMuVElDS0lDT04sXG4gICAgc2hvd1RpY2s6IGZhbHNlLFxuICAgIHRlbXBsYXRlOiB7XG4gICAgICBjYXJldDogJzxzcGFuIGNsYXNzPVwiY2FyZXRcIj48L3NwYW4+J1xuICAgIH0sXG4gICAgbWF4T3B0aW9uczogZmFsc2UsXG4gICAgbW9iaWxlOiBmYWxzZSxcbiAgICBzZWxlY3RPblRhYjogdHJ1ZSxcbiAgICBkcm9wZG93bkFsaWduUmlnaHQ6IGZhbHNlLFxuICAgIHdpbmRvd1BhZGRpbmc6IDAsXG4gICAgdmlydHVhbFNjcm9sbDogNjAwLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIHNhbml0aXplOiB0cnVlLFxuICAgIHNhbml0aXplRm46IG51bGwsXG4gICAgd2hpdGVMaXN0OiBEZWZhdWx0V2hpdGVsaXN0XG4gIH07XG5cbiAgU2VsZWN0cGlja2VyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBTZWxlY3RwaWNrZXIsXG5cbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyksXG4gICAgICAgICAgZWxlbWVudCA9IHRoaXMuJGVsZW1lbnRbMF0sXG4gICAgICAgICAgZm9ybSA9IGVsZW1lbnQuZm9ybTtcblxuICAgICAgc2VsZWN0SWQrKztcbiAgICAgIHRoaXMuc2VsZWN0SWQgPSAnYnMtc2VsZWN0LScgKyBzZWxlY3RJZDtcblxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdicy1zZWxlY3QtaGlkZGVuJyk7XG5cbiAgICAgIHRoaXMubXVsdGlwbGUgPSB0aGlzLiRlbGVtZW50LnByb3AoJ211bHRpcGxlJyk7XG4gICAgICB0aGlzLmF1dG9mb2N1cyA9IHRoaXMuJGVsZW1lbnQucHJvcCgnYXV0b2ZvY3VzJyk7XG5cbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc2hvdy10aWNrJykpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNob3dUaWNrID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kbmV3RWxlbWVudCA9IHRoaXMuY3JlYXRlRHJvcGRvd24oKTtcblxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAuYWZ0ZXIodGhpcy4kbmV3RWxlbWVudClcbiAgICAgICAgLnByZXBlbmRUbyh0aGlzLiRuZXdFbGVtZW50KTtcblxuICAgICAgLy8gZW5zdXJlIHNlbGVjdCBpcyBhc3NvY2lhdGVkIHdpdGggZm9ybSBlbGVtZW50IGlmIGl0IGdvdCB1bmxpbmtlZCBhZnRlciBtb3ZpbmcgaXQgaW5zaWRlIG5ld0VsZW1lbnRcbiAgICAgIGlmIChmb3JtICYmIGVsZW1lbnQuZm9ybSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoIWZvcm0uaWQpIGZvcm0uaWQgPSAnZm9ybS0nICsgdGhpcy5zZWxlY3RJZDtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Zvcm0nLCBmb3JtLmlkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kYnV0dG9uID0gdGhpcy4kbmV3RWxlbWVudC5jaGlsZHJlbignYnV0dG9uJyk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93Q2xlYXIpIHRoaXMuJGNsZWFyQnV0dG9uID0gdGhpcy4kYnV0dG9uLmNoaWxkcmVuKCcuYnMtc2VsZWN0LWNsZWFyLXNlbGVjdGVkJyk7XG4gICAgICB0aGlzLiRtZW51ID0gdGhpcy4kbmV3RWxlbWVudC5jaGlsZHJlbihTZWxlY3Rvci5NRU5VKTtcbiAgICAgIHRoaXMuJG1lbnVJbm5lciA9IHRoaXMuJG1lbnUuY2hpbGRyZW4oJy5pbm5lcicpO1xuICAgICAgdGhpcy4kc2VhcmNoYm94ID0gdGhpcy4kbWVudS5maW5kKCdpbnB1dCcpO1xuXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2JzLXNlbGVjdC1oaWRkZW4nKTtcblxuICAgICAgdGhpcy5mZXRjaERhdGEoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0LnJlbmRlcih0cnVlKTtcbiAgICAgICAgdGhhdC5idWlsZExpc3QoKTtcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignbG9hZGVkJyArIEVWRU5UX0tFWSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJvcGRvd25BbGlnblJpZ2h0ID09PSB0cnVlKSB0aGlzLiRtZW51WzBdLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lcy5NRU5VUklHSFQpO1xuXG4gICAgICBpZiAodHlwZW9mIGlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLiRidXR0b24uYXR0cignZGF0YS1pZCcsIGlkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGVja0Rpc2FibGVkKCk7XG4gICAgICB0aGlzLmNsaWNrTGlzdGVuZXIoKTtcblxuICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPiA0KSB0aGlzLmRyb3Bkb3duID0gbmV3IERyb3Bkb3duKHRoaXMuJGJ1dHRvblswXSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaCkge1xuICAgICAgICB0aGlzLmxpdmVTZWFyY2hMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLmZvY3VzZWRQYXJlbnQgPSB0aGlzLiRzZWFyY2hib3hbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvY3VzZWRQYXJlbnQgPSB0aGlzLiRtZW51SW5uZXJbMF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3R5bGUoKTtcbiAgICAgIHRoaXMuc2V0V2lkdGgoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0UG9zaXRpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2hpZGUnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoYXQuaXNWaXJ0dWFsKCkpIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IG1lbnUgb24gY2xvc2VcbiAgICAgICAgICAgIHZhciBtZW51SW5uZXIgPSB0aGF0LiRtZW51SW5uZXJbMF0sXG4gICAgICAgICAgICAgICAgZW1wdHlNZW51ID0gbWVudUlubmVyLmZpcnN0Q2hpbGQuY2xvbmVOb2RlKGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgZXhpc3RpbmcgVUwgd2l0aCBhbiBlbXB0eSBvbmUgLSB0aGlzIGlzIGZhc3RlciB0aGFuICQuZW1wdHkoKSBvciBpbm5lckhUTUwgPSAnJ1xuICAgICAgICAgICAgbWVudUlubmVyLnJlcGxhY2VDaGlsZChlbXB0eU1lbnUsIG1lbnVJbm5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIG1lbnVJbm5lci5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLiRtZW51LmRhdGEoJ3RoaXMnLCB0aGlzKTtcbiAgICAgIHRoaXMuJG5ld0VsZW1lbnQuZGF0YSgndGhpcycsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tb2JpbGUpIHRoaXMubW9iaWxlKCk7XG5cbiAgICAgIHRoaXMuJG5ld0VsZW1lbnQub24oe1xuICAgICAgICAnaGlkZS5icy5kcm9wZG93bic6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdoaWRlJyArIEVWRU5UX0tFWSwgZSk7XG4gICAgICAgIH0sXG4gICAgICAgICdoaWRkZW4uYnMuZHJvcGRvd24nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignaGlkZGVuJyArIEVWRU5UX0tFWSwgZSk7XG4gICAgICAgIH0sXG4gICAgICAgICdzaG93LmJzLmRyb3Bkb3duJzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cnICsgRVZFTlRfS0VZLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ3Nob3duLmJzLmRyb3Bkb3duJzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ3Nob3duJyArIEVWRU5UX0tFWSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JlcXVpcmVkJykpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignaW52YWxpZCcgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LiRidXR0b25bMF0uY2xhc3NMaXN0LmFkZCgnYnMtaW52YWxpZCcpO1xuXG4gICAgICAgICAgdGhhdC4kZWxlbWVudFxuICAgICAgICAgICAgLm9uKCdzaG93bicgKyBFVkVOVF9LRVkgKyAnLmludmFsaWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgICAgICAgICAudmFsKHRoYXQuJGVsZW1lbnQudmFsKCkpIC8vIHNldCB0aGUgdmFsdWUgdG8gaGlkZSB0aGUgdmFsaWRhdGlvbiBtZXNzYWdlIGluIENocm9tZSB3aGVuIG1lbnUgaXMgb3BlbmVkXG4gICAgICAgICAgICAgICAgLm9mZignc2hvd24nICsgRVZFTlRfS0VZICsgJy5pbnZhbGlkJyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdyZW5kZXJlZCcgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gaWYgc2VsZWN0IGlzIG5vIGxvbmdlciBpbnZhbGlkLCByZW1vdmUgdGhlIGJzLWludmFsaWQgY2xhc3NcbiAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRpdHkudmFsaWQpIHRoYXQuJGJ1dHRvblswXS5jbGFzc0xpc3QucmVtb3ZlKCdicy1pbnZhbGlkJyk7XG4gICAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQub2ZmKCdyZW5kZXJlZCcgKyBFVkVOVF9LRVkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGF0LiRidXR0b24ub24oJ2JsdXInICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcignYmx1cicpO1xuICAgICAgICAgICAgdGhhdC4kYnV0dG9uLm9mZignYmx1cicgKyBFVkVOVF9LRVkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgJChmb3JtKS5vbigncmVzZXQnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQucmVuZGVyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjcmVhdGVEcm9wZG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gT3B0aW9uc1xuICAgICAgLy8gSWYgd2UgYXJlIG11bHRpcGxlIG9yIHNob3dUaWNrIG9wdGlvbiBpcyBzZXQsIHRoZW4gYWRkIHRoZSBzaG93LXRpY2sgY2xhc3NcbiAgICAgIHZhciBzaG93VGljayA9ICh0aGlzLm11bHRpcGxlIHx8IHRoaXMub3B0aW9ucy5zaG93VGljaykgPyAnIHNob3ctdGljaycgOiAnJyxcbiAgICAgICAgICBtdWx0aXNlbGVjdGFibGUgPSB0aGlzLm11bHRpcGxlID8gJyBhcmlhLW11bHRpc2VsZWN0YWJsZT1cInRydWVcIicgOiAnJyxcbiAgICAgICAgICBpbnB1dEdyb3VwID0gJycsXG4gICAgICAgICAgYXV0b2ZvY3VzID0gdGhpcy5hdXRvZm9jdXMgPyAnIGF1dG9mb2N1cycgOiAnJztcblxuICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPCA0ICYmIHRoaXMuJGVsZW1lbnQucGFyZW50KCkuaGFzQ2xhc3MoJ2lucHV0LWdyb3VwJykpIHtcbiAgICAgICAgaW5wdXRHcm91cCA9ICcgaW5wdXQtZ3JvdXAtYnRuJztcbiAgICAgIH1cblxuICAgICAgLy8gRWxlbWVudHNcbiAgICAgIHZhciBkcm9wLFxuICAgICAgICAgIGhlYWRlciA9ICcnLFxuICAgICAgICAgIHNlYXJjaGJveCA9ICcnLFxuICAgICAgICAgIGFjdGlvbnNib3ggPSAnJyxcbiAgICAgICAgICBkb25lYnV0dG9uID0gJycsXG4gICAgICAgICAgY2xlYXJCdXR0b24gPSAnJztcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXIpIHtcbiAgICAgICAgaGVhZGVyID1cbiAgICAgICAgICAnPGRpdiBjbGFzcz1cIicgKyBjbGFzc05hbWVzLlBPUE9WRVJIRUFERVIgKyAnXCI+JyArXG4gICAgICAgICAgICAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L2J1dHRvbj4nICtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhlYWRlciArXG4gICAgICAgICAgJzwvZGl2Pic7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaCkge1xuICAgICAgICBzZWFyY2hib3ggPVxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYnMtc2VhcmNoYm94XCI+JyArXG4gICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJzZWFyY2hcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGF1dG9jb21wbGV0ZT1cIm9mZlwiJyArXG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaFBsYWNlaG9sZGVyID09PSBudWxsID8gJydcbiAgICAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgICAgJyBwbGFjZWhvbGRlcj1cIicgKyBodG1sRXNjYXBlKHRoaXMub3B0aW9ucy5saXZlU2VhcmNoUGxhY2Vob2xkZXIpICsgJ1wiJ1xuICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgJyByb2xlPVwiY29tYm9ib3hcIiBhcmlhLWxhYmVsPVwiU2VhcmNoXCIgYXJpYS1jb250cm9scz1cIicgKyB0aGlzLnNlbGVjdElkICsgJ1wiIGFyaWEtYXV0b2NvbXBsZXRlPVwibGlzdFwiPicgK1xuICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tdWx0aXBsZSAmJiB0aGlzLm9wdGlvbnMuYWN0aW9uc0JveCkge1xuICAgICAgICBhY3Rpb25zYm94ID1cbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImJzLWFjdGlvbnNib3hcIj4nICtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIGJ0bi1ncm91cC1zbVwiPicgK1xuICAgICAgICAgICAgICAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJhY3Rpb25zLWJ0biBicy1zZWxlY3QtYWxsIGJ0biAnICsgY2xhc3NOYW1lcy5CVVRUT05DTEFTUyArICdcIj4nICtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0QWxsVGV4dCArXG4gICAgICAgICAgICAgICc8L2J1dHRvbj4nICtcbiAgICAgICAgICAgICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYWN0aW9ucy1idG4gYnMtZGVzZWxlY3QtYWxsIGJ0biAnICsgY2xhc3NOYW1lcy5CVVRUT05DTEFTUyArICdcIj4nICtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGVzZWxlY3RBbGxUZXh0ICtcbiAgICAgICAgICAgICAgJzwvYnV0dG9uPicgK1xuICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tdWx0aXBsZSAmJiB0aGlzLm9wdGlvbnMuZG9uZUJ1dHRvbikge1xuICAgICAgICBkb25lYnV0dG9uID1cbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImJzLWRvbmVidXR0b25cIj4nICtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwXCI+JyArXG4gICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc20gJyArIGNsYXNzTmFtZXMuQlVUVE9OQ0xBU1MgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRvbmVCdXR0b25UZXh0ICtcbiAgICAgICAgICAgICAgJzwvYnV0dG9uPicgK1xuICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93Q2xlYXIpIHtcbiAgICAgICAgY2xlYXJCdXR0b24gPSAnPHNwYW4gY2xhc3M9XCJjbG9zZSBicy1zZWxlY3QtY2xlYXItc2VsZWN0ZWRcIiB0aXRsZT1cIicgKyB0aGlzLm9wdGlvbnMuZGVzZWxlY3RBbGxUZXh0ICsgJ1wiPjxzcGFuPiZ0aW1lczs8L3NwYW4+JztcbiAgICAgIH1cblxuICAgICAgZHJvcCA9XG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZHJvcGRvd24gYm9vdHN0cmFwLXNlbGVjdCcgKyBzaG93VGljayArIGlucHV0R3JvdXAgKyAnXCI+JyArXG4gICAgICAgICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiLTFcIiBjbGFzcz1cIicgK1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0eWxlQmFzZSArXG4gICAgICAgICAgICAnIGRyb3Bkb3duLXRvZ2dsZVwiICcgK1xuICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5kaXNwbGF5ID09PSAnc3RhdGljJyA/ICdkYXRhLWRpc3BsYXk9XCJzdGF0aWNcIicgOiAnJykgK1xuICAgICAgICAgICAgU2VsZWN0b3IuREFUQV9UT0dHTEUgK1xuICAgICAgICAgICAgYXV0b2ZvY3VzICtcbiAgICAgICAgICAgICcgcm9sZT1cImNvbWJvYm94XCIgYXJpYS1vd25zPVwiJyArXG4gICAgICAgICAgICB0aGlzLnNlbGVjdElkICtcbiAgICAgICAgICAgICdcIiBhcmlhLWhhc3BvcHVwPVwibGlzdGJveFwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPicgK1xuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmaWx0ZXItb3B0aW9uXCI+JyArXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmlsdGVyLW9wdGlvbi1pbm5lclwiPicgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmlsdGVyLW9wdGlvbi1pbm5lci1pbm5lclwiPiZuYnNwOzwvZGl2PicgK1xuICAgICAgICAgICAgICAnPC9kaXY+ICcgK1xuICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgY2xlYXJCdXR0b24gK1xuICAgICAgICAgICAgJzwvc3Bhbj4nICtcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgdmVyc2lvbi5tYWpvciA+PSAnNCcgPyAnJ1xuICAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImJzLWNhcmV0XCI+JyArXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRlbXBsYXRlLmNhcmV0ICtcbiAgICAgICAgICAgICAgJzwvc3Bhbj4nXG4gICAgICAgICAgICApICtcbiAgICAgICAgICAnPC9idXR0b24+JyArXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCInICsgY2xhc3NOYW1lcy5NRU5VICsgJyAnICsgKHZlcnNpb24ubWFqb3IgPj0gJzQnID8gJycgOiBjbGFzc05hbWVzLlNIT1cpICsgJ1wiPicgK1xuICAgICAgICAgICAgaGVhZGVyICtcbiAgICAgICAgICAgIHNlYXJjaGJveCArXG4gICAgICAgICAgICBhY3Rpb25zYm94ICtcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaW5uZXIgJyArIGNsYXNzTmFtZXMuU0hPVyArICdcIiByb2xlPVwibGlzdGJveFwiIGlkPVwiJyArIHRoaXMuc2VsZWN0SWQgKyAnXCIgdGFiaW5kZXg9XCItMVwiICcgKyBtdWx0aXNlbGVjdGFibGUgKyAnPicgK1xuICAgICAgICAgICAgICAgICc8dWwgY2xhc3M9XCInICsgY2xhc3NOYW1lcy5NRU5VICsgJyBpbm5lciAnICsgKHZlcnNpb24ubWFqb3IgPj0gJzQnID8gY2xhc3NOYW1lcy5TSE9XIDogJycpICsgJ1wiIHJvbGU9XCJwcmVzZW50YXRpb25cIj4nICtcbiAgICAgICAgICAgICAgICAnPC91bD4nICtcbiAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgIGRvbmVidXR0b24gK1xuICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgJzwvZGl2Pic7XG5cbiAgICAgIHJldHVybiAkKGRyb3ApO1xuICAgIH0sXG5cbiAgICBzZXRQb3NpdGlvbkRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0ID0gW107XG4gICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnNpemUgPSAwO1xuICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy5maXJzdEhpZ2hsaWdodEluZGV4ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaSA9IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpXSxcbiAgICAgICAgICAgIGNhbkhpZ2hsaWdodCA9IHRydWU7XG5cbiAgICAgICAgaWYgKGxpLnR5cGUgPT09ICdkaXZpZGVyJykge1xuICAgICAgICAgIGNhbkhpZ2hsaWdodCA9IGZhbHNlO1xuICAgICAgICAgIGxpLmhlaWdodCA9IHRoaXMuc2l6ZUluZm8uZGl2aWRlckhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChsaS50eXBlID09PSAnb3B0Z3JvdXAtbGFiZWwnKSB7XG4gICAgICAgICAgY2FuSGlnaGxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgbGkuaGVpZ2h0ID0gdGhpcy5zaXplSW5mby5kcm9wZG93bkhlYWRlckhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaS5oZWlnaHQgPSB0aGlzLnNpemVJbmZvLmxpSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpLmRpc2FibGVkKSBjYW5IaWdobGlnaHQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodC5wdXNoKGNhbkhpZ2hsaWdodCk7XG5cbiAgICAgICAgaWYgKGNhbkhpZ2hsaWdodCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuc2l6ZSsrO1xuICAgICAgICAgIGxpLnBvc2luc2V0ID0gdGhpcy5zZWxlY3RwaWNrZXIudmlldy5zaXplO1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdHBpY2tlci52aWV3LmZpcnN0SGlnaGxpZ2h0SW5kZXggPT09IGZhbHNlKSB0aGlzLnNlbGVjdHBpY2tlci52aWV3LmZpcnN0SGlnaGxpZ2h0SW5kZXggPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGkucG9zaXRpb24gPSAoaSA9PT0gMCA/IDAgOiB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbaSAtIDFdLnBvc2l0aW9uKSArIGxpLmhlaWdodDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNWaXJ0dWFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMub3B0aW9ucy52aXJ0dWFsU2Nyb2xsICE9PSBmYWxzZSkgJiYgKHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YS5sZW5ndGggPj0gdGhpcy5vcHRpb25zLnZpcnR1YWxTY3JvbGwpIHx8IHRoaXMub3B0aW9ucy52aXJ0dWFsU2Nyb2xsID09PSB0cnVlO1xuICAgIH0sXG5cbiAgICBjcmVhdGVWaWV3OiBmdW5jdGlvbiAoaXNTZWFyY2hpbmcsIHNldFNpemUsIHJlZnJlc2gpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBzY3JvbGxUb3AgPSAwO1xuXG4gICAgICB0aGlzLnNlbGVjdHBpY2tlci5pc1NlYXJjaGluZyA9IGlzU2VhcmNoaW5nO1xuICAgICAgdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudCA9IGlzU2VhcmNoaW5nID8gdGhpcy5zZWxlY3RwaWNrZXIuc2VhcmNoIDogdGhpcy5zZWxlY3RwaWNrZXIubWFpbjtcblxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkRhdGEoKTtcblxuICAgICAgaWYgKHNldFNpemUpIHtcbiAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICBzY3JvbGxUb3AgPSB0aGlzLiRtZW51SW5uZXJbMF0uc2Nyb2xsVG9wO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGF0Lm11bHRpcGxlKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGF0LiRlbGVtZW50WzBdLFxuICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4ID0gKGVsZW1lbnQub3B0aW9uc1tlbGVtZW50LnNlbGVjdGVkSW5kZXhdIHx8IHt9KS5saUluZGV4O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RlZEluZGV4ID09PSAnbnVtYmVyJyAmJiB0aGF0Lm9wdGlvbnMuc2l6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZERhdGEgPSB0aGF0LnNlbGVjdHBpY2tlci5tYWluLmRhdGFbc2VsZWN0ZWRJbmRleF0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBzZWxlY3RlZERhdGEgJiYgc2VsZWN0ZWREYXRhLnBvc2l0aW9uO1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gcG9zaXRpb24gLSAoKHRoYXQuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0ICsgdGhhdC5zaXplSW5mby5saUhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2Nyb2xsKHNjcm9sbFRvcCwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuJG1lbnVJbm5lci5vZmYoJ3Njcm9sbC5jcmVhdGVWaWV3Jykub24oJ3Njcm9sbC5jcmVhdGVWaWV3JywgZnVuY3Rpb24gKGUsIHVwZGF0ZVZhbHVlKSB7XG4gICAgICAgIGlmICghdGhhdC5ub1Njcm9sbCkgc2Nyb2xsKHRoaXMuc2Nyb2xsVG9wLCB1cGRhdGVWYWx1ZSk7XG4gICAgICAgIHRoYXQubm9TY3JvbGwgPSBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBzY3JvbGwgKHNjcm9sbFRvcCwgaW5pdCkge1xuICAgICAgICB2YXIgc2l6ZSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBjaHVua3MgPSBbXSxcbiAgICAgICAgICAgIGNodW5rU2l6ZSxcbiAgICAgICAgICAgIGNodW5rQ291bnQsXG4gICAgICAgICAgICBmaXJzdENodW5rLFxuICAgICAgICAgICAgbGFzdENodW5rLFxuICAgICAgICAgICAgY3VycmVudENodW5rLFxuICAgICAgICAgICAgcHJldlBvc2l0aW9ucyxcbiAgICAgICAgICAgIHBvc2l0aW9uSXNEaWZmZXJlbnQsXG4gICAgICAgICAgICBwcmV2aW91c0VsZW1lbnRzLFxuICAgICAgICAgICAgbWVudUlzRGlmZmVyZW50ID0gdHJ1ZSxcbiAgICAgICAgICAgIGlzVmlydHVhbCA9IHRoYXQuaXNWaXJ0dWFsKCk7XG5cbiAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG5cbiAgICAgICAgY2h1bmtTaXplID0gdGhhdC5vcHRpb25zLmNodW5rU2l6ZTsgLy8gbnVtYmVyIG9mIG9wdGlvbnMgaW4gYSBjaHVua1xuICAgICAgICBjaHVua0NvdW50ID0gTWF0aC5jZWlsKHNpemUgLyBjaHVua1NpemUpIHx8IDE7IC8vIG51bWJlciBvZiBjaHVua3NcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rQ291bnQ7IGkrKykge1xuICAgICAgICAgIHZhciBlbmRPZkNodW5rID0gKGkgKyAxKSAqIGNodW5rU2l6ZTtcblxuICAgICAgICAgIGlmIChpID09PSBjaHVua0NvdW50IC0gMSkge1xuICAgICAgICAgICAgZW5kT2ZDaHVuayA9IHNpemU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2h1bmtzW2ldID0gW1xuICAgICAgICAgICAgKGkpICogY2h1bmtTaXplICsgKCFpID8gMCA6IDEpLFxuICAgICAgICAgICAgZW5kT2ZDaHVua1xuICAgICAgICAgIF07XG5cbiAgICAgICAgICBpZiAoIXNpemUpIGJyZWFrO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnRDaHVuayA9PT0gdW5kZWZpbmVkICYmIHNjcm9sbFRvcCAtIDEgPD0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2VuZE9mQ2h1bmsgLSAxXS5wb3NpdGlvbiAtIHRoYXQuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgICBjdXJyZW50Q2h1bmsgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50Q2h1bmsgPT09IHVuZGVmaW5lZCkgY3VycmVudENodW5rID0gMDtcblxuICAgICAgICBwcmV2UG9zaXRpb25zID0gW3RoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wLCB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMV07XG5cbiAgICAgICAgLy8gYWx3YXlzIGRpc3BsYXkgcHJldmlvdXMsIGN1cnJlbnQsIGFuZCBuZXh0IGNodW5rc1xuICAgICAgICBmaXJzdENodW5rID0gTWF0aC5tYXgoMCwgY3VycmVudENodW5rIC0gMSk7XG4gICAgICAgIGxhc3RDaHVuayA9IE1hdGgubWluKGNodW5rQ291bnQgLSAxLCBjdXJyZW50Q2h1bmsgKyAxKTtcblxuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCA9IGlzVmlydHVhbCA9PT0gZmFsc2UgPyAwIDogKE1hdGgubWF4KDAsIGNodW5rc1tmaXJzdENodW5rXVswXSkgfHwgMCk7XG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24xID0gaXNWaXJ0dWFsID09PSBmYWxzZSA/IHNpemUgOiAoTWF0aC5taW4oc2l6ZSwgY2h1bmtzW2xhc3RDaHVua11bMV0pIHx8IDApO1xuXG4gICAgICAgIHBvc2l0aW9uSXNEaWZmZXJlbnQgPSBwcmV2UG9zaXRpb25zWzBdICE9PSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCB8fCBwcmV2UG9zaXRpb25zWzFdICE9PSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMTtcblxuICAgICAgICBpZiAodGhhdC5hY3RpdmVFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgaWYgKHRoYXQuYWN0aXZlRWxlbWVudCAhPT0gdGhhdC5zZWxlY3RlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgdGhhdC5kZWZvY3VzSXRlbSh0aGF0LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5hY3RpdmVFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGF0LmFjdGl2ZUVsZW1lbnQgIT09IHRoYXQuc2VsZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGF0LmRlZm9jdXNJdGVtKHRoYXQuc2VsZWN0ZWRFbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhhdC5wcmV2QWN0aXZlRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmIHRoYXQucHJldkFjdGl2ZUVsZW1lbnQgIT09IHRoYXQuYWN0aXZlRWxlbWVudCAmJiB0aGF0LnByZXZBY3RpdmVFbGVtZW50ICE9PSB0aGF0LnNlbGVjdGVkRWxlbWVudCkge1xuICAgICAgICAgIHRoYXQuZGVmb2N1c0l0ZW0odGhhdC5wcmV2QWN0aXZlRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5pdCB8fCBwb3NpdGlvbklzRGlmZmVyZW50IHx8IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuaGFzTW9yZSkge1xuICAgICAgICAgIHByZXZpb3VzRWxlbWVudHMgPSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnZpc2libGVFbGVtZW50cyA/IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzLnNsaWNlKCkgOiBbXTtcblxuICAgICAgICAgIGlmIChpc1ZpcnR1YWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnZpc2libGVFbGVtZW50cyA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cy5zbGljZSh0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCwgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoYXQuc2V0T3B0aW9uU3RhdHVzKCk7XG5cbiAgICAgICAgICAvLyBpZiBzZWFyY2hpbmcsIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgbGlzdCBoYXMgYWN0dWFsbHkgYmVlbiB1cGRhdGVkIGJlZm9yZSB1cGRhdGluZyBET01cbiAgICAgICAgICAvLyB0aGlzIHByZXZlbnRzIHVubmVjZXNzYXJ5IHJlcGFpbnRzXG4gICAgICAgICAgaWYgKGlzU2VhcmNoaW5nIHx8IChpc1ZpcnR1YWwgPT09IGZhbHNlICYmIGluaXQpKSBtZW51SXNEaWZmZXJlbnQgPSAhaXNFcXVhbChwcmV2aW91c0VsZW1lbnRzLCB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnZpc2libGVFbGVtZW50cyk7XG5cbiAgICAgICAgICAvLyBpZiB2aXJ0dWFsIHNjcm9sbCBpcyBkaXNhYmxlZCBhbmQgbm90IHNlYXJjaGluZyxcbiAgICAgICAgICAvLyBtZW51IHNob3VsZCBuZXZlciBuZWVkIHRvIGJlIHVwZGF0ZWQgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICBpZiAoKGluaXQgfHwgaXNWaXJ0dWFsID09PSB0cnVlKSAmJiBtZW51SXNEaWZmZXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBtZW51SW5uZXIgPSB0aGF0LiRtZW51SW5uZXJbMF0sXG4gICAgICAgICAgICAgICAgbWVudUZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgICAgIGVtcHR5TWVudSA9IG1lbnVJbm5lci5maXJzdENoaWxkLmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSxcbiAgICAgICAgICAgICAgICBlbGVtZW50cyA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzLFxuICAgICAgICAgICAgICAgIHRvU2FuaXRpemUgPSBbXTtcblxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgZXhpc3RpbmcgVUwgd2l0aCBhbiBlbXB0eSBvbmUgLSB0aGlzIGlzIGZhc3RlciB0aGFuICQuZW1wdHkoKVxuICAgICAgICAgICAgbWVudUlubmVyLnJlcGxhY2VDaGlsZChlbXB0eU1lbnUsIG1lbnVJbm5lci5maXJzdENoaWxkKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHZpc2libGVFbGVtZW50c0xlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IHZpc2libGVFbGVtZW50c0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV0sXG4gICAgICAgICAgICAgICAgICBlbFRleHQsXG4gICAgICAgICAgICAgICAgICBlbGVtZW50RGF0YTtcblxuICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNhbml0aXplKSB7XG4gICAgICAgICAgICAgICAgZWxUZXh0ID0gZWxlbWVudC5sYXN0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxUZXh0KSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50RGF0YSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpICsgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjBdO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudERhdGEgJiYgZWxlbWVudERhdGEuY29udGVudCAmJiAhZWxlbWVudERhdGEuc2FuaXRpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvU2FuaXRpemUucHVzaChlbFRleHQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50RGF0YS5zYW5pdGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG1lbnVGcmFnbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zYW5pdGl6ZSAmJiB0b1Nhbml0aXplLmxlbmd0aCkge1xuICAgICAgICAgICAgICBzYW5pdGl6ZUh0bWwodG9TYW5pdGl6ZSwgdGhhdC5vcHRpb25zLndoaXRlTGlzdCwgdGhhdC5vcHRpb25zLnNhbml0aXplRm4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNWaXJ0dWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9ICh0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCA9PT0gMCA/IDAgOiB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjAgLSAxXS5wb3NpdGlvbik7XG4gICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9ICh0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMSA+IHNpemUgLSAxID8gMCA6IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtzaXplIC0gMV0ucG9zaXRpb24gLSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjEgLSAxXS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuc3R5bGUubWFyZ2luVG9wID0gbWFyZ2luVG9wICsgJ3B4JztcbiAgICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuc3R5bGUubWFyZ2luQm90dG9tID0gbWFyZ2luQm90dG9tICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1lbnVJbm5lci5maXJzdENoaWxkLnN0eWxlLm1hcmdpblRvcCA9IDA7XG4gICAgICAgICAgICAgIG1lbnVJbm5lci5maXJzdENoaWxkLnN0eWxlLm1hcmdpbkJvdHRvbSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lbnVJbm5lci5maXJzdENoaWxkLmFwcGVuZENoaWxkKG1lbnVGcmFnbWVudCk7XG5cbiAgICAgICAgICAgIC8vIGlmIGFuIG9wdGlvbiBpcyBlbmNvdW50ZXJlZCB0aGF0IGlzIHdpZGVyIHRoYW4gdGhlIGN1cnJlbnQgbWVudSB3aWR0aCwgdXBkYXRlIHRoZSBtZW51IHdpZHRoIGFjY29yZGluZ2x5XG4gICAgICAgICAgICAvLyBzd2l0Y2ggdG8gUmVzaXplT2JzZXJ2ZXIgd2l0aCBpbmNyZWFzZWQgYnJvd3NlciBzdXBwb3J0XG4gICAgICAgICAgICBpZiAoaXNWaXJ0dWFsID09PSB0cnVlICYmIHRoYXQuc2l6ZUluZm8uaGFzU2Nyb2xsQmFyKSB7XG4gICAgICAgICAgICAgIHZhciBtZW51SW5uZXJJbm5lcldpZHRoID0gbWVudUlubmVyLmZpcnN0Q2hpbGQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgICAgICAgaWYgKGluaXQgJiYgbWVudUlubmVySW5uZXJXaWR0aCA8IHRoYXQuc2l6ZUluZm8ubWVudUlubmVySW5uZXJXaWR0aCAmJiB0aGF0LnNpemVJbmZvLnRvdGFsTWVudVdpZHRoID4gdGhhdC5zaXplSW5mby5zZWxlY3RXaWR0aCkge1xuICAgICAgICAgICAgICAgIG1lbnVJbm5lci5maXJzdENoaWxkLnN0eWxlLm1pbldpZHRoID0gdGhhdC5zaXplSW5mby5tZW51SW5uZXJJbm5lcldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZW51SW5uZXJJbm5lcldpZHRoID4gdGhhdC5zaXplSW5mby5tZW51SW5uZXJJbm5lcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHRvIDAgdG8gZ2V0IGFjdHVhbCB3aWR0aCBvZiBtZW51XG4gICAgICAgICAgICAgICAgdGhhdC4kbWVudVswXS5zdHlsZS5taW5XaWR0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWN0dWFsTWVudVdpZHRoID0gbWVudUlubmVyLmZpcnN0Q2hpbGQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWN0dWFsTWVudVdpZHRoID4gdGhhdC5zaXplSW5mby5tZW51SW5uZXJJbm5lcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICB0aGF0LnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGggPSBhY3R1YWxNZW51V2lkdGg7XG4gICAgICAgICAgICAgICAgICBtZW51SW5uZXIuZmlyc3RDaGlsZC5zdHlsZS5taW5XaWR0aCA9IHRoYXQuc2l6ZUluZm8ubWVudUlubmVySW5uZXJXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdG8gZGVmYXVsdCBDU1Mgc3R5bGluZ1xuICAgICAgICAgICAgICAgIHRoYXQuJG1lbnVbMF0uc3R5bGUubWluV2lkdGggPSAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgoIWlzU2VhcmNoaW5nICYmIHRoYXQub3B0aW9ucy5zb3VyY2UuZGF0YSB8fCBpc1NlYXJjaGluZyAmJiB0aGF0Lm9wdGlvbnMuc291cmNlLnNlYXJjaCkgJiYgdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5oYXNNb3JlICYmIGN1cnJlbnRDaHVuayA9PT0gY2h1bmtDb3VudCAtIDEpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGxvYWQgdGhlIG5leHQgY2h1bmsgdW50aWwgc2Nyb2xsaW5nIGhhcyBzdGFydGVkXG4gICAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHVubmVjZXNzYXJ5IHJlcXVlc3RzIHdoaWxlIHRoZSB1c2VyIGlzIHR5cGluZyBpZiBwYWdlU2l6ZSBpcyA8PSBjaHVua1NpemVcbiAgICAgICAgICAgIGlmIChzY3JvbGxUb3AgPiAwKSB7XG4gICAgICAgICAgICAgIC8vIENodW5rcyB1c2UgMC1iYXNlZCBpbmRleGluZywgYnV0IHBhZ2VzIHVzZSAxLWJhc2VkLiBBZGQgMSB0byBjb252ZXJ0IGFuZCBhZGQgMSBhZ2FpbiB0byBnZXQgbmV4dCBwYWdlXG4gICAgICAgICAgICAgIHZhciBwYWdlID0gTWF0aC5mbG9vcigoY3VycmVudENodW5rICogdGhhdC5vcHRpb25zLmNodW5rU2l6ZSkgLyB0aGF0Lm9wdGlvbnMuc291cmNlLnBhZ2VTaXplKSArIDI7XG5cbiAgICAgICAgICAgICAgdGhhdC5mZXRjaERhdGEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhhdC5idWlsZExpc3Qoc2l6ZSwgaXNTZWFyY2hpbmcpO1xuICAgICAgICAgICAgICAgIHRoYXQuc2V0UG9zaXRpb25EYXRhKCk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsKHNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgIH0sIGlzU2VhcmNoaW5nID8gJ3NlYXJjaCcgOiAnZGF0YScsIHBhZ2UsIGlzU2VhcmNoaW5nID8gdGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLnByZXZpb3VzVmFsdWUgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQucHJldkFjdGl2ZUVsZW1lbnQgPSB0aGF0LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCF0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xuICAgICAgICAgIHRoYXQuJG1lbnVJbm5lci50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU2VhcmNoaW5nICYmIGluaXQpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICBuZXdBY3RpdmU7XG5cbiAgICAgICAgICBpZiAoIXRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0W2luZGV4XSkge1xuICAgICAgICAgICAgaW5kZXggPSAxICsgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5jYW5IaWdobGlnaHQuc2xpY2UoMSkuaW5kZXhPZih0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdBY3RpdmUgPSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnZpc2libGVFbGVtZW50c1tpbmRleF07XG5cbiAgICAgICAgICB0aGF0LmRlZm9jdXNJdGVtKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY3VycmVudEFjdGl2ZSk7XG5cbiAgICAgICAgICB0aGF0LmFjdGl2ZUVsZW1lbnQgPSAodGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2luZGV4XSB8fCB7fSkuZWxlbWVudDtcblxuICAgICAgICAgIHRoYXQuZm9jdXNJdGVtKG5ld0FjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgJCh3aW5kb3cpXG4gICAgICAgIC5vZmYoJ3Jlc2l6ZScgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5jcmVhdGVWaWV3JylcbiAgICAgICAgLm9uKCdyZXNpemUnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuY3JlYXRlVmlldycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaXNBY3RpdmUgPSB0aGF0LiRuZXdFbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZXMuU0hPVyk7XG5cbiAgICAgICAgICBpZiAoaXNBY3RpdmUpIHNjcm9sbCh0aGF0LiRtZW51SW5uZXJbMF0uc2Nyb2xsVG9wKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZvY3VzSXRlbTogZnVuY3Rpb24gKGxpLCBsaURhdGEsIG5vU3R5bGUpIHtcbiAgICAgIGlmIChsaSkge1xuICAgICAgICBsaURhdGEgPSBsaURhdGEgfHwgdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW3RoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMuaW5kZXhPZih0aGlzLmFjdGl2ZUVsZW1lbnQpXTtcbiAgICAgICAgdmFyIGEgPSBsaS5maXJzdENoaWxkO1xuXG4gICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2V0c2l6ZScsIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuc2l6ZSk7XG4gICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2FyaWEtcG9zaW5zZXQnLCBsaURhdGEucG9zaW5zZXQpO1xuXG4gICAgICAgICAgaWYgKG5vU3R5bGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNlZFBhcmVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIGEuaWQpO1xuICAgICAgICAgICAgbGkuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICBhLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWZvY3VzSXRlbTogZnVuY3Rpb24gKGxpKSB7XG4gICAgICBpZiAobGkpIHtcbiAgICAgICAgbGkuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIGlmIChsaS5maXJzdENoaWxkKSBsaS5maXJzdENoaWxkLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRQbGFjZWhvbGRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIHVwZGF0ZUluZGV4ID0gZmFsc2U7XG5cbiAgICAgIGlmICgodGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyIHx8IHRoaXMub3B0aW9ucy5hbGxvd0NsZWFyKSAmJiAhdGhpcy5tdWx0aXBsZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0cGlja2VyLnZpZXcudGl0bGVPcHRpb24pIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcudGl0bGVPcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcblxuICAgICAgICAvLyB0aGlzIG9wdGlvbiBkb2Vzbid0IGNyZWF0ZSBhIG5ldyA8bGk+IGVsZW1lbnQsIGJ1dCBkb2VzIGFkZCBhIG5ldyBvcHRpb24gYXQgdGhlIHN0YXJ0LFxuICAgICAgICAvLyBzbyBzdGFydEluZGV4IHNob3VsZCBpbmNyZWFzZSB0byBwcmV2ZW50IGhhdmluZyB0byBjaGVjayBldmVyeSBvcHRpb24gZm9yIHRoZSBicy10aXRsZS1vcHRpb24gY2xhc3NcbiAgICAgICAgdXBkYXRlSW5kZXggPSB0cnVlO1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy4kZWxlbWVudFswXSxcbiAgICAgICAgICAgIHNlbGVjdFRpdGxlT3B0aW9uID0gZmFsc2UsXG4gICAgICAgICAgICB0aXRsZU5vdEFwcGVuZGVkID0gIXRoaXMuc2VsZWN0cGlja2VyLnZpZXcudGl0bGVPcHRpb24ucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBlbGVtZW50LnNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICBzZWxlY3RlZE9wdGlvbiA9IGVsZW1lbnQub3B0aW9uc1tzZWxlY3RlZEluZGV4XSxcbiAgICAgICAgICAgIGZpcnN0U2VsZWN0YWJsZSA9IGVsZW1lbnQucXVlcnlTZWxlY3Rvcignc2VsZWN0ID4gKjpub3QoOmRpc2FibGVkKScpLFxuICAgICAgICAgICAgZmlyc3RTZWxlY3RhYmxlSW5kZXggPSBmaXJzdFNlbGVjdGFibGUgPyBmaXJzdFNlbGVjdGFibGUuaW5kZXggOiAwLFxuICAgICAgICAgICAgbmF2aWdhdGlvbiA9IHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5VHlwZSgnbmF2aWdhdGlvbicpLFxuICAgICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCBnZXRFbnRyaWVzQnlUeXBlKCduYXZpZ2F0aW9uJykgLSBmYWxsIGJhY2sgdG8gcGVyZm9ybWFuY2UubmF2aWdhdGlvblxuICAgICAgICAgICAgaXNOb3RCYWNrRm9yd2FyZCA9IChuYXZpZ2F0aW9uICYmIG5hdmlnYXRpb24ubGVuZ3RoKSA/IG5hdmlnYXRpb25bMF0udHlwZSAhPT0gJ2JhY2tfZm9yd2FyZCcgOiB3aW5kb3cucGVyZm9ybWFuY2UubmF2aWdhdGlvbi50eXBlICE9PSAyO1xuXG4gICAgICAgIGlmICh0aXRsZU5vdEFwcGVuZGVkKSB7XG4gICAgICAgICAgLy8gVXNlIG5hdGl2ZSBKUyB0byBwcmVwZW5kIG9wdGlvbiAoZmFzdGVyKVxuICAgICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcudGl0bGVPcHRpb24uY2xhc3NOYW1lID0gJ2JzLXRpdGxlLW9wdGlvbic7XG4gICAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbi52YWx1ZSA9ICcnO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgc2VsZWN0ZWQgb3IgZGF0YS1zZWxlY3RlZCBhdHRyaWJ1dGUgaXMgYWxyZWFkeSBzZXQgb24gYW4gb3B0aW9uLiBJZiBub3QsIHNlbGVjdCB0aGUgdGl0bGVPcHRpb24gb3B0aW9uLlxuICAgICAgICAgIC8vIHRoZSBzZWxlY3RlZCBpdGVtIG1heSBoYXZlIGJlZW4gY2hhbmdlZCBieSB1c2VyIG9yIHByb2dyYW1tYXRpY2FsbHkgYmVmb3JlIHRoZSBib290c3RyYXAgc2VsZWN0IHBsdWdpbiBydW5zLFxuICAgICAgICAgIC8vIGlmIHNvLCB0aGUgc2VsZWN0IHdpbGwgaGF2ZSB0aGUgZGF0YS1zZWxlY3RlZCBhdHRyaWJ1dGVcbiAgICAgICAgICBzZWxlY3RUaXRsZU9wdGlvbiA9ICFzZWxlY3RlZE9wdGlvbiB8fCAoc2VsZWN0ZWRJbmRleCA9PT0gZmlyc3RTZWxlY3RhYmxlSW5kZXggJiYgc2VsZWN0ZWRPcHRpb24uZGVmYXVsdFNlbGVjdGVkID09PSBmYWxzZSAmJiB0aGlzLiRlbGVtZW50LmRhdGEoJ3NlbGVjdGVkJykgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGl0bGVOb3RBcHBlbmRlZCB8fCB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLmluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbiwgZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBzZWxlY3RlZCAqYWZ0ZXIqIGFwcGVuZGluZyB0byBzZWxlY3QsXG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGUgb3B0aW9uIGRvZXNuJ3QgZ2V0IHNlbGVjdGVkIGluIElFXG4gICAgICAgIC8vIHNldCB1c2luZyBzZWxlY3RlZEluZGV4LCBhcyBzZXR0aW5nIHRoZSBzZWxlY3RlZCBhdHRyIHRvIHRydWUgaGVyZSBkb2Vzbid0IHdvcmsgaW4gSUUxMVxuICAgICAgICBpZiAoc2VsZWN0VGl0bGVPcHRpb24gJiYgaXNOb3RCYWNrRm9yd2FyZCkge1xuICAgICAgICAgIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgIC8vIGlmIG5hdmlnYXRpb24gdHlwZSBpcyBiYWNrX2ZvcndhcmQsIHRoZXJlJ3MgYSBjaGFuY2UgdGhlIHNlbGVjdCB3aWxsIGhhdmUgaXRzIHZhbHVlIHNldCBieSBCRkNhY2hlXG4gICAgICAgICAgLy8gd2FpdCBmb3IgdGhhdCB2YWx1ZSB0byBiZSBzZXQsIHRoZW4gcnVuIHJlbmRlciBhZ2FpblxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGF0LnNlbGVjdHBpY2tlci52aWV3LmRpc3BsYXllZFZhbHVlICE9PSBlbGVtZW50LnZhbHVlKSB0aGF0LnJlbmRlcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVJbmRleDtcbiAgICB9LFxuXG4gICAgZmV0Y2hEYXRhOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHR5cGUsIHBhZ2UsIHNlYXJjaFZhbHVlKSB7XG4gICAgICBwYWdlID0gcGFnZSB8fCAxO1xuICAgICAgdHlwZSA9IHR5cGUgfHwgJ2RhdGEnO1xuXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgZGF0YSA9IHRoaXMub3B0aW9ucy5zb3VyY2VbdHlwZV0sXG4gICAgICAgICAgYnVpbHREYXRhO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmlydHVhbFNjcm9sbCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGF0YS5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkYXRhLCBtb3JlLCB0b3RhbEl0ZW1zKSB7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhhdC5zZWxlY3RwaWNrZXJbdHlwZSA9PT0gJ3NlYXJjaCcgPyAnc2VhcmNoJyA6ICdtYWluJ107XG4gICAgICAgICAgICAgIGN1cnJlbnQuaGFzTW9yZSA9IG1vcmU7XG4gICAgICAgICAgICAgIGN1cnJlbnQudG90YWxJdGVtcyA9IHRvdGFsSXRlbXM7XG4gICAgICAgICAgICAgIGJ1aWx0RGF0YSA9IHRoYXQuYnVpbGREYXRhKGRhdGEsIHR5cGUpO1xuICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoYXQsIGJ1aWx0RGF0YSk7XG4gICAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZmV0Y2hlZCcgKyBFVkVOVF9LRVkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgICBzZWFyY2hWYWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgIGJ1aWx0RGF0YSA9IHRoYXQuYnVpbGREYXRhKGRhdGEsIHR5cGUpO1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhhdCwgYnVpbHREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVpbHREYXRhID0gdGhpcy5idWlsZERhdGEoZmFsc2UsIHR5cGUpO1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoYXQsIGJ1aWx0RGF0YSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGJ1aWxkRGF0YTogZnVuY3Rpb24gKGRhdGEsIHR5cGUpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBkYXRhR2V0dGVyID0gZGF0YSA9PT0gZmFsc2UgPyBnZXRPcHRpb25EYXRhLmZyb21PcHRpb24gOiBnZXRPcHRpb25EYXRhLmZyb21EYXRhU291cmNlO1xuXG4gICAgICB2YXIgb3B0aW9uU2VsZWN0b3IgPSAnOm5vdChbaGlkZGVuXSk6bm90KFtkYXRhLWhpZGRlbj1cInRydWVcIl0pOm5vdChbc3R5bGUqPVwiZGlzcGxheTogbm9uZVwiXSknLFxuICAgICAgICAgIG1haW5EYXRhID0gW10sXG4gICAgICAgICAgc3RhcnRMZW4gPSB0aGlzLnNlbGVjdHBpY2tlci5tYWluLmRhdGEgPyB0aGlzLnNlbGVjdHBpY2tlci5tYWluLmRhdGEubGVuZ3RoIDogMCxcbiAgICAgICAgICBvcHRJRCA9IDAsXG4gICAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuc2V0UGxhY2Vob2xkZXIoKSAmJiAhZGF0YSA/IDEgOiAwOyAvLyBhcHBlbmQgdGhlIHRpdGxlT3B0aW9uIGlmIG5lY2Vzc2FyeSBhbmQgc2tpcCB0aGUgZmlyc3Qgb3B0aW9uIGluIHRoZSBsb29wXG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VhcmNoJykge1xuICAgICAgICBzdGFydExlbiA9IHRoaXMuc2VsZWN0cGlja2VyLnNlYXJjaC5kYXRhLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWRlRGlzYWJsZWQpIG9wdGlvblNlbGVjdG9yICs9ICc6bm90KDpkaXNhYmxlZCknO1xuXG4gICAgICB2YXIgc2VsZWN0T3B0aW9ucyA9IGRhdGEgPyBkYXRhLmZpbHRlcihmaWx0ZXJIaWRkZW4sIHRoaXMpIDogdGhpcy4kZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QgPiAqJyArIG9wdGlvblNlbGVjdG9yKTtcblxuICAgICAgZnVuY3Rpb24gYWRkRGl2aWRlciAoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcmV2aW91c0RhdGEgPSBtYWluRGF0YVttYWluRGF0YS5sZW5ndGggLSAxXTtcblxuICAgICAgICAvLyBlbnN1cmUgb3B0Z3JvdXAgZG9lc24ndCBjcmVhdGUgYmFjay10by1iYWNrIGRpdmlkZXJzXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcmV2aW91c0RhdGEgJiZcbiAgICAgICAgICBwcmV2aW91c0RhdGEudHlwZSA9PT0gJ2RpdmlkZXInICYmXG4gICAgICAgICAgKHByZXZpb3VzRGF0YS5vcHRJRCB8fCBjb25maWcub3B0SUQpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgY29uZmlnLnR5cGUgPSAnZGl2aWRlcic7XG5cbiAgICAgICAgbWFpbkRhdGEucHVzaChjb25maWcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRPcHRpb24gKGl0ZW0sIGNvbmZpZykge1xuICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICAgICAgY29uZmlnLmRpdmlkZXIgPSBkYXRhR2V0dGVyKGl0ZW0sICdkaXZpZGVyJyk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5kaXZpZGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgYWRkRGl2aWRlcih7XG4gICAgICAgICAgICBvcHRJRDogY29uZmlnLm9wdElEXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGxpSW5kZXggPSBtYWluRGF0YS5sZW5ndGggKyBzdGFydExlbixcbiAgICAgICAgICAgICAgY3NzVGV4dCA9IGRhdGFHZXR0ZXIoaXRlbSwgJ3N0eWxlJyksXG4gICAgICAgICAgICAgIGlubGluZVN0eWxlID0gY3NzVGV4dCA/IGh0bWxFc2NhcGUoY3NzVGV4dCkgOiAnJyxcbiAgICAgICAgICAgICAgb3B0aW9uQ2xhc3MgPSAoaXRlbS5jbGFzc05hbWUgfHwgJycpICsgKGNvbmZpZy5vcHRncm91cENsYXNzIHx8ICcnKTtcblxuICAgICAgICAgIGlmIChjb25maWcub3B0SUQpIG9wdGlvbkNsYXNzID0gJ29wdCAnICsgb3B0aW9uQ2xhc3M7XG5cbiAgICAgICAgICBjb25maWcub3B0aW9uQ2xhc3MgPSBvcHRpb25DbGFzcy50cmltKCk7XG4gICAgICAgICAgY29uZmlnLmlubGluZVN0eWxlID0gaW5saW5lU3R5bGU7XG5cbiAgICAgICAgICBjb25maWcudGV4dCA9IGRhdGFHZXR0ZXIoaXRlbSwgJ3RleHQnKTtcbiAgICAgICAgICBjb25maWcudGl0bGUgPSBkYXRhR2V0dGVyKGl0ZW0sICd0aXRsZScpO1xuICAgICAgICAgIGNvbmZpZy5jb250ZW50ID0gZGF0YUdldHRlcihpdGVtLCAnY29udGVudCcpO1xuICAgICAgICAgIGNvbmZpZy50b2tlbnMgPSBkYXRhR2V0dGVyKGl0ZW0sICd0b2tlbnMnKTtcbiAgICAgICAgICBjb25maWcuc3VidGV4dCA9IGRhdGFHZXR0ZXIoaXRlbSwgJ3N1YnRleHQnKTtcbiAgICAgICAgICBjb25maWcuaWNvbiA9IGRhdGFHZXR0ZXIoaXRlbSwgJ2ljb24nKTtcblxuICAgICAgICAgIGNvbmZpZy5kaXNwbGF5ID0gY29uZmlnLmNvbnRlbnQgfHwgY29uZmlnLnRleHQ7XG4gICAgICAgICAgY29uZmlnLnZhbHVlID0gaXRlbS52YWx1ZSA9PT0gdW5kZWZpbmVkID8gaXRlbS50ZXh0IDogaXRlbS52YWx1ZTtcbiAgICAgICAgICBjb25maWcudHlwZSA9ICdvcHRpb24nO1xuICAgICAgICAgIGNvbmZpZy5pbmRleCA9IGxpSW5kZXg7XG5cbiAgICAgICAgICBjb25maWcub3B0aW9uID0gIWl0ZW0ub3B0aW9uID8gaXRlbSA6IGl0ZW0ub3B0aW9uOyAvLyByZWZlcmVuY2Ugb3B0aW9uIGVsZW1lbnQgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgY29uZmlnLm9wdGlvbi5saUluZGV4ID0gbGlJbmRleDtcbiAgICAgICAgICBjb25maWcuc2VsZWN0ZWQgPSAhIWl0ZW0uc2VsZWN0ZWQ7XG4gICAgICAgICAgY29uZmlnLmRpc2FibGVkID0gY29uZmlnLmRpc2FibGVkIHx8ICEhaXRlbS5kaXNhYmxlZDtcblxuICAgICAgICAgIGlmIChkYXRhICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0cGlja2VyLm9wdGlvblZhbHVlc0RhdGFNYXBbY29uZmlnLnZhbHVlXSkge1xuICAgICAgICAgICAgICBjb25maWcgPSAkLmV4dGVuZCh0aGF0LnNlbGVjdHBpY2tlci5vcHRpb25WYWx1ZXNEYXRhTWFwW2NvbmZpZy52YWx1ZV0sIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci5vcHRpb25WYWx1ZXNEYXRhTWFwW2NvbmZpZy52YWx1ZV0gPSBjb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWFpbkRhdGEucHVzaChjb25maWcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE9wdGdyb3VwIChpbmRleCwgc2VsZWN0T3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0Z3JvdXAgPSBzZWxlY3RPcHRpb25zW2luZGV4XSxcbiAgICAgICAgICAgIC8vIHNraXAgcGxhY2Vob2xkZXIgb3B0aW9uXG4gICAgICAgICAgICBwcmV2aW91cyA9IGluZGV4IC0gMSA8IHN0YXJ0SW5kZXggPyBmYWxzZSA6IHNlbGVjdE9wdGlvbnNbaW5kZXggLSAxXSxcbiAgICAgICAgICAgIG5leHQgPSBzZWxlY3RPcHRpb25zW2luZGV4ICsgMV0sXG4gICAgICAgICAgICBvcHRpb25zID0gZGF0YSA/IG9wdGdyb3VwLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXJIaWRkZW4sIHRoaXMpIDogb3B0Z3JvdXAucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uJyArIG9wdGlvblNlbGVjdG9yKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogaHRtbEVzY2FwZShkYXRhR2V0dGVyKGl0ZW0sICdsYWJlbCcpKSxcbiAgICAgICAgICAgICAgc3VidGV4dDogZGF0YUdldHRlcihvcHRncm91cCwgJ3N1YnRleHQnKSxcbiAgICAgICAgICAgICAgaWNvbjogZGF0YUdldHRlcihvcHRncm91cCwgJ2ljb24nKSxcbiAgICAgICAgICAgICAgdHlwZTogJ29wdGdyb3VwLWxhYmVsJyxcbiAgICAgICAgICAgICAgb3B0Z3JvdXBDbGFzczogJyAnICsgKG9wdGdyb3VwLmNsYXNzTmFtZSB8fCAnJyksXG4gICAgICAgICAgICAgIG9wdGdyb3VwOiBvcHRncm91cFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlYWRlckluZGV4LFxuICAgICAgICAgICAgbGFzdEluZGV4O1xuXG4gICAgICAgIG9wdElEKys7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgICAgYWRkRGl2aWRlcih7IG9wdElEOiBvcHRJRCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5vcHRJRCA9IG9wdElEO1xuXG4gICAgICAgIG1haW5EYXRhLnB1c2goY29uZmlnKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gb3B0aW9ucy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIHZhciBvcHRpb24gPSBvcHRpb25zW2pdO1xuXG4gICAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAgIGhlYWRlckluZGV4ID0gbWFpbkRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IGhlYWRlckluZGV4ICsgbGVuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFkZE9wdGlvbihvcHRpb24sIHtcbiAgICAgICAgICAgIGhlYWRlckluZGV4OiBoZWFkZXJJbmRleCxcbiAgICAgICAgICAgIGxhc3RJbmRleDogbGFzdEluZGV4LFxuICAgICAgICAgICAgb3B0SUQ6IGNvbmZpZy5vcHRJRCxcbiAgICAgICAgICAgIG9wdGdyb3VwQ2xhc3M6IGNvbmZpZy5vcHRncm91cENsYXNzLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IG9wdGdyb3VwLmRpc2FibGVkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIGFkZERpdmlkZXIoeyBvcHRJRDogb3B0SUQgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbGVuID0gc2VsZWN0T3B0aW9ucy5sZW5ndGgsIGkgPSBzdGFydEluZGV4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBzZWxlY3RPcHRpb25zW2ldLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBpdGVtLmNoaWxkcmVuO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICBhZGRPcHRncm91cC5jYWxsKHRoaXMsIGksIHNlbGVjdE9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZE9wdGlvbi5jYWxsKHRoaXMsIGl0ZW0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZGF0YSc6IHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YSwgbWFpbkRhdGEpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YSA9IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzZWFyY2gnOiB7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5zZWxlY3RwaWNrZXIuc2VhcmNoLmRhdGEsIG1haW5EYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFpbkRhdGE7XG4gICAgfSxcblxuICAgIGJ1aWxkTGlzdDogZnVuY3Rpb24gKHNpemUsIHNlYXJjaGluZykge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIHNlbGVjdERhdGEgPSBzZWFyY2hpbmcgPyB0aGlzLnNlbGVjdHBpY2tlci5zZWFyY2guZGF0YSA6IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YSxcbiAgICAgICAgICBtYWluRWxlbWVudHMgPSBbXSxcbiAgICAgICAgICB3aWRlc3RPcHRpb25MZW5ndGggPSAwO1xuXG4gICAgICBpZiAoKHRoYXQub3B0aW9ucy5zaG93VGljayB8fCB0aGF0Lm11bHRpcGxlKSAmJiAhZWxlbWVudFRlbXBsYXRlcy5jaGVja01hcmsucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmNoZWNrTWFyay5jbGFzc05hbWUgPSB0aGlzLm9wdGlvbnMuaWNvbkJhc2UgKyAnICcgKyB0aGF0Lm9wdGlvbnMudGlja0ljb24gKyAnIGNoZWNrLW1hcmsnO1xuICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmEuYXBwZW5kQ2hpbGQoZWxlbWVudFRlbXBsYXRlcy5jaGVja01hcmspO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZEVsZW1lbnQgKG1haW5FbGVtZW50cywgaXRlbSkge1xuICAgICAgICB2YXIgbGlFbGVtZW50LFxuICAgICAgICAgICAgY29tYmluZWRMZW5ndGggPSAwO1xuXG4gICAgICAgIHN3aXRjaCAoaXRlbS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZGl2aWRlcic6XG4gICAgICAgICAgICBsaUVsZW1lbnQgPSBnZW5lcmF0ZU9wdGlvbi5saShcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZXMuRElWSURFUixcbiAgICAgICAgICAgICAgKGl0ZW0ub3B0SUQgPyBpdGVtLm9wdElEICsgJ2RpdicgOiB1bmRlZmluZWQpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgICAgICBsaUVsZW1lbnQgPSBnZW5lcmF0ZU9wdGlvbi5saShcbiAgICAgICAgICAgICAgZ2VuZXJhdGVPcHRpb24uYShcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZU9wdGlvbi50ZXh0LmNhbGwodGhhdCwgaXRlbSksXG4gICAgICAgICAgICAgICAgaXRlbS5vcHRpb25DbGFzcyxcbiAgICAgICAgICAgICAgICBpdGVtLmlubGluZVN0eWxlXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICBpdGVtLm9wdElEXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAobGlFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgbGlFbGVtZW50LmZpcnN0Q2hpbGQuaWQgPSB0aGF0LnNlbGVjdElkICsgJy0nICsgaXRlbS5pbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdvcHRncm91cC1sYWJlbCc6XG4gICAgICAgICAgICBsaUVsZW1lbnQgPSBnZW5lcmF0ZU9wdGlvbi5saShcbiAgICAgICAgICAgICAgZ2VuZXJhdGVPcHRpb24ubGFiZWwuY2FsbCh0aGF0LCBpdGVtKSxcbiAgICAgICAgICAgICAgJ2Ryb3Bkb3duLWhlYWRlcicgKyBpdGVtLm9wdGdyb3VwQ2xhc3MsXG4gICAgICAgICAgICAgIGl0ZW0ub3B0SURcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpdGVtLmVsZW1lbnQpIHtcbiAgICAgICAgICBpdGVtLmVsZW1lbnQgPSBsaUVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5lbGVtZW50LmlubmVySFRNTCA9IGxpRWxlbWVudC5pbm5lckhUTUw7XG4gICAgICAgIH1cbiAgICAgICAgbWFpbkVsZW1lbnRzLnB1c2goaXRlbS5lbGVtZW50KTtcblxuICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gdGhlIG9wdGlvbiAtIG5vdCBwZXJmZWN0LCBidXQgc2hvdWxkIHdvcmsgaW4gbW9zdCBjYXNlc1xuICAgICAgICBpZiAoaXRlbS5kaXNwbGF5KSBjb21iaW5lZExlbmd0aCArPSBpdGVtLmRpc3BsYXkubGVuZ3RoO1xuICAgICAgICBpZiAoaXRlbS5zdWJ0ZXh0KSBjb21iaW5lZExlbmd0aCArPSBpdGVtLnN1YnRleHQubGVuZ3RoO1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbiBpY29uLCBlbnN1cmUgdGhpcyBvcHRpb24ncyB3aWR0aCBpcyBjaGVja2VkXG4gICAgICAgIGlmIChpdGVtLmljb24pIGNvbWJpbmVkTGVuZ3RoICs9IDE7XG5cbiAgICAgICAgaWYgKGNvbWJpbmVkTGVuZ3RoID4gd2lkZXN0T3B0aW9uTGVuZ3RoKSB7XG4gICAgICAgICAgd2lkZXN0T3B0aW9uTGVuZ3RoID0gY29tYmluZWRMZW5ndGg7XG5cbiAgICAgICAgICAvLyBndWVzcyB3aGljaCBvcHRpb24gaXMgdGhlIHdpZGVzdFxuICAgICAgICAgIC8vIHVzZSB0aGlzIHdoZW4gY2FsY3VsYXRpbmcgbWVudSB3aWR0aFxuICAgICAgICAgIC8vIG5vdCBwZXJmZWN0LCBidXQgaXQncyBmYXN0LCBhbmQgdGhlIHdpZHRoIHdpbGwgYmUgdXBkYXRpbmcgYWNjb3JkaW5nbHkgd2hlbiBzY3JvbGxpbmdcbiAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LndpZGVzdE9wdGlvbiA9IG1haW5FbGVtZW50c1ttYWluRWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBzaXplIHx8IDA7XG5cbiAgICAgIGZvciAodmFyIGxlbiA9IHNlbGVjdERhdGEubGVuZ3RoLCBpID0gc3RhcnRJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gc2VsZWN0RGF0YVtpXTtcblxuICAgICAgICBidWlsZEVsZW1lbnQobWFpbkVsZW1lbnRzLCBpdGVtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgaWYgKHNlYXJjaGluZykge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuc2VsZWN0cGlja2VyLnNlYXJjaC5lbGVtZW50cywgbWFpbkVsZW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnNlbGVjdHBpY2tlci5tYWluLmVsZW1lbnRzLCBtYWluRWxlbWVudHMpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMgPSB0aGlzLnNlbGVjdHBpY2tlci5tYWluLmVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2VhcmNoaW5nKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIuc2VhcmNoLmVsZW1lbnRzID0gbWFpbkVsZW1lbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHMgPSB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmVsZW1lbnRzID0gbWFpbkVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbmRMaXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRtZW51SW5uZXIuZmluZCgnLmlubmVyID4gbGknKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoaW5pdCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLiRlbGVtZW50WzBdLFxuICAgICAgICAgIC8vIGVuc3VyZSB0aXRsZU9wdGlvbiBpcyBhcHBlbmRlZCBhbmQgc2VsZWN0ZWQgKGlmIG5lY2Vzc2FyeSkgYmVmb3JlIGdldHRpbmcgc2VsZWN0ZWRPcHRpb25zXG4gICAgICAgICAgcGxhY2Vob2xkZXJTZWxlY3RlZCA9IHRoaXMuc2V0UGxhY2Vob2xkZXIoKSAmJiBlbGVtZW50LnNlbGVjdGVkSW5kZXggPT09IDAsXG4gICAgICAgICAgc2VsZWN0ZWRPcHRpb25zID0gZ2V0U2VsZWN0ZWRPcHRpb25zLmNhbGwodGhpcyksXG4gICAgICAgICAgc2VsZWN0ZWRDb3VudCA9IHNlbGVjdGVkT3B0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRTZWxlY3RWYWx1ZXMuY2FsbCh0aGlzLCBzZWxlY3RlZE9wdGlvbnMpLFxuICAgICAgICAgIGJ1dHRvbiA9IHRoaXMuJGJ1dHRvblswXSxcbiAgICAgICAgICBidXR0b25Jbm5lciA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcuZmlsdGVyLW9wdGlvbi1pbm5lci1pbm5lcicpLFxuICAgICAgICAgIG11bHRpcGxlU2VwYXJhdG9yID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5vcHRpb25zLm11bHRpcGxlU2VwYXJhdG9yKSxcbiAgICAgICAgICB0aXRsZUZyYWdtZW50ID0gZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudC5jbG9uZU5vZGUoZmFsc2UpLFxuICAgICAgICAgIHNob3dDb3VudCxcbiAgICAgICAgICBjb3VudE1heCxcbiAgICAgICAgICBoYXNDb250ZW50ID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdGVkIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtLnNlbGVjdGVkKSB7XG4gICAgICAgICAgdGhhdC5jcmVhdGVPcHRpb24oaXRlbSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5jaGlsZHJlbiAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIGl0ZW0uY2hpbGRyZW4ubWFwKGNyZWF0ZVNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzIHRvIGVuc3VyZSBzZWxlY3QgdmFsdWUgaXMgY29ycmVjdFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2UuZGF0YSAmJiBpbml0KSB7XG4gICAgICAgIHNlbGVjdGVkT3B0aW9ucy5tYXAoY3JlYXRlU2VsZWN0ZWQpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2VsZWN0cGlja2VyLm1haW4ub3B0aW9uUXVldWUpO1xuXG4gICAgICAgIGlmIChwbGFjZWhvbGRlclNlbGVjdGVkKSBwbGFjZWhvbGRlclNlbGVjdGVkID0gZWxlbWVudC5zZWxlY3RlZEluZGV4ID09PSAwO1xuICAgICAgfVxuXG4gICAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZSgnYnMtcGxhY2Vob2xkZXInLCB0aGF0Lm11bHRpcGxlID8gIXNlbGVjdGVkQ291bnQgOiAhc2VsZWN0ZWRWYWx1ZXMgJiYgc2VsZWN0ZWRWYWx1ZXMgIT09IDApO1xuXG4gICAgICBpZiAoIXRoYXQubXVsdGlwbGUgJiYgc2VsZWN0ZWRPcHRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmRpc3BsYXllZFZhbHVlID0gc2VsZWN0ZWRWYWx1ZXM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0ZWRUZXh0Rm9ybWF0ID09PSAnc3RhdGljJykge1xuICAgICAgICB0aXRsZUZyYWdtZW50ID0gZ2VuZXJhdGVPcHRpb24udGV4dC5jYWxsKHRoaXMsIHsgdGV4dDogdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyIH0sIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hvd0NvdW50ID0gdGhpcy5tdWx0aXBsZSAmJiB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRUZXh0Rm9ybWF0LmluZGV4T2YoJ2NvdW50JykgIT09IC0xICYmIHNlbGVjdGVkQ291bnQgPiAwO1xuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIG9wdGlvbnMgd2lsbCBiZSBzaG93biAoc2hvd0NvdW50ID09PSB0cnVlKVxuICAgICAgICBpZiAoc2hvd0NvdW50KSB7XG4gICAgICAgICAgY291bnRNYXggPSB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRUZXh0Rm9ybWF0LnNwbGl0KCc+Jyk7XG4gICAgICAgICAgc2hvd0NvdW50ID0gKGNvdW50TWF4Lmxlbmd0aCA+IDEgJiYgc2VsZWN0ZWRDb3VudCA+IGNvdW50TWF4WzFdKSB8fCAoY291bnRNYXgubGVuZ3RoID09PSAxICYmIHNlbGVjdGVkQ291bnQgPj0gMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmx5IGxvb3AgdGhyb3VnaCBhbGwgc2VsZWN0ZWQgb3B0aW9ucyBpZiB0aGUgY291bnQgd29uJ3QgYmUgc2hvd25cbiAgICAgICAgaWYgKHNob3dDb3VudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoIXBsYWNlaG9sZGVyU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNlbGVjdGVkSW5kZXggPSAwOyBzZWxlY3RlZEluZGV4IDwgc2VsZWN0ZWRDb3VudDsgc2VsZWN0ZWRJbmRleCsrKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4IDwgNTApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gc2VsZWN0ZWRPcHRpb25zW3NlbGVjdGVkSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZU9wdGlvbnMgPSB7fTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmIHNlbGVjdGVkSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlRnJhZ21lbnQuYXBwZW5kQ2hpbGQobXVsdGlwbGVTZXBhcmF0b3IuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24udGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVPcHRpb25zLnRleHQgPSBvcHRpb24udGl0bGU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbi5jb250ZW50ICYmIHRoYXQub3B0aW9ucy5zaG93Q29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZU9wdGlvbnMuY29udGVudCA9IG9wdGlvbi5jb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zaG93SWNvbikge1xuICAgICAgICAgICAgICAgICAgICAgIHRpdGxlT3B0aW9ucy5pY29uID0gb3B0aW9uLmljb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zaG93U3VidGV4dCAmJiAhdGhhdC5tdWx0aXBsZSAmJiBvcHRpb24uc3VidGV4dCkgdGl0bGVPcHRpb25zLnN1YnRleHQgPSAnICcgKyBvcHRpb24uc3VidGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVPcHRpb25zLnRleHQgPSBvcHRpb24udGV4dC50cmltKCk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHRpdGxlRnJhZ21lbnQuYXBwZW5kQ2hpbGQoZ2VuZXJhdGVPcHRpb24udGV4dC5jYWxsKHRoaXMsIHRpdGxlT3B0aW9ucywgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgZWxsaXBzaXNcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZENvdW50ID4gNDkpIHtcbiAgICAgICAgICAgICAgdGl0bGVGcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLi4uJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3B0aW9uU2VsZWN0b3IgPSAnOm5vdChbaGlkZGVuXSk6bm90KFtkYXRhLWhpZGRlbj1cInRydWVcIl0pOm5vdChbZGF0YS1kaXZpZGVyPVwidHJ1ZVwiXSk6bm90KFtzdHlsZSo9XCJkaXNwbGF5OiBub25lXCJdKSc7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWRlRGlzYWJsZWQpIG9wdGlvblNlbGVjdG9yICs9ICc6bm90KDpkaXNhYmxlZCknO1xuXG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG11bHRpc2VsZWN0LCBhbmQgc2VsZWN0ZWRUZXh0Rm9ybWF0IGlzIGNvdW50LCB0aGVuIHNob3cgMSBvZiAyIHNlbGVjdGVkLCBldGMuXG4gICAgICAgICAgdmFyIHRvdGFsQ291bnQgPSB0aGlzLiRlbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCA+IG9wdGlvbicgKyBvcHRpb25TZWxlY3RvciArICcsIG9wdGdyb3VwJyArIG9wdGlvblNlbGVjdG9yICsgJyBvcHRpb24nICsgb3B0aW9uU2VsZWN0b3IpLmxlbmd0aCxcbiAgICAgICAgICAgICAgdHI4blRleHQgPSAodHlwZW9mIHRoaXMub3B0aW9ucy5jb3VudFNlbGVjdGVkVGV4dCA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLm9wdGlvbnMuY291bnRTZWxlY3RlZFRleHQoc2VsZWN0ZWRDb3VudCwgdG90YWxDb3VudCkgOiB0aGlzLm9wdGlvbnMuY291bnRTZWxlY3RlZFRleHQ7XG5cbiAgICAgICAgICB0aXRsZUZyYWdtZW50ID0gZ2VuZXJhdGVPcHRpb24udGV4dC5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIHRleHQ6IHRyOG5UZXh0LnJlcGxhY2UoJ3swfScsIHNlbGVjdGVkQ291bnQudG9TdHJpbmcoKSkucmVwbGFjZSgnezF9JywgdG90YWxDb3VudC50b1N0cmluZygpKVxuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBzZWxlY3QgZG9lc24ndCBoYXZlIGEgdGl0bGUsIHRoZW4gdXNlIHRoZSBkZWZhdWx0LCBvciBpZiBub3RoaW5nIGlzIHNldCBhdCBhbGwsIHVzZSBub25lU2VsZWN0ZWRUZXh0XG4gICAgICBpZiAoIXRpdGxlRnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgdGl0bGVGcmFnbWVudCA9IGdlbmVyYXRlT3B0aW9uLnRleHQuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgdGV4dDogdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyID8gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyIDogdGhpcy5vcHRpb25zLm5vbmVTZWxlY3RlZFRleHRcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBzZWxlY3QgaGFzIGEgdGl0bGUsIGFwcGx5IGl0IHRvIHRoZSBidXR0b24sIGFuZCBpZiBub3QsIGFwcGx5IHRpdGxlRnJhZ21lbnQgdGV4dFxuICAgICAgLy8gc3RyaXAgYWxsIEhUTUwgdGFncyBhbmQgdHJpbSB0aGUgcmVzdWx0LCB0aGVuIHVuZXNjYXBlIGFueSBlc2NhcGVkIHRhZ3NcbiAgICAgIGJ1dHRvbi50aXRsZSA9IHRpdGxlRnJhZ21lbnQudGV4dENvbnRlbnQucmVwbGFjZSgvPFtePl0qPj8vZywgJycpLnRyaW0oKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSAmJiBoYXNDb250ZW50KSB7XG4gICAgICAgIHNhbml0aXplSHRtbChbdGl0bGVGcmFnbWVudF0sIHRoYXQub3B0aW9ucy53aGl0ZUxpc3QsIHRoYXQub3B0aW9ucy5zYW5pdGl6ZUZuKTtcbiAgICAgIH1cblxuICAgICAgYnV0dG9uSW5uZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICBidXR0b25Jbm5lci5hcHBlbmRDaGlsZCh0aXRsZUZyYWdtZW50KTtcblxuICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPCA0ICYmIHRoaXMuJG5ld0VsZW1lbnRbMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdiczMtaGFzLWFkZG9uJykpIHtcbiAgICAgICAgdmFyIGZpbHRlckV4cGFuZCA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcuZmlsdGVyLWV4cGFuZCcpLFxuICAgICAgICAgICAgY2xvbmUgPSBidXR0b25Jbm5lci5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgICAgY2xvbmUuY2xhc3NOYW1lID0gJ2ZpbHRlci1leHBhbmQnO1xuXG4gICAgICAgIGlmIChmaWx0ZXJFeHBhbmQpIHtcbiAgICAgICAgICBidXR0b24ucmVwbGFjZUNoaWxkKGNsb25lLCBmaWx0ZXJFeHBhbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdyZW5kZXJlZCcgKyBFVkVOVF9LRVkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gW3N0eWxlXVxuICAgICAqIEBwYXJhbSBbc3RhdHVzXVxuICAgICAqL1xuICAgIHNldFN0eWxlOiBmdW5jdGlvbiAobmV3U3R5bGUsIHN0YXR1cykge1xuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuJGJ1dHRvblswXSxcbiAgICAgICAgICBuZXdFbGVtZW50ID0gdGhpcy4kbmV3RWxlbWVudFswXSxcbiAgICAgICAgICBzdHlsZSA9IHRoaXMub3B0aW9ucy5zdHlsZS50cmltKCksXG4gICAgICAgICAgYnV0dG9uQ2xhc3M7XG5cbiAgICAgIGlmICh0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykpIHtcbiAgICAgICAgdGhpcy4kbmV3RWxlbWVudC5hZGRDbGFzcyh0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykucmVwbGFjZSgvc2VsZWN0cGlja2VyfG1vYmlsZS1kZXZpY2V8YnMtc2VsZWN0LWhpZGRlbnx2YWxpZGF0ZVxcWy4qXFxdL2dpLCAnJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmVyc2lvbi5tYWpvciA8IDQpIHtcbiAgICAgICAgbmV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdiczMnKTtcblxuICAgICAgICBpZiAobmV3RWxlbWVudC5wYXJlbnROb2RlLmNsYXNzTGlzdCAmJiBuZXdFbGVtZW50LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdpbnB1dC1ncm91cCcpICYmXG4gICAgICAgICAgICAobmV3RWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIHx8IG5ld0VsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKSAmJlxuICAgICAgICAgICAgKG5ld0VsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZyB8fCBuZXdFbGVtZW50Lm5leHRFbGVtZW50U2libGluZykuY2xhc3NMaXN0LmNvbnRhaW5zKCdpbnB1dC1ncm91cC1hZGRvbicpXG4gICAgICAgICkge1xuICAgICAgICAgIG5ld0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYnMzLWhhcy1hZGRvbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdTdHlsZSkge1xuICAgICAgICBidXR0b25DbGFzcyA9IG5ld1N0eWxlLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1dHRvbkNsYXNzID0gc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0dXMgPT0gJ2FkZCcpIHtcbiAgICAgICAgaWYgKGJ1dHRvbkNsYXNzKSBidXR0b24uY2xhc3NMaXN0LmFkZC5hcHBseShidXR0b24uY2xhc3NMaXN0LCBidXR0b25DbGFzcy5zcGxpdCgnICcpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09ICdyZW1vdmUnKSB7XG4gICAgICAgIGlmIChidXR0b25DbGFzcykgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUuYXBwbHkoYnV0dG9uLmNsYXNzTGlzdCwgYnV0dG9uQ2xhc3Muc3BsaXQoJyAnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3R5bGUpIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlLmFwcGx5KGJ1dHRvbi5jbGFzc0xpc3QsIHN0eWxlLnNwbGl0KCcgJykpO1xuICAgICAgICBpZiAoYnV0dG9uQ2xhc3MpIGJ1dHRvbi5jbGFzc0xpc3QuYWRkLmFwcGx5KGJ1dHRvbi5jbGFzc0xpc3QsIGJ1dHRvbkNsYXNzLnNwbGl0KCcgJykpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBsaUhlaWdodDogZnVuY3Rpb24gKHJlZnJlc2gpIHtcbiAgICAgIGlmICghcmVmcmVzaCAmJiAodGhpcy5vcHRpb25zLnNpemUgPT09IGZhbHNlIHx8IE9iamVjdC5rZXlzKHRoaXMuc2l6ZUluZm8pLmxlbmd0aCkpIHJldHVybjtcblxuICAgICAgdmFyIG5ld0VsZW1lbnQgPSBlbGVtZW50VGVtcGxhdGVzLmRpdi5jbG9uZU5vZGUoZmFsc2UpLFxuICAgICAgICAgIG1lbnUgPSBlbGVtZW50VGVtcGxhdGVzLmRpdi5jbG9uZU5vZGUoZmFsc2UpLFxuICAgICAgICAgIG1lbnVJbm5lciA9IGVsZW1lbnRUZW1wbGF0ZXMuZGl2LmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgbWVudUlubmVySW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpLFxuICAgICAgICAgIGRpdmlkZXIgPSBlbGVtZW50VGVtcGxhdGVzLmxpLmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgZHJvcGRvd25IZWFkZXIgPSBlbGVtZW50VGVtcGxhdGVzLmxpLmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgbGksXG4gICAgICAgICAgYSA9IGVsZW1lbnRUZW1wbGF0ZXMuYS5jbG9uZU5vZGUoZmFsc2UpLFxuICAgICAgICAgIHRleHQgPSBlbGVtZW50VGVtcGxhdGVzLnNwYW4uY2xvbmVOb2RlKGZhbHNlKSxcbiAgICAgICAgICBoZWFkZXIgPSB0aGlzLm9wdGlvbnMuaGVhZGVyICYmIHRoaXMuJG1lbnUuZmluZCgnLicgKyBjbGFzc05hbWVzLlBPUE9WRVJIRUFERVIpLmxlbmd0aCA+IDAgPyB0aGlzLiRtZW51LmZpbmQoJy4nICsgY2xhc3NOYW1lcy5QT1BPVkVSSEVBREVSKVswXS5jbG9uZU5vZGUodHJ1ZSkgOiBudWxsLFxuICAgICAgICAgIHNlYXJjaCA9IHRoaXMub3B0aW9ucy5saXZlU2VhcmNoID8gZWxlbWVudFRlbXBsYXRlcy5kaXYuY2xvbmVOb2RlKGZhbHNlKSA6IG51bGwsXG4gICAgICAgICAgYWN0aW9ucyA9IHRoaXMub3B0aW9ucy5hY3Rpb25zQm94ICYmIHRoaXMubXVsdGlwbGUgJiYgdGhpcy4kbWVudS5maW5kKCcuYnMtYWN0aW9uc2JveCcpLmxlbmd0aCA+IDAgPyB0aGlzLiRtZW51LmZpbmQoJy5icy1hY3Rpb25zYm94JylbMF0uY2xvbmVOb2RlKHRydWUpIDogbnVsbCxcbiAgICAgICAgICBkb25lQnV0dG9uID0gdGhpcy5vcHRpb25zLmRvbmVCdXR0b24gJiYgdGhpcy5tdWx0aXBsZSAmJiB0aGlzLiRtZW51LmZpbmQoJy5icy1kb25lYnV0dG9uJykubGVuZ3RoID4gMCA/IHRoaXMuJG1lbnUuZmluZCgnLmJzLWRvbmVidXR0b24nKVswXS5jbG9uZU5vZGUodHJ1ZSkgOiBudWxsLFxuICAgICAgICAgIGZpcnN0T3B0aW9uID0gdGhpcy4kZWxlbWVudFswXS5vcHRpb25zWzBdO1xuXG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdFdpZHRoID0gdGhpcy4kbmV3RWxlbWVudFswXS5vZmZzZXRXaWR0aDtcblxuICAgICAgdGV4dC5jbGFzc05hbWUgPSAndGV4dCc7XG4gICAgICBhLmNsYXNzTmFtZSA9ICdkcm9wZG93bi1pdGVtICcgKyAoZmlyc3RPcHRpb24gPyBmaXJzdE9wdGlvbi5jbGFzc05hbWUgOiAnJyk7XG4gICAgICBuZXdFbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMuJG1lbnVbMF0ucGFyZW50Tm9kZS5jbGFzc05hbWUgKyAnICcgKyBjbGFzc05hbWVzLlNIT1c7XG4gICAgICBuZXdFbGVtZW50LnN0eWxlLndpZHRoID0gMDsgLy8gZW5zdXJlIGJ1dHRvbiB3aWR0aCBkb2Vzbid0IGFmZmVjdCBuYXR1cmFsIHdpZHRoIG9mIG1lbnUgd2hlbiBjYWxjdWxhdGluZ1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy53aWR0aCA9PT0gJ2F1dG8nKSBtZW51LnN0eWxlLm1pbldpZHRoID0gMDtcbiAgICAgIG1lbnUuY2xhc3NOYW1lID0gY2xhc3NOYW1lcy5NRU5VICsgJyAnICsgY2xhc3NOYW1lcy5TSE9XO1xuICAgICAgbWVudUlubmVyLmNsYXNzTmFtZSA9ICdpbm5lciAnICsgY2xhc3NOYW1lcy5TSE9XO1xuICAgICAgbWVudUlubmVySW5uZXIuY2xhc3NOYW1lID0gY2xhc3NOYW1lcy5NRU5VICsgJyBpbm5lciAnICsgKHZlcnNpb24ubWFqb3IgPj0gJzQnID8gY2xhc3NOYW1lcy5TSE9XIDogJycpO1xuICAgICAgZGl2aWRlci5jbGFzc05hbWUgPSBjbGFzc05hbWVzLkRJVklERVI7XG4gICAgICBkcm9wZG93bkhlYWRlci5jbGFzc05hbWUgPSAnZHJvcGRvd24taGVhZGVyJztcblxuICAgICAgdGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFx1MjAwYicpKTtcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpXTtcbiAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnb3B0aW9uJyAmJiAkKGRhdGEuZWxlbWVudC5maXJzdENoaWxkKS5jc3MoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBsaSA9IGRhdGEuZWxlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGkgPSBlbGVtZW50VGVtcGxhdGVzLmxpLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIGEuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgICAgIGxpLmFwcGVuZENoaWxkKGEpO1xuICAgICAgfVxuXG4gICAgICBkcm9wZG93bkhlYWRlci5hcHBlbmRDaGlsZCh0ZXh0LmNsb25lTm9kZSh0cnVlKSk7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdHBpY2tlci52aWV3LndpZGVzdE9wdGlvbikge1xuICAgICAgICBtZW51SW5uZXJJbm5lci5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdHBpY2tlci52aWV3LndpZGVzdE9wdGlvbi5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgfVxuXG4gICAgICBtZW51SW5uZXJJbm5lci5hcHBlbmRDaGlsZChsaSk7XG4gICAgICBtZW51SW5uZXJJbm5lci5hcHBlbmRDaGlsZChkaXZpZGVyKTtcbiAgICAgIG1lbnVJbm5lcklubmVyLmFwcGVuZENoaWxkKGRyb3Bkb3duSGVhZGVyKTtcbiAgICAgIGlmIChoZWFkZXIpIG1lbnUuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICAgIGlmIChzZWFyY2gpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgc2VhcmNoLmNsYXNzTmFtZSA9ICdicy1zZWFyY2hib3gnO1xuICAgICAgICBpbnB1dC5jbGFzc05hbWUgPSAnZm9ybS1jb250cm9sJztcbiAgICAgICAgc2VhcmNoLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgbWVudS5hcHBlbmRDaGlsZChzZWFyY2gpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGlvbnMpIG1lbnUuYXBwZW5kQ2hpbGQoYWN0aW9ucyk7XG4gICAgICBtZW51SW5uZXIuYXBwZW5kQ2hpbGQobWVudUlubmVySW5uZXIpO1xuICAgICAgbWVudS5hcHBlbmRDaGlsZChtZW51SW5uZXIpO1xuICAgICAgaWYgKGRvbmVCdXR0b24pIG1lbnUuYXBwZW5kQ2hpbGQoZG9uZUJ1dHRvbik7XG4gICAgICBuZXdFbGVtZW50LmFwcGVuZENoaWxkKG1lbnUpO1xuXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xuXG4gICAgICB2YXIgbGlIZWlnaHQgPSBsaS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgZHJvcGRvd25IZWFkZXJIZWlnaHQgPSBkcm9wZG93bkhlYWRlciA/IGRyb3Bkb3duSGVhZGVyLm9mZnNldEhlaWdodCA6IDAsXG4gICAgICAgICAgaGVhZGVySGVpZ2h0ID0gaGVhZGVyID8gaGVhZGVyLm9mZnNldEhlaWdodCA6IDAsXG4gICAgICAgICAgc2VhcmNoSGVpZ2h0ID0gc2VhcmNoID8gc2VhcmNoLm9mZnNldEhlaWdodCA6IDAsXG4gICAgICAgICAgYWN0aW9uc0hlaWdodCA9IGFjdGlvbnMgPyBhY3Rpb25zLm9mZnNldEhlaWdodCA6IDAsXG4gICAgICAgICAgZG9uZUJ1dHRvbkhlaWdodCA9IGRvbmVCdXR0b24gPyBkb25lQnV0dG9uLm9mZnNldEhlaWdodCA6IDAsXG4gICAgICAgICAgZGl2aWRlckhlaWdodCA9ICQoZGl2aWRlcikub3V0ZXJIZWlnaHQodHJ1ZSksXG4gICAgICAgICAgbWVudVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobWVudSksXG4gICAgICAgICAgbWVudVdpZHRoID0gbWVudS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICBtZW51UGFkZGluZyA9IHtcbiAgICAgICAgICAgIHZlcnQ6IHRvSW50ZWdlcihtZW51U3R5bGUucGFkZGluZ1RvcCkgK1xuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZS5wYWRkaW5nQm90dG9tKSArXG4gICAgICAgICAgICAgICAgICB0b0ludGVnZXIobWVudVN0eWxlLmJvcmRlclRvcFdpZHRoKSArXG4gICAgICAgICAgICAgICAgICB0b0ludGVnZXIobWVudVN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKSxcbiAgICAgICAgICAgIGhvcml6OiB0b0ludGVnZXIobWVudVN0eWxlLnBhZGRpbmdMZWZ0KSArXG4gICAgICAgICAgICAgICAgICB0b0ludGVnZXIobWVudVN0eWxlLnBhZGRpbmdSaWdodCkgK1xuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZS5ib3JkZXJMZWZ0V2lkdGgpICtcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUuYm9yZGVyUmlnaHRXaWR0aClcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1lbnVFeHRyYXMgPSB7XG4gICAgICAgICAgICB2ZXJ0OiBtZW51UGFkZGluZy52ZXJ0ICtcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUubWFyZ2luVG9wKSArXG4gICAgICAgICAgICAgICAgICB0b0ludGVnZXIobWVudVN0eWxlLm1hcmdpbkJvdHRvbSkgKyAyLFxuICAgICAgICAgICAgaG9yaXo6IG1lbnVQYWRkaW5nLmhvcml6ICtcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUubWFyZ2luTGVmdCkgK1xuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZS5tYXJnaW5SaWdodCkgKyAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzY3JvbGxCYXJXaWR0aDtcblxuICAgICAgbWVudUlubmVyLnN0eWxlLm92ZXJmbG93WSA9ICdzY3JvbGwnO1xuXG4gICAgICBzY3JvbGxCYXJXaWR0aCA9IG1lbnUub2Zmc2V0V2lkdGggLSBtZW51V2lkdGg7XG5cbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobmV3RWxlbWVudCk7XG5cbiAgICAgIHRoaXMuc2l6ZUluZm8ubGlIZWlnaHQgPSBsaUhlaWdodDtcbiAgICAgIHRoaXMuc2l6ZUluZm8uZHJvcGRvd25IZWFkZXJIZWlnaHQgPSBkcm9wZG93bkhlYWRlckhlaWdodDtcbiAgICAgIHRoaXMuc2l6ZUluZm8uaGVhZGVySGVpZ2h0ID0gaGVhZGVySGVpZ2h0O1xuICAgICAgdGhpcy5zaXplSW5mby5zZWFyY2hIZWlnaHQgPSBzZWFyY2hIZWlnaHQ7XG4gICAgICB0aGlzLnNpemVJbmZvLmFjdGlvbnNIZWlnaHQgPSBhY3Rpb25zSGVpZ2h0O1xuICAgICAgdGhpcy5zaXplSW5mby5kb25lQnV0dG9uSGVpZ2h0ID0gZG9uZUJ1dHRvbkhlaWdodDtcbiAgICAgIHRoaXMuc2l6ZUluZm8uZGl2aWRlckhlaWdodCA9IGRpdmlkZXJIZWlnaHQ7XG4gICAgICB0aGlzLnNpemVJbmZvLm1lbnVQYWRkaW5nID0gbWVudVBhZGRpbmc7XG4gICAgICB0aGlzLnNpemVJbmZvLm1lbnVFeHRyYXMgPSBtZW51RXh0cmFzO1xuICAgICAgdGhpcy5zaXplSW5mby5tZW51V2lkdGggPSBtZW51V2lkdGg7XG4gICAgICB0aGlzLnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGggPSBtZW51V2lkdGggLSBtZW51UGFkZGluZy5ob3JpejtcbiAgICAgIHRoaXMuc2l6ZUluZm8udG90YWxNZW51V2lkdGggPSB0aGlzLnNpemVJbmZvLm1lbnVXaWR0aDtcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2Nyb2xsQmFyV2lkdGggPSBzY3JvbGxCYXJXaWR0aDtcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0SGVpZ2h0ID0gdGhpcy4kbmV3RWxlbWVudFswXS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIHRoaXMuc2V0UG9zaXRpb25EYXRhKCk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgJHdpbmRvdyA9ICQod2luZG93KSxcbiAgICAgICAgICBwb3MgPSB0aGF0LiRuZXdFbGVtZW50Lm9mZnNldCgpLFxuICAgICAgICAgICRjb250YWluZXIgPSAkKHRoYXQub3B0aW9ucy5jb250YWluZXIpLFxuICAgICAgICAgIGNvbnRhaW5lclBvcztcblxuICAgICAgaWYgKHRoYXQub3B0aW9ucy5jb250YWluZXIgJiYgJGNvbnRhaW5lci5sZW5ndGggJiYgISRjb250YWluZXIuaXMoJ2JvZHknKSkge1xuICAgICAgICBjb250YWluZXJQb3MgPSAkY29udGFpbmVyLm9mZnNldCgpO1xuICAgICAgICBjb250YWluZXJQb3MudG9wICs9IHBhcnNlSW50KCRjb250YWluZXIuY3NzKCdib3JkZXJUb3BXaWR0aCcpKTtcbiAgICAgICAgY29udGFpbmVyUG9zLmxlZnQgKz0gcGFyc2VJbnQoJGNvbnRhaW5lci5jc3MoJ2JvcmRlckxlZnRXaWR0aCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lclBvcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgICB9XG5cbiAgICAgIHZhciB3aW5QYWQgPSB0aGF0Lm9wdGlvbnMud2luZG93UGFkZGluZztcblxuICAgICAgdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRUb3AgPSBwb3MudG9wIC0gY29udGFpbmVyUG9zLnRvcCAtICR3aW5kb3cuc2Nyb2xsVG9wKCk7XG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldEJvdCA9ICR3aW5kb3cuaGVpZ2h0KCkgLSB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldFRvcCAtIHRoaXMuc2l6ZUluZm8uc2VsZWN0SGVpZ2h0IC0gY29udGFpbmVyUG9zLnRvcCAtIHdpblBhZFsyXTtcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0TGVmdCA9IHBvcy5sZWZ0IC0gY29udGFpbmVyUG9zLmxlZnQgLSAkd2luZG93LnNjcm9sbExlZnQoKTtcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0UmlnaHQgPSAkd2luZG93LndpZHRoKCkgLSB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldExlZnQgLSB0aGlzLnNpemVJbmZvLnNlbGVjdFdpZHRoIC0gY29udGFpbmVyUG9zLmxlZnQgLSB3aW5QYWRbMV07XG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldFRvcCAtPSB3aW5QYWRbMF07XG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldExlZnQgLT0gd2luUGFkWzNdO1xuICAgIH0sXG5cbiAgICBzZXRNZW51U2l6ZTogZnVuY3Rpb24gKGlzQXV0bykge1xuICAgICAgdGhpcy5nZXRTZWxlY3RQb3NpdGlvbigpO1xuXG4gICAgICB2YXIgc2VsZWN0V2lkdGggPSB0aGlzLnNpemVJbmZvLnNlbGVjdFdpZHRoLFxuICAgICAgICAgIGxpSGVpZ2h0ID0gdGhpcy5zaXplSW5mby5saUhlaWdodCxcbiAgICAgICAgICBoZWFkZXJIZWlnaHQgPSB0aGlzLnNpemVJbmZvLmhlYWRlckhlaWdodCxcbiAgICAgICAgICBzZWFyY2hIZWlnaHQgPSB0aGlzLnNpemVJbmZvLnNlYXJjaEhlaWdodCxcbiAgICAgICAgICBhY3Rpb25zSGVpZ2h0ID0gdGhpcy5zaXplSW5mby5hY3Rpb25zSGVpZ2h0LFxuICAgICAgICAgIGRvbmVCdXR0b25IZWlnaHQgPSB0aGlzLnNpemVJbmZvLmRvbmVCdXR0b25IZWlnaHQsXG4gICAgICAgICAgZGl2SGVpZ2h0ID0gdGhpcy5zaXplSW5mby5kaXZpZGVySGVpZ2h0LFxuICAgICAgICAgIG1lbnVQYWRkaW5nID0gdGhpcy5zaXplSW5mby5tZW51UGFkZGluZyxcbiAgICAgICAgICBtZW51SW5uZXJIZWlnaHQsXG4gICAgICAgICAgbWVudUhlaWdodCxcbiAgICAgICAgICBkaXZMZW5ndGggPSAwLFxuICAgICAgICAgIG1pbkhlaWdodCxcbiAgICAgICAgICBfbWluSGVpZ2h0LFxuICAgICAgICAgIG1heEhlaWdodCxcbiAgICAgICAgICBtZW51SW5uZXJNaW5IZWlnaHQsXG4gICAgICAgICAgZXN0aW1hdGUsXG4gICAgICAgICAgaXNEcm9wdXA7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJvcHVwQXV0bykge1xuICAgICAgICAvLyBHZXQgdGhlIGVzdGltYXRlZCBoZWlnaHQgb2YgdGhlIG1lbnUgd2l0aG91dCBzY3JvbGxiYXJzLlxuICAgICAgICAvLyBUaGlzIGlzIHVzZWZ1bCBmb3Igc21hbGxlciBtZW51cywgd2hlcmUgdGhlcmUgbWlnaHQgYmUgcGxlbnR5IG9mIHJvb21cbiAgICAgICAgLy8gYmVsb3cgdGhlIGJ1dHRvbiB3aXRob3V0IHNldHRpbmcgZHJvcHVwLCBidXQgd2UgY2FuJ3Qga25vd1xuICAgICAgICAvLyB0aGUgZXhhY3QgaGVpZ2h0IG9mIHRoZSBtZW51IHVudGlsIGNyZWF0ZVZpZXcgaXMgY2FsbGVkIGxhdGVyXG4gICAgICAgIGVzdGltYXRlID0gbGlIZWlnaHQgKiB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEubGVuZ3RoICsgbWVudVBhZGRpbmcudmVydDtcblxuICAgICAgICBpc0Ryb3B1cCA9IHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0VG9wIC0gdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRCb3QgPiB0aGlzLnNpemVJbmZvLm1lbnVFeHRyYXMudmVydCAmJiBlc3RpbWF0ZSArIHRoaXMuc2l6ZUluZm8ubWVudUV4dHJhcy52ZXJ0ICsgNTAgPiB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldEJvdDtcblxuICAgICAgICAvLyBlbnN1cmUgZHJvcHVwIGRvZXNuJ3QgY2hhbmdlIHdoaWxlIHNlYXJjaGluZyAoc28gbWVudSBkb2Vzbid0IGJvdW5jZSBiYWNrIGFuZCBmb3J0aClcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0cGlja2VyLmlzU2VhcmNoaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgaXNEcm9wdXAgPSB0aGlzLnNlbGVjdHBpY2tlci5kcm9wdXA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRuZXdFbGVtZW50LnRvZ2dsZUNsYXNzKGNsYXNzTmFtZXMuRFJPUFVQLCBpc0Ryb3B1cCk7XG4gICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLmRyb3B1cCA9IGlzRHJvcHVwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNpemUgPT09ICdhdXRvJykge1xuICAgICAgICBfbWluSGVpZ2h0ID0gdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhLmxlbmd0aCA+IDMgPyB0aGlzLnNpemVJbmZvLmxpSGVpZ2h0ICogMyArIHRoaXMuc2l6ZUluZm8ubWVudUV4dHJhcy52ZXJ0IC0gMiA6IDA7XG4gICAgICAgIG1lbnVIZWlnaHQgPSB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldEJvdCAtIHRoaXMuc2l6ZUluZm8ubWVudUV4dHJhcy52ZXJ0O1xuICAgICAgICBtaW5IZWlnaHQgPSBfbWluSGVpZ2h0ICsgaGVhZGVySGVpZ2h0ICsgc2VhcmNoSGVpZ2h0ICsgYWN0aW9uc0hlaWdodCArIGRvbmVCdXR0b25IZWlnaHQ7XG4gICAgICAgIG1lbnVJbm5lck1pbkhlaWdodCA9IE1hdGgubWF4KF9taW5IZWlnaHQgLSBtZW51UGFkZGluZy52ZXJ0LCAwKTtcblxuICAgICAgICBpZiAodGhpcy4kbmV3RWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLkRST1BVUCkpIHtcbiAgICAgICAgICBtZW51SGVpZ2h0ID0gdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRUb3AgLSB0aGlzLnNpemVJbmZvLm1lbnVFeHRyYXMudmVydDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1heEhlaWdodCA9IG1lbnVIZWlnaHQ7XG4gICAgICAgIG1lbnVJbm5lckhlaWdodCA9IG1lbnVIZWlnaHQgLSBoZWFkZXJIZWlnaHQgLSBzZWFyY2hIZWlnaHQgLSBhY3Rpb25zSGVpZ2h0IC0gZG9uZUJ1dHRvbkhlaWdodCAtIG1lbnVQYWRkaW5nLnZlcnQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zaXplICYmIHRoaXMub3B0aW9ucy5zaXplICE9ICdhdXRvJyAmJiB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmVsZW1lbnRzLmxlbmd0aCA+IHRoaXMub3B0aW9ucy5zaXplKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLnNpemU7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbaV0udHlwZSA9PT0gJ2RpdmlkZXInKSBkaXZMZW5ndGgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIG1lbnVIZWlnaHQgPSBsaUhlaWdodCAqIHRoaXMub3B0aW9ucy5zaXplICsgZGl2TGVuZ3RoICogZGl2SGVpZ2h0ICsgbWVudVBhZGRpbmcudmVydDtcbiAgICAgICAgbWVudUlubmVySGVpZ2h0ID0gbWVudUhlaWdodCAtIG1lbnVQYWRkaW5nLnZlcnQ7XG4gICAgICAgIG1heEhlaWdodCA9IG1lbnVIZWlnaHQgKyBoZWFkZXJIZWlnaHQgKyBzZWFyY2hIZWlnaHQgKyBhY3Rpb25zSGVpZ2h0ICsgZG9uZUJ1dHRvbkhlaWdodDtcbiAgICAgICAgbWluSGVpZ2h0ID0gbWVudUlubmVyTWluSGVpZ2h0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJG1lbnUuY3NzKHtcbiAgICAgICAgJ21heC1oZWlnaHQnOiBtYXhIZWlnaHQgKyAncHgnLFxuICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAgICAgICAgJ21pbi1oZWlnaHQnOiBtaW5IZWlnaHQgKyAncHgnXG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kbWVudUlubmVyLmNzcyh7XG4gICAgICAgICdtYXgtaGVpZ2h0JzogbWVudUlubmVySGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbiBhdXRvJyxcbiAgICAgICAgJ21pbi1oZWlnaHQnOiBtZW51SW5uZXJNaW5IZWlnaHQgKyAncHgnXG4gICAgICB9KTtcblxuICAgICAgLy8gZW5zdXJlIG1lbnVJbm5lckhlaWdodCBpcyBhbHdheXMgYSBwb3NpdGl2ZSBudW1iZXIgdG8gcHJldmVudCBpc3N1ZXMgY2FsY3VsYXRpbmcgY2h1bmtTaXplIGluIGNyZWF0ZVZpZXdcbiAgICAgIHRoaXMuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0ID0gTWF0aC5tYXgobWVudUlubmVySGVpZ2h0LCAxKTtcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5sZW5ndGggJiYgdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW3RoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5sZW5ndGggLSAxXS5wb3NpdGlvbiA+IHRoaXMuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2l6ZUluZm8uaGFzU2Nyb2xsQmFyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaXplSW5mby50b3RhbE1lbnVXaWR0aCA9IHRoaXMuc2l6ZUluZm8ubWVudVdpZHRoICsgdGhpcy5zaXplSW5mby5zY3JvbGxCYXJXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcm9wZG93bkFsaWduUmlnaHQgPT09ICdhdXRvJykge1xuICAgICAgICB0aGlzLiRtZW51LnRvZ2dsZUNsYXNzKGNsYXNzTmFtZXMuTUVOVVJJR0hULCB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldExlZnQgPiB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldFJpZ2h0ICYmIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0UmlnaHQgPCAodGhpcy5zaXplSW5mby50b3RhbE1lbnVXaWR0aCAtIHNlbGVjdFdpZHRoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRyb3Bkb3duICYmIHRoaXMuZHJvcGRvd24uX3BvcHBlcikgdGhpcy5kcm9wZG93bi5fcG9wcGVyLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBzZXRTaXplOiBmdW5jdGlvbiAocmVmcmVzaCkge1xuICAgICAgdGhpcy5saUhlaWdodChyZWZyZXNoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXIpIHRoaXMuJG1lbnUuY3NzKCdwYWRkaW5nLXRvcCcsIDApO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNpemUgIT09IGZhbHNlKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICR3aW5kb3cgPSAkKHdpbmRvdyk7XG5cbiAgICAgICAgdGhpcy5zZXRNZW51U2l6ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaCkge1xuICAgICAgICAgIHRoaXMuJHNlYXJjaGJveFxuICAgICAgICAgICAgLm9mZignaW5wdXQuc2V0TWVudVNpemUgcHJvcGVydHljaGFuZ2Uuc2V0TWVudVNpemUnKVxuICAgICAgICAgICAgLm9uKCdpbnB1dC5zZXRNZW51U2l6ZSBwcm9wZXJ0eWNoYW5nZS5zZXRNZW51U2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuc2V0TWVudVNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaXplID09PSAnYXV0bycpIHtcbiAgICAgICAgICAkd2luZG93XG4gICAgICAgICAgICAub2ZmKCdyZXNpemUnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuc2V0TWVudVNpemUnICsgJyBzY3JvbGwnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuc2V0TWVudVNpemUnKVxuICAgICAgICAgICAgLm9uKCdyZXNpemUnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuc2V0TWVudVNpemUnICsgJyBzY3JvbGwnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuc2V0TWVudVNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGF0LnNldE1lbnVTaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2l6ZSAmJiB0aGlzLm9wdGlvbnMuc2l6ZSAhPSAnYXV0bycgJiYgdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cy5sZW5ndGggPiB0aGlzLm9wdGlvbnMuc2l6ZSkge1xuICAgICAgICAgICR3aW5kb3cub2ZmKCdyZXNpemUnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuc2V0TWVudVNpemUnICsgJyBzY3JvbGwnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuc2V0TWVudVNpemUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNyZWF0ZVZpZXcoZmFsc2UsIHRydWUsIHJlZnJlc2gpO1xuICAgIH0sXG5cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLndpZHRoID09PSAnYXV0bycpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LiRtZW51LmNzcygnbWluLXdpZHRoJywgJzAnKTtcblxuICAgICAgICAgIHRoYXQuJGVsZW1lbnQub24oJ2xvYWRlZCcgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubGlIZWlnaHQoKTtcbiAgICAgICAgICAgIHRoYXQuc2V0TWVudVNpemUoKTtcblxuICAgICAgICAgICAgLy8gR2V0IGNvcnJlY3Qgd2lkdGggaWYgZWxlbWVudCBpcyBoaWRkZW5cbiAgICAgICAgICAgIHZhciAkc2VsZWN0Q2xvbmUgPSB0aGF0LiRuZXdFbGVtZW50LmNsb25lKCkuYXBwZW5kVG8oJ2JvZHknKSxcbiAgICAgICAgICAgICAgICBidG5XaWR0aCA9ICRzZWxlY3RDbG9uZS5jc3MoJ3dpZHRoJywgJ2F1dG8nKS5jaGlsZHJlbignYnV0dG9uJykub3V0ZXJXaWR0aCgpO1xuXG4gICAgICAgICAgICAkc2VsZWN0Q2xvbmUucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vIFNldCB3aWR0aCB0byB3aGF0ZXZlcidzIGxhcmdlciwgYnV0dG9uIHRpdGxlIG9yIGxvbmdlc3Qgb3B0aW9uXG4gICAgICAgICAgICB0aGF0LnNpemVJbmZvLnNlbGVjdFdpZHRoID0gTWF0aC5tYXgodGhhdC5zaXplSW5mby50b3RhbE1lbnVXaWR0aCwgYnRuV2lkdGgpO1xuICAgICAgICAgICAgdGhhdC4kbmV3RWxlbWVudC5jc3MoJ3dpZHRoJywgdGhhdC5zaXplSW5mby5zZWxlY3RXaWR0aCArICdweCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLndpZHRoID09PSAnZml0Jykge1xuICAgICAgICAvLyBSZW1vdmUgaW5saW5lIG1pbi13aWR0aCBzbyB3aWR0aCBjYW4gYmUgY2hhbmdlZCBmcm9tICdhdXRvJ1xuICAgICAgICB0aGlzLiRtZW51LmNzcygnbWluLXdpZHRoJywgJycpO1xuICAgICAgICB0aGlzLiRuZXdFbGVtZW50LmNzcygnd2lkdGgnLCAnJykuYWRkQ2xhc3MoJ2ZpdC13aWR0aCcpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGlubGluZSBtaW4td2lkdGggc28gd2lkdGggY2FuIGJlIGNoYW5nZWQgZnJvbSAnYXV0bydcbiAgICAgICAgdGhpcy4kbWVudS5jc3MoJ21pbi13aWR0aCcsICcnKTtcbiAgICAgICAgdGhpcy4kbmV3RWxlbWVudC5jc3MoJ3dpZHRoJywgdGhpcy5vcHRpb25zLndpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbW92ZSBpbmxpbmUgbWluLXdpZHRoL3dpZHRoIHNvIHdpZHRoIGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIHRoaXMuJG1lbnUuY3NzKCdtaW4td2lkdGgnLCAnJyk7XG4gICAgICAgIHRoaXMuJG5ld0VsZW1lbnQuY3NzKCd3aWR0aCcsICcnKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBmaXQtd2lkdGggY2xhc3MgaWYgd2lkdGggaXMgY2hhbmdlZCBwcm9ncmFtbWF0aWNhbGx5XG4gICAgICBpZiAodGhpcy4kbmV3RWxlbWVudC5oYXNDbGFzcygnZml0LXdpZHRoJykgJiYgdGhpcy5vcHRpb25zLndpZHRoICE9PSAnZml0Jykge1xuICAgICAgICB0aGlzLiRuZXdFbGVtZW50WzBdLmNsYXNzTGlzdC5yZW1vdmUoJ2ZpdC13aWR0aCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWxlY3RQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy4kYnNDb250YWluZXIgPSAkKCc8ZGl2IGNsYXNzPVwiYnMtY29udGFpbmVyXCIgLz4nKTtcblxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICRjb250YWluZXIgPSAkKHRoaXMub3B0aW9ucy5jb250YWluZXIpLFxuICAgICAgICAgIHBvcyxcbiAgICAgICAgICBjb250YWluZXJQb3MsXG4gICAgICAgICAgYWN0dWFsSGVpZ2h0LFxuICAgICAgICAgIGdldFBsYWNlbWVudCA9IGZ1bmN0aW9uICgkZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lclBvc2l0aW9uID0ge30sXG4gICAgICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGRyb3Bkb3duJ3MgZGVmYXVsdCBkaXNwbGF5IHNldHRpbmcgaWYgZGlzcGxheSBpcyBub3QgbWFudWFsbHkgc2V0XG4gICAgICAgICAgICAgICAgZGlzcGxheSA9IHRoYXQub3B0aW9ucy5kaXNwbGF5IHx8IChcbiAgICAgICAgICAgICAgICAgIC8vIEJvb3RzdHJhcCAzIGRvZXNuJ3QgaGF2ZSAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yLkRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IuRGVmYXVsdCA/ICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IuRGVmYXVsdC5kaXNwbGF5XG4gICAgICAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhhdC4kYnNDb250YWluZXIuYWRkQ2xhc3MoJGVsZW1lbnQuYXR0cignY2xhc3MnKS5yZXBsYWNlKC9mb3JtLWNvbnRyb2x8Zml0LXdpZHRoL2dpLCAnJykpLnRvZ2dsZUNsYXNzKGNsYXNzTmFtZXMuRFJPUFVQLCAkZWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLkRST1BVUCkpO1xuICAgICAgICAgICAgcG9zID0gJGVsZW1lbnQub2Zmc2V0KCk7XG5cbiAgICAgICAgICAgIGlmICghJGNvbnRhaW5lci5pcygnYm9keScpKSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lclBvcyA9ICRjb250YWluZXIub2Zmc2V0KCk7XG4gICAgICAgICAgICAgIGNvbnRhaW5lclBvcy50b3AgKz0gcGFyc2VJbnQoJGNvbnRhaW5lci5jc3MoJ2JvcmRlclRvcFdpZHRoJykpIC0gJGNvbnRhaW5lci5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgICAgY29udGFpbmVyUG9zLmxlZnQgKz0gcGFyc2VJbnQoJGNvbnRhaW5lci5jc3MoJ2JvcmRlckxlZnRXaWR0aCcpKSAtICRjb250YWluZXIuc2Nyb2xsTGVmdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyUG9zID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWN0dWFsSGVpZ2h0ID0gJGVsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lcy5EUk9QVVApID8gMCA6ICRlbGVtZW50WzBdLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgLy8gQm9vdHN0cmFwIDQrIHVzZXMgUG9wcGVyIGZvciBtZW51IHBvc2l0aW9uaW5nXG4gICAgICAgICAgICBpZiAodmVyc2lvbi5tYWpvciA8IDQgfHwgZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyUG9zaXRpb24udG9wID0gcG9zLnRvcCAtIGNvbnRhaW5lclBvcy50b3AgKyBhY3R1YWxIZWlnaHQ7XG4gICAgICAgICAgICAgIGNvbnRhaW5lclBvc2l0aW9uLmxlZnQgPSBwb3MubGVmdCAtIGNvbnRhaW5lclBvcy5sZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWluZXJQb3NpdGlvbi53aWR0aCA9ICRlbGVtZW50WzBdLm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgICB0aGF0LiRic0NvbnRhaW5lci5jc3MoY29udGFpbmVyUG9zaXRpb24pO1xuICAgICAgICAgIH07XG5cbiAgICAgIHRoaXMuJGJ1dHRvbi5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGF0LmlzRGlzYWJsZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBsYWNlbWVudCh0aGF0LiRuZXdFbGVtZW50KTtcblxuICAgICAgICB0aGF0LiRic0NvbnRhaW5lclxuICAgICAgICAgIC5hcHBlbmRUbyh0aGF0Lm9wdGlvbnMuY29udGFpbmVyKVxuICAgICAgICAgIC50b2dnbGVDbGFzcyhjbGFzc05hbWVzLlNIT1csICF0aGF0LiRidXR0b24uaGFzQ2xhc3MoY2xhc3NOYW1lcy5TSE9XKSlcbiAgICAgICAgICAuYXBwZW5kKHRoYXQuJG1lbnUpO1xuICAgICAgfSk7XG5cbiAgICAgICQod2luZG93KVxuICAgICAgICAub2ZmKCdyZXNpemUnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcgc2Nyb2xsJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQpXG4gICAgICAgIC5vbigncmVzaXplJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQgKyAnIHNjcm9sbCcgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGlzQWN0aXZlID0gdGhhdC4kbmV3RWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLlNIT1cpO1xuXG4gICAgICAgICAgaWYgKGlzQWN0aXZlKSBnZXRQbGFjZW1lbnQodGhhdC4kbmV3RWxlbWVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdoaWRlJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0LiRtZW51LmRhdGEoJ2hlaWdodCcsIHRoYXQuJG1lbnUuaGVpZ2h0KCkpO1xuICAgICAgICB0aGF0LiRic0NvbnRhaW5lci5kZXRhY2goKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjcmVhdGVPcHRpb246IGZ1bmN0aW9uIChkYXRhLCBpbml0KSB7XG4gICAgICB2YXIgb3B0aW9uRGF0YSA9ICFkYXRhLm9wdGlvbiA/IGRhdGEgOiBkYXRhLm9wdGlvbjtcblxuICAgICAgaWYgKG9wdGlvbkRhdGEgJiYgb3B0aW9uRGF0YS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICB2YXIgb3B0aW9uID0gKGluaXQgPyBlbGVtZW50VGVtcGxhdGVzLnNlbGVjdGVkT3B0aW9uIDogZWxlbWVudFRlbXBsYXRlcy5vcHRpb24pLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgaWYgKG9wdGlvbkRhdGEudmFsdWUgIT09IHVuZGVmaW5lZCkgb3B0aW9uLnZhbHVlID0gb3B0aW9uRGF0YS52YWx1ZTtcbiAgICAgICAgb3B0aW9uLnRleHRDb250ZW50ID0gb3B0aW9uRGF0YS50ZXh0O1xuXG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKG9wdGlvbkRhdGEubGlJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0aW9uLmxpSW5kZXggPSBvcHRpb25EYXRhLmxpSW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZiAoIWluaXQpIHtcbiAgICAgICAgICBvcHRpb24ubGlJbmRleCA9IGRhdGEuaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLm9wdGlvbiA9IG9wdGlvbjtcblxuICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci5tYWluLm9wdGlvblF1ZXVlLmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldE9wdGlvblN0YXR1czogZnVuY3Rpb24gKHNlbGVjdGVkT25seSkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICB0aGF0Lm5vU2Nyb2xsID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGF0LnNlbGVjdHBpY2tlci52aWV3LnZpc2libGVFbGVtZW50cyAmJiB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnZpc2libGVFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnZpc2libGVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBsaURhdGEgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbaSArIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wXSxcbiAgICAgICAgICAgICAgb3B0aW9uID0gbGlEYXRhLm9wdGlvbjtcblxuICAgICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE9ubHkgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdGhhdC5zZXREaXNhYmxlZChsaURhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0LnNldFNlbGVjdGVkKGxpRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwZW5kIG9wdGlvblF1ZXVlIChkb2N1bWVudEZyYWdtZW50IHdpdGggb3B0aW9uIGVsZW1lbnRzIGZvciBzZWxlY3Qgb3B0aW9ucylcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2UuZGF0YSkgdGhpcy4kZWxlbWVudFswXS5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdHBpY2tlci5tYWluLm9wdGlvblF1ZXVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpRGF0YSAtIHRoZSBvcHRpb24gb2JqZWN0IHRoYXQgaXMgYmVpbmcgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgLSB0cnVlIGlmIHRoZSBvcHRpb24gaXMgYmVpbmcgc2VsZWN0ZWQsIGZhbHNlIGlmIGJlaW5nIGRlc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRTZWxlY3RlZDogZnVuY3Rpb24gKGxpRGF0YSwgc2VsZWN0ZWQpIHtcbiAgICAgIHNlbGVjdGVkID0gc2VsZWN0ZWQgPT09IHVuZGVmaW5lZCA/IGxpRGF0YS5zZWxlY3RlZCA6IHNlbGVjdGVkO1xuXG4gICAgICB2YXIgbGkgPSBsaURhdGEuZWxlbWVudCxcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SXNTZXQgPSB0aGlzLmFjdGl2ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICB0aGlzSXNBY3RpdmUgPSB0aGlzLmFjdGl2ZUVsZW1lbnQgPT09IGxpLFxuICAgICAgICAgIHByZXZBY3RpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IG9wdGlvbiBpcyBhbHJlYWR5IGFjdGl2ZVxuICAgICAgICAgIC8vIE9SXG4gICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgb3B0aW9uIGlzIGJlaW5nIHNlbGVjdGVkLCBpdCdzIE5PVCBtdWx0aXBsZSwgYW5kXG4gICAgICAgICAgLy8gYWN0aXZlRWxlbWVudCBpcyB1bmRlZmluZWQ6XG4gICAgICAgICAgLy8gIC0gd2hlbiB0aGUgbWVudSBpcyBmaXJzdCBiZWluZyBvcGVuZWQsIE9SXG4gICAgICAgICAgLy8gIC0gYWZ0ZXIgYSBzZWFyY2ggaGFzIGJlZW4gcGVyZm9ybWVkLCBPUlxuICAgICAgICAgIC8vICAtIHdoZW4gcmV0YWluQWN0aXZlIGlzIGZhbHNlIHdoZW4gc2VsZWN0aW5nIGEgbmV3IG9wdGlvbiAoaS5lLiBpbmRleCBvZiB0aGUgbmV3bHkgc2VsZWN0ZWQgb3B0aW9uIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBhY3RpdmVFbGVtZW50KVxuICAgICAgICAgIGtlZXBBY3RpdmUgPSB0aGlzSXNBY3RpdmUgfHwgKHNlbGVjdGVkICYmICF0aGlzLm11bHRpcGxlICYmICFhY3RpdmVFbGVtZW50SXNTZXQpO1xuXG4gICAgICBpZiAoIWxpKSByZXR1cm47XG5cbiAgICAgIGlmIChzZWxlY3RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpRGF0YS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICBpZiAobGlEYXRhLm9wdGlvbikgbGlEYXRhLm9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgdGhpcy5vcHRpb25zLnNvdXJjZS5kYXRhKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlT3B0aW9uKGxpRGF0YSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBhID0gbGkuZmlyc3RDaGlsZDtcblxuICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRFbGVtZW50ID0gbGk7XG4gICAgICB9XG5cbiAgICAgIGxpLmNsYXNzTGlzdC50b2dnbGUoJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xuXG4gICAgICBpZiAoa2VlcEFjdGl2ZSkge1xuICAgICAgICB0aGlzLmZvY3VzSXRlbShsaSwgbGlEYXRhKTtcbiAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy5jdXJyZW50QWN0aXZlID0gbGk7XG4gICAgICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IGxpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZvY3VzSXRlbShsaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhKSB7XG4gICAgICAgIGEuY2xhc3NMaXN0LnRvZ2dsZSgnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGEucmVtb3ZlQXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgha2VlcEFjdGl2ZSAmJiAhYWN0aXZlRWxlbWVudElzU2V0ICYmIHNlbGVjdGVkICYmIHRoaXMucHJldkFjdGl2ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmV2QWN0aXZlID0gdGhpcy5wcmV2QWN0aXZlRWxlbWVudDtcblxuICAgICAgICB0aGlzLmRlZm9jdXNJdGVtKHByZXZBY3RpdmUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIG9wdGlvbiB0aGF0IGlzIGJlaW5nIGRpc2FibGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAtIHRydWUgaWYgdGhlIG9wdGlvbiBpcyBiZWluZyBkaXNhYmxlZCwgZmFsc2UgaWYgYmVpbmcgZW5hYmxlZFxuICAgICAqL1xuICAgIHNldERpc2FibGVkOiBmdW5jdGlvbiAobGlEYXRhKSB7XG4gICAgICB2YXIgZGlzYWJsZWQgPSBsaURhdGEuZGlzYWJsZWQsXG4gICAgICAgICAgbGkgPSBsaURhdGEuZWxlbWVudCxcbiAgICAgICAgICBhO1xuXG4gICAgICBpZiAoIWxpKSByZXR1cm47XG5cbiAgICAgIGEgPSBsaS5maXJzdENoaWxkO1xuXG4gICAgICBsaS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZXMuRElTQUJMRUQsIGRpc2FibGVkKTtcblxuICAgICAgaWYgKGEpIHtcbiAgICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPj0gJzQnKSBhLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lcy5ESVNBQkxFRCwgZGlzYWJsZWQpO1xuXG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgZGlzYWJsZWQpO1xuICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpO1xuICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50WzBdLmRpc2FibGVkO1xuICAgIH0sXG5cbiAgICBjaGVja0Rpc2FibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5pc0Rpc2FibGVkKCkpIHtcbiAgICAgICAgdGhpcy4kbmV3RWxlbWVudFswXS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZXMuRElTQUJMRUQpO1xuICAgICAgICB0aGlzLiRidXR0b24uYWRkQ2xhc3MoY2xhc3NOYW1lcy5ESVNBQkxFRCkuYXR0cignYXJpYS1kaXNhYmxlZCcsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuJGJ1dHRvblswXS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lcy5ESVNBQkxFRCkpIHtcbiAgICAgICAgICB0aGlzLiRuZXdFbGVtZW50WzBdLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lcy5ESVNBQkxFRCk7XG4gICAgICAgICAgdGhpcy4kYnV0dG9uLnJlbW92ZUNsYXNzKGNsYXNzTmFtZXMuRElTQUJMRUQpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xpY2tMaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICRkb2N1bWVudCA9ICQoZG9jdW1lbnQpO1xuXG4gICAgICAkZG9jdW1lbnQuZGF0YSgnc3BhY2VTZWxlY3QnLCBmYWxzZSk7XG5cbiAgICAgIHRoaXMuJGJ1dHRvbi5vbigna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoLygzMikvLnRlc3QoZS5rZXlDb2RlLnRvU3RyaW5nKDEwKSkgJiYgJGRvY3VtZW50LmRhdGEoJ3NwYWNlU2VsZWN0JykpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgJGRvY3VtZW50LmRhdGEoJ3NwYWNlU2VsZWN0JywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kbmV3RWxlbWVudC5vbignc2hvdy5icy5kcm9wZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGF0LmRyb3Bkb3duICYmIHZlcnNpb24ubWFqb3IgPT09ICc0Jykge1xuICAgICAgICAgIHRoYXQuZHJvcGRvd24gPSB0aGF0LiRidXR0b24uZGF0YSgnYnMuZHJvcGRvd24nKTtcbiAgICAgICAgICB0aGF0LmRyb3Bkb3duLl9tZW51ID0gdGhhdC4kbWVudVswXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGF0Lm11bHRpcGxlKSB7XG4gICAgICAgICAgdGhhdC5kZXNlbGVjdEFsbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhhdC4kZWxlbWVudFswXSxcbiAgICAgICAgICAgICAgcHJldlZhbHVlID0gZWxlbWVudC52YWx1ZSxcbiAgICAgICAgICAgICAgcHJldkluZGV4ID0gZWxlbWVudC5zZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgICBwcmV2T3B0aW9uID0gZWxlbWVudC5vcHRpb25zW3ByZXZJbmRleF0sXG4gICAgICAgICAgICAgIHByZXZEYXRhID0gcHJldk9wdGlvbiA/IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtwcmV2T3B0aW9uLmxpSW5kZXhdIDogZmFsc2U7XG5cbiAgICAgICAgICBpZiAocHJldkRhdGEpIHtcbiAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0ZWQocHJldkRhdGEsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSAwO1xuXG4gICAgICAgICAgY2hhbmdlZEFyZ3VtZW50cyA9IFtwcmV2SW5kZXgsIGZhbHNlLCBwcmV2VmFsdWVdO1xuICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlck5hdGl2ZSgnY2hhbmdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgc2VsZWN0ZWQgc3R5bGluZyBpZiBtZW51IGlzIG9wZW5cbiAgICAgICAgaWYgKHRoYXQuJG5ld0VsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lcy5TSE9XKSkge1xuICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xuICAgICAgICAgICAgdGhhdC4kc2VhcmNoYm94LnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhhdC5jcmVhdGVWaWV3KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLiRidXR0b24ub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5hbGxvd0NsZWFyKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0LFxuICAgICAgICAgICAgICBjbGVhckJ1dHRvbiA9IHRoYXQuJGNsZWFyQnV0dG9uWzBdO1xuXG4gICAgICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGV2ZW50IGxpc3RlbmVycyBvbiBjaGlsZCBlbGVtZW50cyBvZiBidXR0b25zXG4gICAgICAgICAgaWYgKC9NU0lFfFRyaWRlbnQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGFyZ2V0ID09PSBjbGVhckJ1dHRvbiB8fCB0YXJnZXQucGFyZW50RWxlbWVudCA9PT0gY2xlYXJCdXR0b24pIHtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjbGVhclNlbGVjdGlvbihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoYXQuJG5ld0VsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lcy5TSE9XKSkge1xuICAgICAgICAgIHRoYXQuc2V0U2l6ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gc2V0Rm9jdXMgKCkge1xuICAgICAgICBpZiAodGhhdC5vcHRpb25zLmxpdmVTZWFyY2gpIHtcbiAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0LiRtZW51SW5uZXIudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1BvcHBlckV4aXN0cyAoKSB7XG4gICAgICAgIGlmICh0aGF0LmRyb3Bkb3duICYmIHRoYXQuZHJvcGRvd24uX3BvcHBlciAmJiB0aGF0LmRyb3Bkb3duLl9wb3BwZXIuc3RhdGUpIHtcbiAgICAgICAgICBzZXRGb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjaGVja1BvcHBlckV4aXN0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5vbignc2hvd24nICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGF0LiRtZW51SW5uZXJbMF0uc2Nyb2xsVG9wICE9PSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnNjcm9sbFRvcCkge1xuICAgICAgICAgIHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgPSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnNjcm9sbFRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2ZXJzaW9uLm1ham9yID4gMykge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjaGVja1BvcHBlckV4aXN0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0Rm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGVuc3VyZSBwb3NpbnNldCBhbmQgc2V0c2l6ZSBhcmUgY29ycmVjdCBiZWZvcmUgc2VsZWN0aW5nIGFuIG9wdGlvbiB2aWEgYSBjbGlja1xuICAgICAgdGhpcy4kbWVudUlubmVyLm9uKCdtb3VzZWVudGVyJywgJ2xpIGEnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaG92ZXJMaSA9IHRoaXMucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIHBvc2l0aW9uMCA9IHRoYXQuaXNWaXJ0dWFsKCkgPyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCA6IDAsXG4gICAgICAgICAgICBpbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoaG92ZXJMaS5wYXJlbnRFbGVtZW50LmNoaWxkcmVuLCBob3ZlckxpKSxcbiAgICAgICAgICAgIGhvdmVyRGF0YSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpbmRleCArIHBvc2l0aW9uMF07XG5cbiAgICAgICAgdGhhdC5mb2N1c0l0ZW0oaG92ZXJMaSwgaG92ZXJEYXRhLCB0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRtZW51SW5uZXIub24oJ2NsaWNrJywgJ2xpIGEnLCBmdW5jdGlvbiAoZSwgcmV0YWluQWN0aXZlKSB7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICBlbGVtZW50ID0gdGhhdC4kZWxlbWVudFswXSxcbiAgICAgICAgICAgIHBvc2l0aW9uMCA9IHRoYXQuaXNWaXJ0dWFsKCkgPyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCA6IDAsXG4gICAgICAgICAgICBjbGlja2VkRGF0YSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVskdGhpcy5wYXJlbnQoKS5pbmRleCgpICsgcG9zaXRpb24wXSxcbiAgICAgICAgICAgIGNsaWNrZWRFbGVtZW50ID0gY2xpY2tlZERhdGEuZWxlbWVudCxcbiAgICAgICAgICAgIHByZXZWYWx1ZSA9IGdldFNlbGVjdFZhbHVlcy5jYWxsKHRoYXQpLFxuICAgICAgICAgICAgcHJldkluZGV4ID0gZWxlbWVudC5zZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgcHJldk9wdGlvbiA9IGVsZW1lbnQub3B0aW9uc1twcmV2SW5kZXhdLFxuICAgICAgICAgICAgcHJldkRhdGEgPSBwcmV2T3B0aW9uID8gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW3ByZXZPcHRpb24ubGlJbmRleF0gOiBmYWxzZSxcbiAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UgPSB0cnVlO1xuXG4gICAgICAgIC8vIERvbid0IGNsb3NlIG9uIG11bHRpIGNob2ljZSBtZW51XG4gICAgICAgIGlmICh0aGF0Lm11bHRpcGxlICYmIHRoYXQub3B0aW9ucy5tYXhPcHRpb25zICE9PSAxKSB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBEb24ndCBydW4gaWYgdGhlIHNlbGVjdCBpcyBkaXNhYmxlZFxuICAgICAgICBpZiAoIXRoYXQuaXNEaXNhYmxlZCgpICYmICEkdGhpcy5wYXJlbnQoKS5oYXNDbGFzcyhjbGFzc05hbWVzLkRJU0FCTEVEKSkge1xuICAgICAgICAgIHZhciBvcHRpb24gPSBjbGlja2VkRGF0YS5vcHRpb24sXG4gICAgICAgICAgICAgICRvcHRpb24gPSAkKG9wdGlvbiksXG4gICAgICAgICAgICAgIHN0YXRlID0gb3B0aW9uLnNlbGVjdGVkLFxuICAgICAgICAgICAgICBvcHRncm91cERhdGEgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEuZmluZChmdW5jdGlvbiAoZGF0dW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW0ub3B0SUQgPT09IGNsaWNrZWREYXRhLm9wdElEICYmIGRhdHVtLnR5cGUgPT09ICdvcHRncm91cC1sYWJlbCc7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBvcHRncm91cCA9IG9wdGdyb3VwRGF0YSA/IG9wdGdyb3VwRGF0YS5vcHRncm91cCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZGF0YUdldHRlciA9IG9wdGdyb3VwIGluc3RhbmNlb2YgRWxlbWVudCA/IGdldE9wdGlvbkRhdGEuZnJvbU9wdGlvbiA6IGdldE9wdGlvbkRhdGEuZnJvbURhdGFTb3VyY2UsXG4gICAgICAgICAgICAgIG9wdGdyb3VwT3B0aW9ucyA9IG9wdGdyb3VwICYmIG9wdGdyb3VwLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBtYXhPcHRpb25zID0gcGFyc2VJbnQodGhhdC5vcHRpb25zLm1heE9wdGlvbnMpLFxuICAgICAgICAgICAgICBtYXhPcHRpb25zR3JwID0gb3B0Z3JvdXAgJiYgcGFyc2VJbnQoZGF0YUdldHRlcihvcHRncm91cCwgJ21heE9wdGlvbnMnKSkgfHwgZmFsc2U7XG5cbiAgICAgICAgICBpZiAoY2xpY2tlZEVsZW1lbnQgPT09IHRoYXQuYWN0aXZlRWxlbWVudCkgcmV0YWluQWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICghcmV0YWluQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGF0LnByZXZBY3RpdmVFbGVtZW50ID0gdGhhdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgdGhhdC5hY3RpdmVFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhhdC5tdWx0aXBsZSB8fCBtYXhPcHRpb25zID09PSAxKSB7IC8vIERlc2VsZWN0IHByZXZpb3VzIG9wdGlvbiBpZiBub3QgbXVsdGkgc2VsZWN0XG4gICAgICAgICAgICBpZiAocHJldkRhdGEpIHRoYXQuc2V0U2VsZWN0ZWQocHJldkRhdGEsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0ZWQoY2xpY2tlZERhdGEsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIFRvZ2dsZSB0aGUgY2xpY2tlZCBvcHRpb24gaWYgbXVsdGkgc2VsZWN0LlxuICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3RlZChjbGlja2VkRGF0YSwgIXN0YXRlKTtcbiAgICAgICAgICAgIHRoYXQuZm9jdXNlZFBhcmVudC5mb2N1cygpO1xuXG4gICAgICAgICAgICBpZiAobWF4T3B0aW9ucyAhPT0gZmFsc2UgfHwgbWF4T3B0aW9uc0dycCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdmFyIG1heFJlYWNoZWQgPSBtYXhPcHRpb25zIDwgZ2V0U2VsZWN0ZWRPcHRpb25zLmNhbGwodGhhdCkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRHcm91cE9wdGlvbnMgPSAwO1xuXG4gICAgICAgICAgICAgIGlmIChvcHRncm91cCAmJiBvcHRncm91cC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0Z3JvdXAuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvcHRncm91cC5jaGlsZHJlbltpXS5zZWxlY3RlZCkgc2VsZWN0ZWRHcm91cE9wdGlvbnMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbWF4UmVhY2hlZEdycCA9IG1heE9wdGlvbnNHcnAgPCBzZWxlY3RlZEdyb3VwT3B0aW9ucztcblxuICAgICAgICAgICAgICBpZiAoKG1heE9wdGlvbnMgJiYgbWF4UmVhY2hlZCkgfHwgKG1heE9wdGlvbnNHcnAgJiYgbWF4UmVhY2hlZEdycCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4T3B0aW9ucyAmJiBtYXhPcHRpb25zID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uU3RhdHVzKHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF4T3B0aW9uc0dycCAmJiBtYXhPcHRpb25zR3JwID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGdyb3VwT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX29wdGlvbiA9IG9wdGdyb3VwT3B0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3RlZCh0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbX29wdGlvbi5saUluZGV4XSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB0aGF0LnNldFNlbGVjdGVkKGNsaWNrZWREYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIG1heE9wdGlvbnNUZXh0ID0gdHlwZW9mIHRoYXQub3B0aW9ucy5tYXhPcHRpb25zVGV4dCA9PT0gJ3N0cmluZycgPyBbdGhhdC5vcHRpb25zLm1heE9wdGlvbnNUZXh0LCB0aGF0Lm9wdGlvbnMubWF4T3B0aW9uc1RleHRdIDogdGhhdC5vcHRpb25zLm1heE9wdGlvbnNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIG1heE9wdGlvbnNBcnIgPSB0eXBlb2YgbWF4T3B0aW9uc1RleHQgPT09ICdmdW5jdGlvbicgPyBtYXhPcHRpb25zVGV4dChtYXhPcHRpb25zLCBtYXhPcHRpb25zR3JwKSA6IG1heE9wdGlvbnNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIG1heFR4dCA9IG1heE9wdGlvbnNBcnJbMF0ucmVwbGFjZSgne259JywgbWF4T3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgbWF4VHh0R3JwID0gbWF4T3B0aW9uc0FyclsxXS5yZXBsYWNlKCd7bn0nLCBtYXhPcHRpb25zR3JwKSxcbiAgICAgICAgICAgICAgICAgICAgICAkbm90aWZ5ID0gJCgnPGRpdiBjbGFzcz1cIm5vdGlmeVwiPjwvZGl2PicpO1xuICAgICAgICAgICAgICAgICAgLy8gSWYge3Zhcn0gaXMgc2V0IGluIGFycmF5LCByZXBsYWNlIGl0XG4gICAgICAgICAgICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgICAgICAgICAgIGlmIChtYXhPcHRpb25zQXJyWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFR4dCA9IG1heFR4dC5yZXBsYWNlKCd7dmFyfScsIG1heE9wdGlvbnNBcnJbMl1bbWF4T3B0aW9ucyA+IDEgPyAwIDogMV0pO1xuICAgICAgICAgICAgICAgICAgICBtYXhUeHRHcnAgPSBtYXhUeHRHcnAucmVwbGFjZSgne3Zhcn0nLCBtYXhPcHRpb25zQXJyWzJdW21heE9wdGlvbnNHcnAgPiAxID8gMCA6IDFdKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdGhhdC4kbWVudS5hcHBlbmQoJG5vdGlmeSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChtYXhPcHRpb25zICYmIG1heFJlYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJG5vdGlmeS5hcHBlbmQoJCgnPGRpdj4nICsgbWF4VHh0ICsgJzwvZGl2PicpKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ21heFJlYWNoZWQnICsgRVZFTlRfS0VZKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKG1heE9wdGlvbnNHcnAgJiYgbWF4UmVhY2hlZEdycCkge1xuICAgICAgICAgICAgICAgICAgICAkbm90aWZ5LmFwcGVuZCgkKCc8ZGl2PicgKyBtYXhUeHRHcnAgKyAnPC9kaXY+JykpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignbWF4UmVhY2hlZEdycCcgKyBFVkVOVF9LRVkpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3RlZChjbGlja2VkRGF0YSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgfSwgMTApO1xuXG4gICAgICAgICAgICAgICAgICAkbm90aWZ5WzBdLmNsYXNzTGlzdC5hZGQoJ2ZhZGVPdXQnKTtcblxuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICRub3RpZnkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICB9LCAxMDUwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNvdXJjZS5kYXRhKSB0aGF0LiRlbGVtZW50WzBdLmFwcGVuZENoaWxkKHRoYXQuc2VsZWN0cGlja2VyLm1haW4ub3B0aW9uUXVldWUpO1xuXG4gICAgICAgICAgaWYgKCF0aGF0Lm11bHRpcGxlIHx8ICh0aGF0Lm11bHRpcGxlICYmIHRoYXQub3B0aW9ucy5tYXhPcHRpb25zID09PSAxKSkge1xuICAgICAgICAgICAgdGhhdC4kYnV0dG9uLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xuICAgICAgICAgICAgdGhhdC4kc2VhcmNoYm94LnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVHJpZ2dlciBzZWxlY3QgJ2NoYW5nZSdcbiAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKHRoYXQubXVsdGlwbGUgfHwgcHJldkluZGV4ICE9PSBlbGVtZW50LnNlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gJG9wdGlvbi5wcm9wKCdzZWxlY3RlZCcpIGlzIGN1cnJlbnQgb3B0aW9uIHN0YXRlIChzZWxlY3RlZC91bnNlbGVjdGVkKS4gcHJldlZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0IHByaW9yIHRvIGJlaW5nIGNoYW5nZWQuXG4gICAgICAgICAgICAgIGNoYW5nZWRBcmd1bWVudHMgPSBbb3B0aW9uLmluZGV4LCAkb3B0aW9uLnByb3AoJ3NlbGVjdGVkJyksIHByZXZWYWx1ZV07XG4gICAgICAgICAgICAgIHRoYXQuJGVsZW1lbnRcbiAgICAgICAgICAgICAgICAudHJpZ2dlck5hdGl2ZSgnY2hhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kbWVudS5vbignY2xpY2snLCAnbGkuJyArIGNsYXNzTmFtZXMuRElTQUJMRUQgKyAnIGEsIC4nICsgY2xhc3NOYW1lcy5QT1BPVkVSSEVBREVSICsgJywgLicgKyBjbGFzc05hbWVzLlBPUE9WRVJIRUFERVIgKyAnIDpub3QoLmNsb3NlKScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmN1cnJlbnRUYXJnZXQgPT0gdGhpcykge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCAmJiAhJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2Nsb3NlJykpIHtcbiAgICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LiRidXR0b24udHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRtZW51SW5uZXIub24oJ2NsaWNrJywgJy5kaXZpZGVyLCAuZHJvcGRvd24taGVhZGVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAodGhhdC5vcHRpb25zLmxpdmVTZWFyY2gpIHtcbiAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0LiRidXR0b24udHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJG1lbnUub24oJ2NsaWNrJywgJy4nICsgY2xhc3NOYW1lcy5QT1BPVkVSSEVBREVSICsgJyAuY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJHNlYXJjaGJveC5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJG1lbnUub24oJ2NsaWNrJywgJy5hY3Rpb25zLWJ0bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xuICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdicy1zZWxlY3QtYWxsJykpIHtcbiAgICAgICAgICB0aGF0LnNlbGVjdEFsbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoYXQuZGVzZWxlY3RBbGwoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJGJ1dHRvblxuICAgICAgICAub24oJ2ZvY3VzJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgdGFiaW5kZXggPSB0aGF0LiRlbGVtZW50WzBdLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcblxuICAgICAgICAgIC8vIG9ubHkgY2hhbmdlIHdoZW4gYnV0dG9uIGlzIGFjdHVhbGx5IGZvY3VzZWRcbiAgICAgICAgICBpZiAodGFiaW5kZXggIT09IHVuZGVmaW5lZCAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmlzVHJ1c3RlZCkge1xuICAgICAgICAgICAgLy8gYXBwbHkgc2VsZWN0IGVsZW1lbnQncyB0YWJpbmRleCB0byBlbnN1cmUgY29ycmVjdCBvcmRlciBpcyBmb2xsb3dlZCB3aGVuIHRhYmJpbmcgdG8gdGhlIG5leHQgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGFiaW5kZXgpO1xuICAgICAgICAgICAgLy8gc2V0IGVsZW1lbnQncyB0YWJpbmRleCB0byAtMSB0byBhbGxvdyBmb3IgcmV2ZXJzZSB0YWJiaW5nXG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50WzBdLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnRhYmluZGV4ID0gdGFiaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2JsdXInICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIHJldmVydCBldmVyeXRoaW5nIHRvIG9yaWdpbmFsIHRhYmluZGV4XG4gICAgICAgICAgaWYgKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudGFiaW5kZXggIT09IHVuZGVmaW5lZCAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmlzVHJ1c3RlZCkge1xuICAgICAgICAgICAgdGhhdC4kZWxlbWVudFswXS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGhhdC5zZWxlY3RwaWNrZXIudmlldy50YWJpbmRleCk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnRhYmluZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLm9uKCdjaGFuZ2UnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC5yZW5kZXIoKTtcbiAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZWQnICsgRVZFTlRfS0VZLCBjaGFuZ2VkQXJndW1lbnRzKTtcbiAgICAgICAgICBjaGFuZ2VkQXJndW1lbnRzID0gbnVsbDtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdmb2N1cycgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIXRoYXQub3B0aW9ucy5tb2JpbGUpIHRoYXQuJGJ1dHRvblswXS5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgbGl2ZVNlYXJjaExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJGJ1dHRvbi5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghIXRoYXQuJHNlYXJjaGJveC52YWwoKSkge1xuICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC52YWwoJycpO1xuICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnNlYXJjaC5wcmV2aW91c1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kc2VhcmNoYm94Lm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaSBmb2N1cy5icy5kcm9wZG93bi5kYXRhLWFwaSB0b3VjaGVuZC5icy5kcm9wZG93bi5kYXRhLWFwaScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kc2VhcmNoYm94Lm9uKCdpbnB1dCBwcm9wZXJ0eWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlYXJjaFZhbHVlID0gdGhhdC4kc2VhcmNoYm94WzBdLnZhbHVlO1xuXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnNlYXJjaC5lbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci5zZWFyY2guZGF0YSA9IFtdO1xuXG4gICAgICAgIGlmIChzZWFyY2hWYWx1ZSkge1xuICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnNlYXJjaC5wcmV2aW91c1ZhbHVlID0gc2VhcmNoVmFsdWU7XG5cbiAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNvdXJjZS5zZWFyY2gpIHtcbiAgICAgICAgICAgIHRoYXQuZmV0Y2hEYXRhKGZ1bmN0aW9uIChidWlsdERhdGEpIHtcbiAgICAgICAgICAgICAgdGhhdC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgdGhhdC5idWlsZExpc3QodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhhdC5ub1Njcm9sbCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoYXQuJG1lbnVJbm5lci5zY3JvbGxUb3AoMCk7XG4gICAgICAgICAgICAgIHRoYXQuY3JlYXRlVmlldyh0cnVlKTtcbiAgICAgICAgICAgICAgc2hvd05vUmVzdWx0cy5jYWxsKHRoYXQsIGJ1aWx0RGF0YSwgc2VhcmNoVmFsdWUpO1xuICAgICAgICAgICAgfSwgJ3NlYXJjaCcsIDAsIHNlYXJjaFZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgc2VhcmNoTWF0Y2ggPSBbXSxcbiAgICAgICAgICAgICAgICBxID0gc2VhcmNoVmFsdWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHt9LFxuICAgICAgICAgICAgICAgIGNhY2hlQXJyID0gW10sXG4gICAgICAgICAgICAgICAgc2VhcmNoU3R5bGUgPSB0aGF0Ll9zZWFyY2hTdHlsZSgpLFxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVNlYXJjaCA9IHRoYXQub3B0aW9ucy5saXZlU2VhcmNoTm9ybWFsaXplO1xuXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplU2VhcmNoKSBxID0gbm9ybWFsaXplVG9CYXNlKHEpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgbGkgPSB0aGF0LnNlbGVjdHBpY2tlci5tYWluLmRhdGFbaV07XG5cbiAgICAgICAgICAgICAgaWYgKCFjYWNoZVtpXSkge1xuICAgICAgICAgICAgICAgIGNhY2hlW2ldID0gc3RyaW5nU2VhcmNoKGxpLCBxLCBzZWFyY2hTdHlsZSwgbm9ybWFsaXplU2VhcmNoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjYWNoZVtpXSAmJiBsaS5oZWFkZXJJbmRleCAhPT0gdW5kZWZpbmVkICYmIGNhY2hlQXJyLmluZGV4T2YobGkuaGVhZGVySW5kZXgpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChsaS5oZWFkZXJJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGNhY2hlW2xpLmhlYWRlckluZGV4IC0gMV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2FjaGVBcnIucHVzaChsaS5oZWFkZXJJbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhY2hlW2xpLmhlYWRlckluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FjaGVBcnIucHVzaChsaS5oZWFkZXJJbmRleCk7XG5cbiAgICAgICAgICAgICAgICBjYWNoZVtsaS5sYXN0SW5kZXggKyAxXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY2FjaGVbaV0gJiYgbGkudHlwZSAhPT0gJ29wdGdyb3VwLWxhYmVsJykgY2FjaGVBcnIucHVzaChpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNhY2hlTGVuID0gY2FjaGVBcnIubGVuZ3RoOyBpIDwgY2FjaGVMZW47IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjYWNoZUFycltpXSxcbiAgICAgICAgICAgICAgICAgIHByZXZJbmRleCA9IGNhY2hlQXJyW2kgLSAxXSxcbiAgICAgICAgICAgICAgICAgIGxpID0gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgIGxpUHJldiA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtwcmV2SW5kZXhdO1xuXG4gICAgICAgICAgICAgIGlmIChsaS50eXBlICE9PSAnZGl2aWRlcicgfHwgKGxpLnR5cGUgPT09ICdkaXZpZGVyJyAmJiBsaVByZXYgJiYgbGlQcmV2LnR5cGUgIT09ICdkaXZpZGVyJyAmJiBjYWNoZUxlbiAtIDEgIT09IGkpKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLmRhdGEucHVzaChsaSk7XG4gICAgICAgICAgICAgICAgc2VhcmNoTWF0Y2gucHVzaCh0aGF0LnNlbGVjdHBpY2tlci5tYWluLmVsZW1lbnRzW2luZGV4XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5hY3RpdmVFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhhdC5ub1Njcm9sbCA9IHRydWU7XG4gICAgICAgICAgICB0aGF0LiRtZW51SW5uZXIuc2Nyb2xsVG9wKDApO1xuICAgICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLmVsZW1lbnRzID0gc2VhcmNoTWF0Y2g7XG4gICAgICAgICAgICB0aGF0LmNyZWF0ZVZpZXcodHJ1ZSk7XG4gICAgICAgICAgICBzaG93Tm9SZXN1bHRzLmNhbGwodGhhdCwgc2VhcmNoTWF0Y2gsIHNlYXJjaFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLnByZXZpb3VzVmFsdWUpIHsgLy8gZm9yIElFMTEgKCMyNDAyKVxuICAgICAgICAgIHRoYXQuJG1lbnVJbm5lci5zY3JvbGxUb3AoMCk7XG4gICAgICAgICAgdGhhdC5jcmVhdGVWaWV3KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9zZWFyY2hTdHlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5saXZlU2VhcmNoU3R5bGUgfHwgJ2NvbnRhaW5zJztcbiAgICB9LFxuXG4gICAgdmFsOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy4kZWxlbWVudFswXTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkT3B0aW9ucyA9IGdldFNlbGVjdGVkT3B0aW9ucy5jYWxsKHRoaXMpLFxuICAgICAgICAgICAgcHJldlZhbHVlID0gZ2V0U2VsZWN0VmFsdWVzLmNhbGwodGhpcywgc2VsZWN0ZWRPcHRpb25zKTtcblxuICAgICAgICBjaGFuZ2VkQXJndW1lbnRzID0gW251bGwsIG51bGwsIHByZXZWYWx1ZV07XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbIHZhbHVlIF07XG5cbiAgICAgICAgdmFsdWUubWFwKFN0cmluZyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHNlbGVjdGVkT3B0aW9uc1tpXTtcblxuICAgICAgICAgIGlmIChpdGVtICYmIHZhbHVlLmluZGV4T2YoU3RyaW5nKGl0ZW0udmFsdWUpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQoaXRlbSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgdXBkYXRlIHNlbGVjdGVkIHZhbHVlIGlmIGl0IG1hdGNoZXMgYW4gZXhpc3Rpbmcgb3B0aW9uXG4gICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihTdHJpbmcoaXRlbS52YWx1ZSkpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3RlZChpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3VyY2UuZGF0YSkgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdHBpY2tlci5tYWluLm9wdGlvblF1ZXVlKTtcblxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZWQnICsgRVZFTlRfS0VZLCBjaGFuZ2VkQXJndW1lbnRzKTtcblxuICAgICAgICBpZiAodGhpcy4kbmV3RWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLlNIT1cpKSB7XG4gICAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9uU3RhdHVzKHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGlTZWxlY3RlZEluZGV4ID0gKGVsZW1lbnQub3B0aW9uc1tlbGVtZW50LnNlbGVjdGVkSW5kZXhdIHx8IHt9KS5saUluZGV4O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpU2VsZWN0ZWRJbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3RlZCh0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbbGlTZWxlY3RlZEluZGV4XSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcblxuICAgICAgICBjaGFuZ2VkQXJndW1lbnRzID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gdGhpcy4kZWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50LnZhbCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGFuZ2VBbGw6IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgIGlmICghdGhpcy5tdWx0aXBsZSkgcmV0dXJuO1xuICAgICAgaWYgKHR5cGVvZiBzdGF0dXMgPT09ICd1bmRlZmluZWQnKSBzdGF0dXMgPSB0cnVlO1xuXG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuJGVsZW1lbnRbMF0sXG4gICAgICAgICAgcHJldmlvdXNTZWxlY3RlZCA9IDAsXG4gICAgICAgICAgY3VycmVudFNlbGVjdGVkID0gMCxcbiAgICAgICAgICBwcmV2VmFsdWUgPSBnZXRTZWxlY3RWYWx1ZXMuY2FsbCh0aGlzKTtcblxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdicy1zZWxlY3QtaGlkZGVuJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBkYXRhID0gdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBsaURhdGEgPSBkYXRhW2ldLFxuICAgICAgICAgICAgb3B0aW9uID0gbGlEYXRhLm9wdGlvbjtcblxuICAgICAgICBpZiAob3B0aW9uICYmICFsaURhdGEuZGlzYWJsZWQgJiYgbGlEYXRhLnR5cGUgIT09ICdkaXZpZGVyJykge1xuICAgICAgICAgIGlmIChsaURhdGEuc2VsZWN0ZWQpIHByZXZpb3VzU2VsZWN0ZWQrKztcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzdGF0dXM7XG4gICAgICAgICAgbGlEYXRhLnNlbGVjdGVkID0gc3RhdHVzO1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09IHRydWUpIGN1cnJlbnRTZWxlY3RlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnYnMtc2VsZWN0LWhpZGRlbicpO1xuXG4gICAgICBpZiAocHJldmlvdXNTZWxlY3RlZCA9PT0gY3VycmVudFNlbGVjdGVkKSByZXR1cm47XG5cbiAgICAgIHRoaXMuc2V0T3B0aW9uU3RhdHVzKCk7XG5cbiAgICAgIGNoYW5nZWRBcmd1bWVudHMgPSBbbnVsbCwgbnVsbCwgcHJldlZhbHVlXTtcblxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAudHJpZ2dlck5hdGl2ZSgnY2hhbmdlJyk7XG4gICAgfSxcblxuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQWxsKHRydWUpO1xuICAgIH0sXG5cbiAgICBkZXNlbGVjdEFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQWxsKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlOiBmdW5jdGlvbiAoZSwgc3RhdGUpIHtcbiAgICAgIHZhciBpc0FjdGl2ZSxcbiAgICAgICAgICB0cmlnZ2VyQ2xpY2sgPSBzdGF0ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgIGlmIChlKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAodHJpZ2dlckNsaWNrID09PSBmYWxzZSkge1xuICAgICAgICBpc0FjdGl2ZSA9IHRoaXMuJG5ld0VsZW1lbnRbMF0uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZXMuU0hPVyk7XG4gICAgICAgIHRyaWdnZXJDbGljayA9IHN0YXRlID09PSB0cnVlICYmIGlzQWN0aXZlID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gZmFsc2UgJiYgaXNBY3RpdmUgPT09IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmlnZ2VyQ2xpY2spIHRoaXMuJGJ1dHRvbi50cmlnZ2VyKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScpO1xuICAgIH0sXG5cbiAgICBvcGVuOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy50b2dnbGUoZSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIGNsb3NlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy50b2dnbGUoZSwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICBrZXlkb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICBpc1RvZ2dsZSA9ICR0aGlzLmhhc0NsYXNzKCdkcm9wZG93bi10b2dnbGUnKSxcbiAgICAgICAgICAkcGFyZW50ID0gaXNUb2dnbGUgPyAkdGhpcy5jbG9zZXN0KCcuZHJvcGRvd24nKSA6ICR0aGlzLmNsb3Nlc3QoU2VsZWN0b3IuTUVOVSksXG4gICAgICAgICAgdGhhdCA9ICRwYXJlbnQuZGF0YSgndGhpcycpLFxuICAgICAgICAgICRpdGVtcyA9IHRoYXQuZmluZExpcygpLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGlzQWN0aXZlLFxuICAgICAgICAgIGxpQWN0aXZlLFxuICAgICAgICAgIGFjdGl2ZUxpLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICB1cGRhdGVTY3JvbGwgPSBmYWxzZSxcbiAgICAgICAgICBkb3duT25UYWIgPSBlLndoaWNoID09PSBrZXlDb2Rlcy5UQUIgJiYgIWlzVG9nZ2xlICYmICF0aGF0Lm9wdGlvbnMuc2VsZWN0T25UYWIsXG4gICAgICAgICAgaXNBcnJvd0tleSA9IFJFR0VYUF9BUlJPVy50ZXN0KGUud2hpY2gpIHx8IGRvd25PblRhYixcbiAgICAgICAgICBzY3JvbGxUb3AgPSB0aGF0LiRtZW51SW5uZXJbMF0uc2Nyb2xsVG9wLFxuICAgICAgICAgIGlzVmlydHVhbCA9IHRoYXQuaXNWaXJ0dWFsKCksXG4gICAgICAgICAgcG9zaXRpb24wID0gaXNWaXJ0dWFsID09PSB0cnVlID8gdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjAgOiAwO1xuXG4gICAgICAvLyBkbyBub3RoaW5nIGlmIGEgZnVuY3Rpb24ga2V5IGlzIHByZXNzZWRcbiAgICAgIGlmIChlLndoaWNoID49IDExMiAmJiBlLndoaWNoIDw9IDEyMykgcmV0dXJuO1xuXG4gICAgICBpc0FjdGl2ZSA9IHRoYXQuJG1lbnUuaGFzQ2xhc3MoY2xhc3NOYW1lcy5TSE9XKTtcblxuICAgICAgaWYgKFxuICAgICAgICAhaXNBY3RpdmUgJiZcbiAgICAgICAgKFxuICAgICAgICAgIGlzQXJyb3dLZXkgfHxcbiAgICAgICAgICAoZS53aGljaCA+PSA0OCAmJiBlLndoaWNoIDw9IDU3KSB8fFxuICAgICAgICAgIChlLndoaWNoID49IDk2ICYmIGUud2hpY2ggPD0gMTA1KSB8fFxuICAgICAgICAgIChlLndoaWNoID49IDY1ICYmIGUud2hpY2ggPD0gOTApXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0aGF0LiRidXR0b24udHJpZ2dlcignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknKTtcblxuICAgICAgICBpZiAodGhhdC5vcHRpb25zLmxpdmVTZWFyY2gpIHtcbiAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGUud2hpY2ggPT09IGtleUNvZGVzLkVTQ0FQRSAmJiBpc0FjdGl2ZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScpLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Fycm93S2V5KSB7IC8vIGlmIHVwIG9yIGRvd25cbiAgICAgICAgaWYgKCEkaXRlbXMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgbGlBY3RpdmUgPSB0aGF0LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGluZGV4ID0gbGlBY3RpdmUgPyBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGxpQWN0aXZlLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4sIGxpQWN0aXZlKSA6IC0xO1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGF0LmRlZm9jdXNJdGVtKGxpQWN0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLndoaWNoID09PSBrZXlDb2Rlcy5BUlJPV19VUCkgeyAvLyB1cFxuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIGluZGV4LS07XG4gICAgICAgICAgaWYgKGluZGV4ICsgcG9zaXRpb24wIDwgMCkgaW5kZXggKz0gJGl0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgIGlmICghdGhhdC5zZWxlY3RwaWNrZXIudmlldy5jYW5IaWdobGlnaHRbaW5kZXggKyBwb3NpdGlvbjBdKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0LnNsaWNlKDAsIGluZGV4ICsgcG9zaXRpb24wKS5sYXN0SW5kZXhPZih0cnVlKSAtIHBvc2l0aW9uMDtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIGluZGV4ID0gJGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IGtleUNvZGVzLkFSUk9XX0RPV04gfHwgZG93bk9uVGFiKSB7IC8vIGRvd25cbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIGlmIChpbmRleCArIHBvc2l0aW9uMCA+PSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodC5sZW5ndGgpIGluZGV4ID0gdGhhdC5zZWxlY3RwaWNrZXIudmlldy5maXJzdEhpZ2hsaWdodEluZGV4O1xuXG4gICAgICAgICAgaWYgKCF0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodFtpbmRleCArIHBvc2l0aW9uMF0pIHtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxICsgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5jYW5IaWdobGlnaHQuc2xpY2UoaW5kZXggKyBwb3NpdGlvbjAgKyAxKS5pbmRleE9mKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgbGlBY3RpdmVJbmRleCA9IHBvc2l0aW9uMCArIGluZGV4O1xuXG4gICAgICAgIGlmIChlLndoaWNoID09PSBrZXlDb2Rlcy5BUlJPV19VUCkgeyAvLyB1cFxuICAgICAgICAgIC8vIHNjcm9sbCB0byBib3R0b20gYW5kIGhpZ2hsaWdodCBsYXN0IG9wdGlvblxuICAgICAgICAgIGlmIChwb3NpdGlvbjAgPT09IDAgJiYgaW5kZXggPT09ICRpdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aGF0LiRtZW51SW5uZXJbMF0uc2Nyb2xsVG9wID0gdGhhdC4kbWVudUlubmVyWzBdLnNjcm9sbEhlaWdodDtcblxuICAgICAgICAgICAgbGlBY3RpdmVJbmRleCA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlTGkgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbbGlBY3RpdmVJbmRleF07XG5cbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIHVuZGVmaW5lZCBpZiBubyByZXN1bHRzIGV4aXN0XG4gICAgICAgICAgICBpZiAoYWN0aXZlTGkpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gYWN0aXZlTGkucG9zaXRpb24gLSBhY3RpdmVMaS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgdXBkYXRlU2Nyb2xsID0gb2Zmc2V0IDwgc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09PSBrZXlDb2Rlcy5BUlJPV19ET1dOIHx8IGRvd25PblRhYikgeyAvLyBkb3duXG4gICAgICAgICAgLy8gc2Nyb2xsIHRvIHRvcCBhbmQgaGlnaGxpZ2h0IGZpcnN0IG9wdGlvblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhhdC5zZWxlY3RwaWNrZXIudmlldy5maXJzdEhpZ2hsaWdodEluZGV4KSB7XG4gICAgICAgICAgICB0aGF0LiRtZW51SW5uZXJbMF0uc2Nyb2xsVG9wID0gMDtcblxuICAgICAgICAgICAgbGlBY3RpdmVJbmRleCA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuZmlyc3RIaWdobGlnaHRJbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlTGkgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbbGlBY3RpdmVJbmRleF07XG5cbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIHVuZGVmaW5lZCBpZiBubyByZXN1bHRzIGV4aXN0XG4gICAgICAgICAgICBpZiAoYWN0aXZlTGkpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gYWN0aXZlTGkucG9zaXRpb24gLSB0aGF0LnNpemVJbmZvLm1lbnVJbm5lckhlaWdodDtcblxuICAgICAgICAgICAgICB1cGRhdGVTY3JvbGwgPSBvZmZzZXQgPiBzY3JvbGxUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGlBY3RpdmUgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmVsZW1lbnRzW2xpQWN0aXZlSW5kZXhdO1xuXG4gICAgICAgIHRoYXQuYWN0aXZlRWxlbWVudCA9ICh0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbbGlBY3RpdmVJbmRleF0gfHwge30pLmVsZW1lbnQ7XG5cbiAgICAgICAgdGhhdC5mb2N1c0l0ZW0obGlBY3RpdmUpO1xuXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY3VycmVudEFjdGl2ZSA9IGxpQWN0aXZlO1xuXG4gICAgICAgIGlmICh1cGRhdGVTY3JvbGwpIHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgPSBvZmZzZXQ7XG5cbiAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5saXZlU2VhcmNoKSB7XG4gICAgICAgICAgdGhhdC4kc2VhcmNoYm94LnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHRoaXMudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKCEkdGhpcy5pcygnaW5wdXQnKSAmJiAhUkVHRVhQX1RBQl9PUl9FU0NBUEUudGVzdChlLndoaWNoKSkgfHxcbiAgICAgICAgKGUud2hpY2ggPT09IGtleUNvZGVzLlNQQUNFICYmIHRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ua2V5SGlzdG9yeSlcbiAgICAgICkge1xuICAgICAgICB2YXIgc2VhcmNoTWF0Y2gsXG4gICAgICAgICAgICBtYXRjaGVzID0gW10sXG4gICAgICAgICAgICBrZXlIaXN0b3J5O1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci5rZXlkb3duLmtleUhpc3RvcnkgKz0ga2V5Q29kZU1hcFtlLndoaWNoXTtcblxuICAgICAgICBpZiAodGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5yZXNldEtleUhpc3RvcnkuY2FuY2VsKSBjbGVhclRpbWVvdXQodGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5yZXNldEtleUhpc3RvcnkuY2FuY2VsKTtcbiAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5yZXNldEtleUhpc3RvcnkuY2FuY2VsID0gdGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5yZXNldEtleUhpc3Rvcnkuc3RhcnQoKTtcblxuICAgICAgICBrZXlIaXN0b3J5ID0gdGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5rZXlIaXN0b3J5O1xuXG4gICAgICAgIC8vIGlmIGFsbCBsZXR0ZXJzIGFyZSB0aGUgc2FtZSwgc2V0IGtleUhpc3RvcnkgdG8ganVzdCB0aGUgZmlyc3QgY2hhcmFjdGVyIHdoZW4gc2VhcmNoaW5nXG4gICAgICAgIGlmICgvXiguKVxcMSskLy50ZXN0KGtleUhpc3RvcnkpKSB7XG4gICAgICAgICAga2V5SGlzdG9yeSA9IGtleUhpc3RvcnkuY2hhckF0KDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBtYXRjaGVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGxpID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2ldLFxuICAgICAgICAgICAgICBoYXNNYXRjaDtcblxuICAgICAgICAgIGhhc01hdGNoID0gc3RyaW5nU2VhcmNoKGxpLCBrZXlIaXN0b3J5LCAnc3RhcnRzV2l0aCcsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKGhhc01hdGNoICYmIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0W2ldKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2gobGkuZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG1hdGNoSW5kZXggPSAwO1xuXG4gICAgICAgICAgJGl0ZW1zLnJlbW92ZUNsYXNzKCdhY3RpdmUnKS5maW5kKCdhJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXG4gICAgICAgICAgLy8gZWl0aGVyIG9ubHkgb25lIGtleSBoYXMgYmVlbiBwcmVzc2VkIG9yIHRoZXkgYXJlIGFsbCB0aGUgc2FtZSBrZXlcbiAgICAgICAgICBpZiAoa2V5SGlzdG9yeS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIG1hdGNoSW5kZXggPSBtYXRjaGVzLmluZGV4T2YodGhhdC5hY3RpdmVFbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoSW5kZXggPT09IC0xIHx8IG1hdGNoSW5kZXggPT09IG1hdGNoZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBtYXRjaEluZGV4ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWFyY2hNYXRjaCA9IG1hdGNoZXNbbWF0Y2hJbmRleF07XG5cbiAgICAgICAgICBhY3RpdmVMaSA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtzZWFyY2hNYXRjaF07XG5cbiAgICAgICAgICBpZiAoc2Nyb2xsVG9wIC0gYWN0aXZlTGkucG9zaXRpb24gPiAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBhY3RpdmVMaS5wb3NpdGlvbiAtIGFjdGl2ZUxpLmhlaWdodDtcbiAgICAgICAgICAgIHVwZGF0ZVNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGFjdGl2ZUxpLnBvc2l0aW9uIC0gdGhhdC5zaXplSW5mby5tZW51SW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICAvLyBpZiB0aGUgb3B0aW9uIGlzIGFscmVhZHkgdmlzaWJsZSBhdCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24sIGp1c3Qga2VlcCBpdCB0aGUgc2FtZVxuICAgICAgICAgICAgdXBkYXRlU2Nyb2xsID0gYWN0aXZlTGkucG9zaXRpb24gPiBzY3JvbGxUb3AgKyB0aGF0LnNpemVJbmZvLm1lbnVJbm5lckhlaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaUFjdGl2ZSA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHNbc2VhcmNoTWF0Y2hdO1xuXG4gICAgICAgICAgdGhhdC5hY3RpdmVFbGVtZW50ID0gbGlBY3RpdmU7XG5cbiAgICAgICAgICB0aGF0LmZvY3VzSXRlbShsaUFjdGl2ZSk7XG5cbiAgICAgICAgICBpZiAobGlBY3RpdmUpIGxpQWN0aXZlLmZpcnN0Q2hpbGQuZm9jdXMoKTtcblxuICAgICAgICAgIGlmICh1cGRhdGVTY3JvbGwpIHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgPSBvZmZzZXQ7XG5cbiAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNlbGVjdCBmb2N1c2VkIG9wdGlvbiBpZiBcIkVudGVyXCIsIFwiU3BhY2ViYXJcIiBvciBcIlRhYlwiICh3aGVuIHNlbGVjdE9uVGFiIGlzIHRydWUpIGFyZSBwcmVzc2VkIGluc2lkZSB0aGUgbWVudS5cbiAgICAgIGlmIChcbiAgICAgICAgaXNBY3RpdmUgJiZcbiAgICAgICAgKFxuICAgICAgICAgIChlLndoaWNoID09PSBrZXlDb2Rlcy5TUEFDRSAmJiAhdGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5rZXlIaXN0b3J5KSB8fFxuICAgICAgICAgIGUud2hpY2ggPT09IGtleUNvZGVzLkVOVEVSIHx8XG4gICAgICAgICAgKGUud2hpY2ggPT09IGtleUNvZGVzLlRBQiAmJiB0aGF0Lm9wdGlvbnMuc2VsZWN0T25UYWIpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBpZiAoZS53aGljaCAhPT0ga2V5Q29kZXMuU1BBQ0UpIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIXRoYXQub3B0aW9ucy5saXZlU2VhcmNoIHx8IGUud2hpY2ggIT09IGtleUNvZGVzLlNQQUNFKSB7XG4gICAgICAgICAgdGhhdC4kbWVudUlubmVyLmZpbmQoJy5hY3RpdmUgYScpLnRyaWdnZXIoJ2NsaWNrJywgdHJ1ZSk7IC8vIHJldGFpbiBhY3RpdmUgY2xhc3NcbiAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdmb2N1cycpO1xuXG4gICAgICAgICAgaWYgKCF0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBzY3JlZW4gZnJvbSBzY3JvbGxpbmcgaWYgdGhlIHVzZXIgaGl0cyB0aGUgc3BhY2ViYXJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIC8vIEZpeGVzIHNwYWNlYmFyIHNlbGVjdGlvbiBvZiBkcm9wZG93biBpdGVtcyBpbiBGRiAmIElFXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5kYXRhKCdzcGFjZVNlbGVjdCcsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBtb2JpbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVuc3VyZSBtb2JpbGUgaXMgc2V0IHRvIHRydWUgaWYgbW9iaWxlIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciBpbml0XG4gICAgICB0aGlzLm9wdGlvbnMubW9iaWxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NMaXN0LmFkZCgnbW9iaWxlLWRldmljZScpO1xuICAgIH0sXG5cbiAgICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAvLyB1cGRhdGUgb3B0aW9ucyBpZiBkYXRhIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIGNoYW5nZWRcbiAgICAgIHZhciBjb25maWcgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBnZXRBdHRyaWJ1dGVzT2JqZWN0KHRoaXMuJGVsZW1lbnQpLCB0aGlzLiRlbGVtZW50LmRhdGEoKSk7IC8vIGluIHRoaXMgb3JkZXIgb24gcmVmcmVzaCwgYXMgdXNlciBtYXkgY2hhbmdlIGF0dHJpYnV0ZXMgb24gc2VsZWN0LCBhbmQgb3B0aW9ucyBvYmplY3QgaXMgbm90IHBhc3NlZCBvbiByZWZyZXNoXG4gICAgICB0aGlzLm9wdGlvbnMgPSBjb25maWc7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc291cmNlLmRhdGEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5idWlsZExpc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmV0Y2hEYXRhKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnJlbmRlcigpO1xuICAgICAgICAgIHRoYXQuYnVpbGRMaXN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoZWNrRGlzYWJsZWQoKTtcbiAgICAgIHRoaXMuc2V0U3R5bGUoKTtcbiAgICAgIHRoaXMuc2V0V2lkdGgoKTtcblxuICAgICAgdGhpcy5zZXRTaXplKHRydWUpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3JlZnJlc2hlZCcgKyBFVkVOVF9LRVkpO1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLiRuZXdFbGVtZW50LmhpZGUoKTtcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy4kbmV3RWxlbWVudC5zaG93KCk7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy4kbmV3RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuJG5ld0VsZW1lbnQuYmVmb3JlKHRoaXMuJGVsZW1lbnQpLnJlbW92ZSgpO1xuXG4gICAgICBpZiAodGhpcy4kYnNDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy4kYnNDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRtZW51LnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbiAmJiB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2VsZWN0cGlja2VyLnZpZXcudGl0bGVPcHRpb24pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5vZmYoRVZFTlRfS0VZKVxuICAgICAgICAucmVtb3ZlRGF0YSgnc2VsZWN0cGlja2VyJylcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdicy1zZWxlY3QtaGlkZGVuIHNlbGVjdHBpY2tlciBtb2JpbGUtZGV2aWNlJyk7XG5cbiAgICAgICQod2luZG93KS5vZmYoRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNFTEVDVFBJQ0tFUiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gUGx1Z2luIChvcHRpb24pIHtcbiAgICAvLyBnZXQgdGhlIGFyZ3Mgb2YgdGhlIG91dGVyIGZ1bmN0aW9uLi5cbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAvLyBUaGUgYXJndW1lbnRzIG9mIHRoZSBmdW5jdGlvbiBhcmUgZXhwbGljaXRseSByZS1kZWZpbmVkIGZyb20gdGhlIGFyZ3VtZW50IGxpc3QsIGJlY2F1c2UgdGhlIHNoaWZ0IGNhdXNlcyB0aGVtXG4gICAgLy8gdG8gZ2V0IGxvc3QvY29ycnVwdGVkIGluIGFuZHJvaWQgMi4zIGFuZCBJRTkgIzcxNSAjNzc1XG4gICAgdmFyIF9vcHRpb24gPSBvcHRpb247XG5cbiAgICBbXS5zaGlmdC5hcHBseShhcmdzKTtcblxuICAgIC8vIGlmIHRoZSB2ZXJzaW9uIHdhcyBub3Qgc2V0IHN1Y2Nlc3NmdWxseVxuICAgIGlmICghdmVyc2lvbi5zdWNjZXNzKSB7XG4gICAgICAvLyB0cnkgdG8gcmV0cmVpdmUgaXQgYWdhaW5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24uZnVsbCA9IChnZXRWZXJzaW9uKCkgfHwgJycpLnNwbGl0KCcgJylbMF0uc3BsaXQoJy4nKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdXNlIEJvb3RzdHJhcFZlcnNpb24gaWYgc2V0XG4gICAgICAgIGlmIChTZWxlY3RwaWNrZXIuQm9vdHN0cmFwVmVyc2lvbikge1xuICAgICAgICAgIHZlcnNpb24uZnVsbCA9IFNlbGVjdHBpY2tlci5Cb290c3RyYXBWZXJzaW9uLnNwbGl0KCcgJylbMF0uc3BsaXQoJy4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ZXJzaW9uLmZ1bGwgPSBbdmVyc2lvbi5tYWpvciwgJzAnLCAnMCddO1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ1RoZXJlIHdhcyBhbiBpc3N1ZSByZXRyaWV2aW5nIEJvb3RzdHJhcFxcJ3MgdmVyc2lvbi4gJyArXG4gICAgICAgICAgICAnRW5zdXJlIEJvb3RzdHJhcCBpcyBiZWluZyBsb2FkZWQgYmVmb3JlIGJvb3RzdHJhcC1zZWxlY3QgYW5kIHRoZXJlIGlzIG5vIG5hbWVzcGFjZSBjb2xsaXNpb24uICcgK1xuICAgICAgICAgICAgJ0lmIGxvYWRpbmcgQm9vdHN0cmFwIGFzeW5jaHJvbm91c2x5LCB0aGUgdmVyc2lvbiBtYXkgbmVlZCB0byBiZSBtYW51YWxseSBzcGVjaWZpZWQgdmlhICQuZm4uc2VsZWN0cGlja2VyLkNvbnN0cnVjdG9yLkJvb3RzdHJhcFZlcnNpb24uJyxcbiAgICAgICAgICAgIGVyclxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmVyc2lvbi5tYWpvciA9IHZlcnNpb24uZnVsbFswXTtcbiAgICAgIHZlcnNpb24uc3VjY2VzcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24ubWFqb3IgPj0gJzQnKSB7XG4gICAgICAvLyBzb21lIGRlZmF1bHRzIG5lZWQgdG8gYmUgY2hhbmdlZCBpZiB1c2luZyBCb290c3RyYXAgNFxuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZXkgaGF2ZSBhbHJlYWR5IGJlZW4gbWFudWFsbHkgY2hhbmdlZCBiZWZvcmUgZm9yY2luZyB0aGVtIHRvIHVwZGF0ZVxuICAgICAgdmFyIHRvVXBkYXRlID0gW107XG5cbiAgICAgIGlmIChTZWxlY3RwaWNrZXIuREVGQVVMVFMuc3R5bGUgPT09IGNsYXNzTmFtZXMuQlVUVE9OQ0xBU1MpIHRvVXBkYXRlLnB1c2goeyBuYW1lOiAnc3R5bGUnLCBjbGFzc05hbWU6ICdCVVRUT05DTEFTUycgfSk7XG4gICAgICBpZiAoU2VsZWN0cGlja2VyLkRFRkFVTFRTLmljb25CYXNlID09PSBjbGFzc05hbWVzLklDT05CQVNFKSB0b1VwZGF0ZS5wdXNoKHsgbmFtZTogJ2ljb25CYXNlJywgY2xhc3NOYW1lOiAnSUNPTkJBU0UnIH0pO1xuICAgICAgaWYgKFNlbGVjdHBpY2tlci5ERUZBVUxUUy50aWNrSWNvbiA9PT0gY2xhc3NOYW1lcy5USUNLSUNPTikgdG9VcGRhdGUucHVzaCh7IG5hbWU6ICd0aWNrSWNvbicsIGNsYXNzTmFtZTogJ1RJQ0tJQ09OJyB9KTtcblxuICAgICAgY2xhc3NOYW1lcy5ESVZJREVSID0gJ2Ryb3Bkb3duLWRpdmlkZXInO1xuICAgICAgY2xhc3NOYW1lcy5TSE9XID0gJ3Nob3cnO1xuICAgICAgY2xhc3NOYW1lcy5CVVRUT05DTEFTUyA9ICdidG4tbGlnaHQnO1xuICAgICAgY2xhc3NOYW1lcy5QT1BPVkVSSEVBREVSID0gJ3BvcG92ZXItaGVhZGVyJztcbiAgICAgIGNsYXNzTmFtZXMuSUNPTkJBU0UgPSAnJztcbiAgICAgIGNsYXNzTmFtZXMuVElDS0lDT04gPSAnYnMtb2stZGVmYXVsdCc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IHRvVXBkYXRlW2ldO1xuICAgICAgICBTZWxlY3RwaWNrZXIuREVGQVVMVFNbb3B0aW9uLm5hbWVdID0gY2xhc3NOYW1lc1tvcHRpb24uY2xhc3NOYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5tYWpvciA+ICc0Jykge1xuICAgICAgU2VsZWN0b3IuREFUQV9UT0dHTEUgPSAnZGF0YS1icy10b2dnbGU9XCJkcm9wZG93blwiJztcbiAgICB9XG5cbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGNoYWluID0gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICBpZiAoJHRoaXMuaXMoJ3NlbGVjdCcpKSB7XG4gICAgICAgIHZhciBkYXRhID0gJHRoaXMuZGF0YSgnc2VsZWN0cGlja2VyJyksXG4gICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIF9vcHRpb24gPT0gJ29iamVjdCcgJiYgX29wdGlvbjtcblxuICAgICAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgLy8gKHVzaW5nIHRpdGxlIGFzIHBsYWNlaG9sZGVyIGlzIGRlcHJlY2F0ZWQgLSByZW1vdmUgaW4gdjIuMC4wKVxuICAgICAgICBpZiAob3B0aW9ucy50aXRsZSkgb3B0aW9ucy5wbGFjZWhvbGRlciA9IG9wdGlvbnMudGl0bGU7XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgdmFyIGRhdGFBdHRyaWJ1dGVzID0gJHRoaXMuZGF0YSgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgZGF0YUF0dHIgaW4gZGF0YUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YUF0dHJpYnV0ZXMsIGRhdGFBdHRyKSAmJiAkLmluQXJyYXkoZGF0YUF0dHIsIERJU0FMTE9XRURfQVRUUklCVVRFUykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBkYXRhQXR0cmlidXRlc1tkYXRhQXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCBTZWxlY3RwaWNrZXIuREVGQVVMVFMsICQuZm4uc2VsZWN0cGlja2VyLmRlZmF1bHRzIHx8IHt9LCBnZXRBdHRyaWJ1dGVzT2JqZWN0KCR0aGlzKSwgZGF0YUF0dHJpYnV0ZXMsIG9wdGlvbnMpOyAvLyB0aGlzIGlzIGNvcnJlY3Qgb3JkZXIgb24gaW5pdGlhbCByZW5kZXJcbiAgICAgICAgICBjb25maWcudGVtcGxhdGUgPSAkLmV4dGVuZCh7fSwgU2VsZWN0cGlja2VyLkRFRkFVTFRTLnRlbXBsYXRlLCAoJC5mbi5zZWxlY3RwaWNrZXIuZGVmYXVsdHMgPyAkLmZuLnNlbGVjdHBpY2tlci5kZWZhdWx0cy50ZW1wbGF0ZSA6IHt9KSwgZGF0YUF0dHJpYnV0ZXMudGVtcGxhdGUsIG9wdGlvbnMudGVtcGxhdGUpO1xuICAgICAgICAgIGNvbmZpZy5zb3VyY2UgPSAkLmV4dGVuZCh7fSwgU2VsZWN0cGlja2VyLkRFRkFVTFRTLnNvdXJjZSwgKCQuZm4uc2VsZWN0cGlja2VyLmRlZmF1bHRzID8gJC5mbi5zZWxlY3RwaWNrZXIuZGVmYXVsdHMuc291cmNlIDoge30pLCBvcHRpb25zLnNvdXJjZSk7XG4gICAgICAgICAgJHRoaXMuZGF0YSgnc2VsZWN0cGlja2VyJywgKGRhdGEgPSBuZXcgU2VsZWN0cGlja2VyKHRoaXMsIGNvbmZpZykpKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGkpKSB7XG4gICAgICAgICAgICAgIGRhdGEub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfb3B0aW9uID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGRhdGFbX29wdGlvbl0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFsdWUgPSBkYXRhW19vcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGRhdGEub3B0aW9uc1tfb3B0aW9uXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRBc3NpZ25tZW50XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjaGFpbjtcbiAgICB9XG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5zZWxlY3RwaWNrZXI7XG4gICQuZm4uc2VsZWN0cGlja2VyID0gUGx1Z2luO1xuICAkLmZuLnNlbGVjdHBpY2tlci5Db25zdHJ1Y3RvciA9IFNlbGVjdHBpY2tlcjtcblxuICAvLyBTRUxFQ1RQSUNLRVIgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09XG4gICQuZm4uc2VsZWN0cGlja2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5zZWxlY3RwaWNrZXIgPSBvbGQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gZ2V0IEJvb3RzdHJhcCdzIGtleWRvd24gZXZlbnQgaGFuZGxlciBmb3IgZWl0aGVyIEJvb3RzdHJhcCA0IG9yIEJvb3RzdHJhcCAzXG4gIGZ1bmN0aW9uIGtleWRvd25IYW5kbGVyICgpIHtcbiAgICBpZiAodmVyc2lvbi5tYWpvciA8IDUpIHtcbiAgICAgIGlmICgkLmZuLmRyb3Bkb3duKSB7XG4gICAgICAgIC8vIHdhaXQgdG8gZGVmaW5lIHVudGlsIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbiBjYXNlIEJvb3RzdHJhcCBpc24ndCBsb2FkZWQgeWV0XG4gICAgICAgIHZhciBib290c3RyYXBLZXlkb3duID0gJC5mbi5kcm9wZG93bi5Db25zdHJ1Y3Rvci5fZGF0YUFwaUtleWRvd25IYW5kbGVyIHx8ICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IucHJvdG90eXBlLmtleWRvd247XG4gICAgICAgIHJldHVybiBib290c3RyYXBLZXlkb3duLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEcm9wZG93bi5kYXRhQXBpS2V5ZG93bkhhbmRsZXI7XG4gICAgfVxuICB9XG5cbiAgJChkb2N1bWVudClcbiAgICAub2ZmKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJylcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnOm5vdCguYm9vdHN0cmFwLXNlbGVjdCkgPiBbJyArIFNlbGVjdG9yLkRBVEFfVE9HR0xFICsgJ10nLCBrZXlkb3duSGFuZGxlcilcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnOm5vdCguYm9vdHN0cmFwLXNlbGVjdCkgPiAuZHJvcGRvd24tbWVudScsIGtleWRvd25IYW5kbGVyKVxuICAgIC5vbigna2V5ZG93bicgKyBFVkVOVF9LRVksICcuYm9vdHN0cmFwLXNlbGVjdCBbJyArIFNlbGVjdG9yLkRBVEFfVE9HR0xFICsgJ10sIC5ib290c3RyYXAtc2VsZWN0IFtyb2xlPVwibGlzdGJveFwiXSwgLmJvb3RzdHJhcC1zZWxlY3QgLmJzLXNlYXJjaGJveCBpbnB1dCcsIFNlbGVjdHBpY2tlci5wcm90b3R5cGUua2V5ZG93bilcbiAgICAub24oJ2ZvY3VzaW4ubW9kYWwnLCAnLmJvb3RzdHJhcC1zZWxlY3QgWycgKyBTZWxlY3Rvci5EQVRBX1RPR0dMRSArICddLCAuYm9vdHN0cmFwLXNlbGVjdCBbcm9sZT1cImxpc3Rib3hcIl0sIC5ib290c3RyYXAtc2VsZWN0IC5icy1zZWFyY2hib3ggaW5wdXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcblxuICAvLyBTRUxFQ1RQSUNLRVIgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnLnNlbGVjdHBpY2tlcicpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRzZWxlY3RwaWNrZXIgPSAkKHRoaXMpO1xuICAgICAgUGx1Z2luLmNhbGwoJHNlbGVjdHBpY2tlciwgJHNlbGVjdHBpY2tlci5kYXRhKCkpO1xuICAgIH0pO1xuICB9KTtcbn0pKGpRdWVyeSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bootstrap-select/js/bootstrap-select.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/bootstrap-select/bootstrap-select.js");
/******/ 	var __webpack_export_target__ = window;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;