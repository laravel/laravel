/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/datatables-responsive/datatables.responsive.js":
/*!*************************************************************!*\
  !*** ./libs/datatables-responsive/datatables.responsive.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var datatables_net_responsive_js_dataTables_responsive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! datatables.net-responsive/js/dataTables.responsive */ "./node_modules/datatables.net-responsive/js/dataTables.responsive.js");
/* harmony import */ var datatables_net_responsive_js_dataTables_responsive__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(datatables_net_responsive_js_dataTables_responsive__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./node_modules/datatables.net-responsive/js/dataTables.responsive.js":
/*!****************************************************************************!*\
  !*** ./node_modules/datatables.net-responsive/js/dataTables.responsive.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Responsive 2.2.9\n * 2014-2021 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     Responsive\n * @description Responsive tables plug-in for DataTables\n * @version     2.2.9\n * @file        dataTables.responsive.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2014-2021 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! datatables.net */ \"datatables.net\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n/**\n * Responsive is a plug-in for the DataTables library that makes use of\n * DataTables' ability to change the visibility of columns, changing the\n * visibility of columns so the displayed columns fit into the table container.\n * The end result is that complex tables will be dynamically adjusted to fit\n * into the viewport, be it on a desktop, tablet or mobile browser.\n *\n * Responsive for DataTables has two modes of operation, which can used\n * individually or combined:\n *\n * * Class name based control - columns assigned class names that match the\n *   breakpoint logic can be shown / hidden as required for each breakpoint.\n * * Automatic control - columns are automatically hidden when there is no\n *   room left to display them. Columns removed from the right.\n *\n * In additional to column visibility control, Responsive also has built into\n * options to use DataTables' child row display to show / hide the information\n * from the table that has been hidden. There are also two modes of operation\n * for this child row display:\n *\n * * Inline - when the control element that the user can use to show / hide\n *   child rows is displayed inside the first column of the table.\n * * Column - where a whole column is dedicated to be the show / hide control.\n *\n * Initialisation of Responsive is performed by:\n *\n * * Adding the class `responsive` or `dt-responsive` to the table. In this case\n *   Responsive will automatically be initialised with the default configuration\n *   options when the DataTable is created.\n * * Using the `responsive` option in the DataTables configuration options. This\n *   can also be used to specify the configuration options, or simply set to\n *   `true` to use the defaults.\n *\n *  @class\n *  @param {object} settings DataTables settings object for the host table\n *  @param {object} [opts] Configuration options\n *  @requires jQuery 1.7+\n *  @requires DataTables 1.10.3+\n *\n *  @example\n *      $('#example').DataTable( {\n *        responsive: true\n *      } );\n *    } );\n */\nvar Responsive = function ( settings, opts ) {\n\t// Sanity check that we are using DataTables 1.10 or newer\n\tif ( ! DataTable.versionCheck || ! DataTable.versionCheck( '1.10.10' ) ) {\n\t\tthrow 'DataTables Responsive requires DataTables 1.10.10 or newer';\n\t}\n\n\tthis.s = {\n\t\tdt: new DataTable.Api( settings ),\n\t\tcolumns: [],\n\t\tcurrent: []\n\t};\n\n\t// Check if responsive has already been initialised on this table\n\tif ( this.s.dt.settings()[0].responsive ) {\n\t\treturn;\n\t}\n\n\t// details is an object, but for simplicity the user can give it as a string\n\t// or a boolean\n\tif ( opts && typeof opts.details === 'string' ) {\n\t\topts.details = { type: opts.details };\n\t}\n\telse if ( opts && opts.details === false ) {\n\t\topts.details = { type: false };\n\t}\n\telse if ( opts && opts.details === true ) {\n\t\topts.details = { type: 'inline' };\n\t}\n\n\tthis.c = $.extend( true, {}, Responsive.defaults, DataTable.defaults.responsive, opts );\n\tsettings.responsive = this;\n\tthis._constructor();\n};\n\n$.extend( Responsive.prototype, {\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Constructor\n\t */\n\n\t/**\n\t * Initialise the Responsive instance\n\t *\n\t * @private\n\t */\n\t_constructor: function ()\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dt;\n\t\tvar dtPrivateSettings = dt.settings()[0];\n\t\tvar oldWindowWidth = $(window).innerWidth();\n\n\t\tdt.settings()[0]._responsive = this;\n\n\t\t// Use DataTables' throttle function to avoid processor thrashing on\n\t\t// resize\n\t\t$(window).on( 'resize.dtr orientationchange.dtr', DataTable.util.throttle( function () {\n\t\t\t// iOS has a bug whereby resize can fire when only scrolling\n\t\t\t// See: http://stackoverflow.com/questions/8898412\n\t\t\tvar width = $(window).innerWidth();\n\n\t\t\tif ( width !== oldWindowWidth ) {\n\t\t\t\tthat._resize();\n\t\t\t\toldWindowWidth = width;\n\t\t\t}\n\t\t} ) );\n\n\t\t// DataTables doesn't currently trigger an event when a row is added, so\n\t\t// we need to hook into its private API to enforce the hidden rows when\n\t\t// new data is added\n\t\tdtPrivateSettings.oApi._fnCallbackReg( dtPrivateSettings, 'aoRowCreatedCallback', function (tr, data, idx) {\n\t\t\tif ( $.inArray( false, that.s.current ) !== -1 ) {\n\t\t\t\t$('>td, >th', tr).each( function ( i ) {\n\t\t\t\t\tvar idx = dt.column.index( 'toData', i );\n\n\t\t\t\t\tif ( that.s.current[idx] === false ) {\n\t\t\t\t\t\t$(this).css('display', 'none');\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\t// Destroy event handler\n\t\tdt.on( 'destroy.dtr', function () {\n\t\t\tdt.off( '.dtr' );\n\t\t\t$( dt.table().body() ).off( '.dtr' );\n\t\t\t$(window).off( 'resize.dtr orientationchange.dtr' );\n\t\t\tdt.cells('.dtr-control').nodes().to$().removeClass('dtr-control');\n\n\t\t\t// Restore the columns that we've hidden\n\t\t\t$.each( that.s.current, function ( i, val ) {\n\t\t\t\tif ( val === false ) {\n\t\t\t\t\tthat._setColumnVis( i, true );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\n\t\t// Reorder the breakpoints array here in case they have been added out\n\t\t// of order\n\t\tthis.c.breakpoints.sort( function (a, b) {\n\t\t\treturn a.width < b.width ? 1 :\n\t\t\t\ta.width > b.width ? -1 : 0;\n\t\t} );\n\n\t\tthis._classLogic();\n\t\tthis._resizeAuto();\n\n\t\t// Details handler\n\t\tvar details = this.c.details;\n\n\t\tif ( details.type !== false ) {\n\t\t\tthat._detailsInit();\n\n\t\t\t// DataTables will trigger this event on every column it shows and\n\t\t\t// hides individually\n\t\t\tdt.on( 'column-visibility.dtr', function () {\n\t\t\t\t// Use a small debounce to allow multiple columns to be set together\n\t\t\t\tif ( that._timer ) {\n\t\t\t\t\tclearTimeout( that._timer );\n\t\t\t\t}\n\n\t\t\t\tthat._timer = setTimeout( function () {\n\t\t\t\t\tthat._timer = null;\n\n\t\t\t\t\tthat._classLogic();\n\t\t\t\t\tthat._resizeAuto();\n\t\t\t\t\tthat._resize(true);\n\n\t\t\t\t\tthat._redrawChildren();\n\t\t\t\t}, 100 );\n\t\t\t} );\n\n\t\t\t// Redraw the details box on each draw which will happen if the data\n\t\t\t// has changed. This is used until DataTables implements a native\n\t\t\t// `updated` event for rows\n\t\t\tdt.on( 'draw.dtr', function () {\n\t\t\t\tthat._redrawChildren();\n\t\t\t} );\n\n\t\t\t$(dt.table().node()).addClass( 'dtr-'+details.type );\n\t\t}\n\n\t\tdt.on( 'column-reorder.dtr', function (e, settings, details) {\n\t\t\tthat._classLogic();\n\t\t\tthat._resizeAuto();\n\t\t\tthat._resize(true);\n\t\t} );\n\n\t\t// Change in column sizes means we need to calc\n\t\tdt.on( 'column-sizing.dtr', function () {\n\t\t\tthat._resizeAuto();\n\t\t\tthat._resize();\n\t\t});\n\n\t\t// DT2 let's us tell it if we are hiding columns\n\t\tdt.on( 'column-calc.dt', function (e, d) {\n\t\t\tvar curr = that.s.current;\n\n\t\t\tfor (var i=0 ; i<curr.length ; i++) {\n\t\t\t\tvar idx = d.visible.indexOf(i);\n\n\t\t\t\tif (curr[i] === false && idx >= 0) {\n\t\t\t\t\td.visible.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// On Ajax reload we want to reopen any child rows which are displayed\n\t\t// by responsive\n\t\tdt.on( 'preXhr.dtr', function () {\n\t\t\tvar rowIds = [];\n\t\t\tdt.rows().every( function () {\n\t\t\t\tif ( this.child.isShown() ) {\n\t\t\t\t\trowIds.push( this.id(true) );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tdt.one( 'draw.dtr', function () {\n\t\t\t\tthat._resizeAuto();\n\t\t\t\tthat._resize();\n\n\t\t\t\tdt.rows( rowIds ).every( function () {\n\t\t\t\t\tthat._detailsDisplay( this, false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t});\n\n\t\tdt\n\t\t\t.on( 'draw.dtr', function () {\n\t\t\t\tthat._controlClass();\n\t\t\t})\n\t\t\t.on( 'init.dtr', function (e, settings, details) {\n\t\t\t\tif ( e.namespace !== 'dt' ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthat._resizeAuto();\n\t\t\t\tthat._resize();\n\n\t\t\t\t// If columns were hidden, then DataTables needs to adjust the\n\t\t\t\t// column sizing\n\t\t\t\tif ( $.inArray( false, that.s.current ) ) {\n\t\t\t\t\tdt.columns.adjust();\n\t\t\t\t}\n\t\t\t} );\n\n\t\t// First pass - draw the table for the current viewport size\n\t\tthis._resize();\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods\n\t */\n\n\t/**\n\t * Calculate the visibility for the columns in a table for a given\n\t * breakpoint. The result is pre-determined based on the class logic if\n\t * class names are used to control all columns, but the width of the table\n\t * is also used if there are columns which are to be automatically shown\n\t * and hidden.\n\t *\n\t * @param  {string} breakpoint Breakpoint name to use for the calculation\n\t * @return {array} Array of boolean values initiating the visibility of each\n\t *   column.\n\t *  @private\n\t */\n\t_columnsVisiblity: function ( breakpoint )\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar columns = this.s.columns;\n\t\tvar i, ien;\n\n\t\t// Create an array that defines the column ordering based first on the\n\t\t// column's priority, and secondly the column index. This allows the\n\t\t// columns to be removed from the right if the priority matches\n\t\tvar order = columns\n\t\t\t.map( function ( col, idx ) {\n\t\t\t\treturn {\n\t\t\t\t\tcolumnIdx: idx,\n\t\t\t\t\tpriority: col.priority\n\t\t\t\t};\n\t\t\t} )\n\t\t\t.sort( function ( a, b ) {\n\t\t\t\tif ( a.priority !== b.priority ) {\n\t\t\t\t\treturn a.priority - b.priority;\n\t\t\t\t}\n\t\t\t\treturn a.columnIdx - b.columnIdx;\n\t\t\t} );\n\n\t\t// Class logic - determine which columns are in this breakpoint based\n\t\t// on the classes. If no class control (i.e. `auto`) then `-` is used\n\t\t// to indicate this to the rest of the function\n\t\tvar display = $.map( columns, function ( col, i ) {\n\t\t\tif ( dt.column(i).visible() === false ) {\n\t\t\t\treturn 'not-visible';\n\t\t\t}\n\t\t\treturn col.auto && col.minWidth === null ?\n\t\t\t\tfalse :\n\t\t\t\tcol.auto === true ?\n\t\t\t\t\t'-' :\n\t\t\t\t\t$.inArray( breakpoint, col.includeIn ) !== -1;\n\t\t} );\n\n\t\t// Auto column control - first pass: how much width is taken by the\n\t\t// ones that must be included from the non-auto columns\n\t\tvar requiredWidth = 0;\n\t\tfor ( i=0, ien=display.length ; i<ien ; i++ ) {\n\t\t\tif ( display[i] === true ) {\n\t\t\t\trequiredWidth += columns[i].minWidth;\n\t\t\t}\n\t\t}\n\n\t\t// Second pass, use up any remaining width for other columns. For\n\t\t// scrolling tables we need to subtract the width of the scrollbar. It\n\t\t// may not be requires which makes this sub-optimal, but it would\n\t\t// require another full redraw to make complete use of those extra few\n\t\t// pixels\n\t\tvar scrolling = dt.settings()[0].oScroll;\n\t\tvar bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;\n\t\tvar widthAvailable = dt.table().container().offsetWidth - bar;\n\t\tvar usedWidth = widthAvailable - requiredWidth;\n\n\t\t// Control column needs to always be included. This makes it sub-\n\t\t// optimal in terms of using the available with, but to stop layout\n\t\t// thrashing or overflow. Also we need to account for the control column\n\t\t// width first so we know how much width is available for the other\n\t\t// columns, since the control column might not be the first one shown\n\t\tfor ( i=0, ien=display.length ; i<ien ; i++ ) {\n\t\t\tif ( columns[i].control ) {\n\t\t\t\tusedWidth -= columns[i].minWidth;\n\t\t\t}\n\t\t}\n\n\t\t// Allow columns to be shown (counting by priority and then right to\n\t\t// left) until we run out of room\n\t\tvar empty = false;\n\t\tfor ( i=0, ien=order.length ; i<ien ; i++ ) {\n\t\t\tvar colIdx = order[i].columnIdx;\n\n\t\t\tif ( display[colIdx] === '-' && ! columns[colIdx].control && columns[colIdx].minWidth ) {\n\t\t\t\t// Once we've found a column that won't fit we don't let any\n\t\t\t\t// others display either, or columns might disappear in the\n\t\t\t\t// middle of the table\n\t\t\t\tif ( empty || usedWidth - columns[colIdx].minWidth < 0 ) {\n\t\t\t\t\tempty = true;\n\t\t\t\t\tdisplay[colIdx] = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdisplay[colIdx] = true;\n\t\t\t\t}\n\n\t\t\t\tusedWidth -= columns[colIdx].minWidth;\n\t\t\t}\n\t\t}\n\n\t\t// Determine if the 'control' column should be shown (if there is one).\n\t\t// This is the case when there is a hidden column (that is not the\n\t\t// control column). The two loops look inefficient here, but they are\n\t\t// trivial and will fly through. We need to know the outcome from the\n\t\t// first , before the action in the second can be taken\n\t\tvar showControl = false;\n\n\t\tfor ( i=0, ien=columns.length ; i<ien ; i++ ) {\n\t\t\tif ( ! columns[i].control && ! columns[i].never && display[i] === false ) {\n\t\t\t\tshowControl = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor ( i=0, ien=columns.length ; i<ien ; i++ ) {\n\t\t\tif ( columns[i].control ) {\n\t\t\t\tdisplay[i] = showControl;\n\t\t\t}\n\n\t\t\t// Replace not visible string with false from the control column detection above\n\t\t\tif ( display[i] === 'not-visible' ) {\n\t\t\t\tdisplay[i] = false;\n\t\t\t}\n\t\t}\n\n\t\t// Finally we need to make sure that there is at least one column that\n\t\t// is visible\n\t\tif ( $.inArray( true, display ) === -1 ) {\n\t\t\tdisplay[0] = true;\n\t\t}\n\n\t\treturn display;\n\t},\n\n\n\t/**\n\t * Create the internal `columns` array with information about the columns\n\t * for the table. This includes determining which breakpoints the column\n\t * will appear in, based upon class names in the column, which makes up the\n\t * vast majority of this method.\n\t *\n\t * @private\n\t */\n\t_classLogic: function ()\n\t{\n\t\tvar that = this;\n\t\tvar calc = {};\n\t\tvar breakpoints = this.c.breakpoints;\n\t\tvar dt = this.s.dt;\n\t\tvar columns = dt.columns().eq(0).map( function (i) {\n\t\t\tvar column = this.column(i);\n\t\t\tvar className = column.header().className;\n\t\t\tvar priority = dt.settings()[0].aoColumns[i].responsivePriority;\n\t\t\tvar dataPriority = column.header().getAttribute('data-priority');\n\n\t\t\tif ( priority === undefined ) {\n\t\t\t\tpriority = dataPriority === undefined || dataPriority === null?\n\t\t\t\t\t10000 :\n\t\t\t\t\tdataPriority * 1;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tclassName: className,\n\t\t\t\tincludeIn: [],\n\t\t\t\tauto:      false,\n\t\t\t\tcontrol:   false,\n\t\t\t\tnever:     className.match(/\\b(dtr\\-)?never\\b/) ? true : false,\n\t\t\t\tpriority:  priority\n\t\t\t};\n\t\t} );\n\n\t\t// Simply add a breakpoint to `includeIn` array, ensuring that there are\n\t\t// no duplicates\n\t\tvar add = function ( colIdx, name ) {\n\t\t\tvar includeIn = columns[ colIdx ].includeIn;\n\n\t\t\tif ( $.inArray( name, includeIn ) === -1 ) {\n\t\t\t\tincludeIn.push( name );\n\t\t\t}\n\t\t};\n\n\t\tvar column = function ( colIdx, name, operator, matched ) {\n\t\t\tvar size, i, ien;\n\n\t\t\tif ( ! operator ) {\n\t\t\t\tcolumns[ colIdx ].includeIn.push( name );\n\t\t\t}\n\t\t\telse if ( operator === 'max-' ) {\n\t\t\t\t// Add this breakpoint and all smaller\n\t\t\t\tsize = that._find( name ).width;\n\n\t\t\t\tfor ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n\t\t\t\t\tif ( breakpoints[i].width <= size ) {\n\t\t\t\t\t\tadd( colIdx, breakpoints[i].name );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( operator === 'min-' ) {\n\t\t\t\t// Add this breakpoint and all larger\n\t\t\t\tsize = that._find( name ).width;\n\n\t\t\t\tfor ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n\t\t\t\t\tif ( breakpoints[i].width >= size ) {\n\t\t\t\t\t\tadd( colIdx, breakpoints[i].name );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( operator === 'not-' ) {\n\t\t\t\t// Add all but this breakpoint\n\t\t\t\tfor ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n\t\t\t\t\tif ( breakpoints[i].name.indexOf( matched ) === -1 ) {\n\t\t\t\t\t\tadd( colIdx, breakpoints[i].name );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Loop over each column and determine if it has a responsive control\n\t\t// class\n\t\tcolumns.each( function ( col, i ) {\n\t\t\tvar classNames = col.className.split(' ');\n\t\t\tvar hasClass = false;\n\n\t\t\t// Split the class name up so multiple rules can be applied if needed\n\t\t\tfor ( var k=0, ken=classNames.length ; k<ken ; k++ ) {\n\t\t\t\tvar className = classNames[k].trim();\n\n\t\t\t\tif ( className === 'all' || className === 'dtr-all' ) {\n\t\t\t\t\t// Include in all\n\t\t\t\t\thasClass = true;\n\t\t\t\t\tcol.includeIn = $.map( breakpoints, function (a) {\n\t\t\t\t\t\treturn a.name;\n\t\t\t\t\t} );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse if ( className === 'none' || className === 'dtr-none' || col.never ) {\n\t\t\t\t\t// Include in none (default) and no auto\n\t\t\t\t\thasClass = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse if ( className === 'control' || className === 'dtr-control' ) {\n\t\t\t\t\t// Special column that is only visible, when one of the other\n\t\t\t\t\t// columns is hidden. This is used for the details control\n\t\t\t\t\thasClass = true;\n\t\t\t\t\tcol.control = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t$.each( breakpoints, function ( j, breakpoint ) {\n\t\t\t\t\t// Does this column have a class that matches this breakpoint?\n\t\t\t\t\tvar brokenPoint = breakpoint.name.split('-');\n\t\t\t\t\tvar re = new RegExp( '(min\\\\-|max\\\\-|not\\\\-)?('+brokenPoint[0]+')(\\\\-[_a-zA-Z0-9])?' );\n\t\t\t\t\tvar match = className.match( re );\n\n\t\t\t\t\tif ( match ) {\n\t\t\t\t\t\thasClass = true;\n\n\t\t\t\t\t\tif ( match[2] === brokenPoint[0] && match[3] === '-'+brokenPoint[1] ) {\n\t\t\t\t\t\t\t// Class name matches breakpoint name fully\n\t\t\t\t\t\t\tcolumn( i, breakpoint.name, match[1], match[2]+match[3] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( match[2] === brokenPoint[0] && ! match[3] ) {\n\t\t\t\t\t\t\t// Class name matched primary breakpoint name with no qualifier\n\t\t\t\t\t\t\tcolumn( i, breakpoint.name, match[1], match[2] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// If there was no control class, then automatic sizing is used\n\t\t\tif ( ! hasClass ) {\n\t\t\t\tcol.auto = true;\n\t\t\t}\n\t\t} );\n\n\t\tthis.s.columns = columns;\n\t},\n\n\t/**\n\t * Update the cells to show the correct control class / button\n\t * @private\n\t */\n\t_controlClass: function ()\n\t{\n\t\tif ( this.c.details.type === 'inline' ) {\n\t\t\tvar dt = this.s.dt;\n\t\t\tvar columnsVis = this.s.current;\n\t\t\tvar firstVisible = $.inArray(true, columnsVis);\n\n\t\t\t// Remove from any cells which shouldn't have it\n\t\t\tdt.cells(\n\t\t\t\tnull,\n\t\t\t\tfunction(idx) {\n\t\t\t\t\treturn idx !== firstVisible;\n\t\t\t\t},\n\t\t\t\t{page: 'current'}\n\t\t\t)\n\t\t\t\t.nodes()\n\t\t\t\t.to$()\n\t\t\t\t.filter('.dtr-control')\n\t\t\t\t.removeClass('dtr-control');\n\n\t\t\tdt.cells(null, firstVisible, {page: 'current'})\n\t\t\t\t.nodes()\n\t\t\t\t.to$()\n\t\t\t\t.addClass('dtr-control');\n\t\t}\n\t},\n\n\t/**\n\t * Show the details for the child row\n\t *\n\t * @param  {DataTables.Api} row    API instance for the row\n\t * @param  {boolean}        update Update flag\n\t * @private\n\t */\n\t_detailsDisplay: function ( row, update )\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dt;\n\t\tvar details = this.c.details;\n\n\t\tif ( details && details.type !== false ) {\n\t\t\tvar renderer = typeof details.renderer === 'string'\n\t\t\t\t? Responsive.renderer[details.renderer]()\n\t\t\t\t: details.renderer;\n\n\t\t\tvar res = details.display( row, update, function () {\n\t\t\t\treturn renderer(\n\t\t\t\t\tdt, row[0], that._detailsObj(row[0])\n\t\t\t\t);\n\t\t\t} );\n\n\t\t\tif ( res === true || res === false ) {\n\t\t\t\t$(dt.table().node()).triggerHandler( 'responsive-display.dt', [dt, row, res, update] );\n\t\t\t}\n\t\t}\n\t},\n\n\n\t/**\n\t * Initialisation for the details handler\n\t *\n\t * @private\n\t */\n\t_detailsInit: function ()\n\t{\n\t\tvar that    = this;\n\t\tvar dt      = this.s.dt;\n\t\tvar details = this.c.details;\n\n\t\t// The inline type always uses the first child as the target\n\t\tif ( details.type === 'inline' ) {\n\t\t\tdetails.target = 'td.dtr-control, th.dtr-control';\n\t\t}\n\n\t\t// Keyboard accessibility\n\t\tdt.on( 'draw.dtr', function () {\n\t\t\tthat._tabIndexes();\n\t\t} );\n\t\tthat._tabIndexes(); // Initial draw has already happened\n\n\t\t$( dt.table().body() ).on( 'keyup.dtr', 'td, th', function (e) {\n\t\t\tif ( e.keyCode === 13 && $(this).data('dtr-keyboard') ) {\n\t\t\t\t$(this).click();\n\t\t\t}\n\t\t} );\n\n\t\t// type.target can be a string jQuery selector or a column index\n\t\tvar target   = details.target;\n\t\tvar selector = typeof target === 'string' ? target : 'td, th';\n\n\t\tif ( target !== undefined || target !== null ) {\n\t\t\t// Click handler to show / hide the details rows when they are available\n\t\t\t$( dt.table().body() )\n\t\t\t\t.on( 'click.dtr mousedown.dtr mouseup.dtr', selector, function (e) {\n\t\t\t\t\t// If the table is not collapsed (i.e. there is no hidden columns)\n\t\t\t\t\t// then take no action\n\t\t\t\t\tif ( ! $(dt.table().node()).hasClass('collapsed' ) ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check that the row is actually a DataTable's controlled node\n\t\t\t\t\tif ( $.inArray( $(this).closest('tr').get(0), dt.rows().nodes().toArray() ) === -1 ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For column index, we determine if we should act or not in the\n\t\t\t\t\t// handler - otherwise it is already okay\n\t\t\t\t\tif ( typeof target === 'number' ) {\n\t\t\t\t\t\tvar targetIdx = target < 0 ?\n\t\t\t\t\t\t\tdt.columns().eq(0).length + target :\n\t\t\t\t\t\t\ttarget;\n\n\t\t\t\t\t\tif ( dt.cell( this ).index().column !== targetIdx ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// $().closest() includes itself in its check\n\t\t\t\t\tvar row = dt.row( $(this).closest('tr') );\n\n\t\t\t\t\t// Check event type to do an action\n\t\t\t\t\tif ( e.type === 'click' ) {\n\t\t\t\t\t\t// The renderer is given as a function so the caller can execute it\n\t\t\t\t\t\t// only when they need (i.e. if hiding there is no point is running\n\t\t\t\t\t\t// the renderer)\n\t\t\t\t\t\tthat._detailsDisplay( row, false );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( e.type === 'mousedown' ) {\n\t\t\t\t\t\t// For mouse users, prevent the focus ring from showing\n\t\t\t\t\t\t$(this).css('outline', 'none');\n\t\t\t\t\t}\n\t\t\t\t\telse if ( e.type === 'mouseup' ) {\n\t\t\t\t\t\t// And then re-allow at the end of the click\n\t\t\t\t\t\t$(this).trigger('blur').css('outline', '');\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}\n\t},\n\n\n\t/**\n\t * Get the details to pass to a renderer for a row\n\t * @param  {int} rowIdx Row index\n\t * @private\n\t */\n\t_detailsObj: function ( rowIdx )\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dt;\n\n\t\treturn $.map( this.s.columns, function( col, i ) {\n\t\t\t// Never and control columns should not be passed to the renderer\n\t\t\tif ( col.never || col.control ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar dtCol = dt.settings()[0].aoColumns[ i ];\n\n\t\t\treturn {\n\t\t\t\tclassName:   dtCol.sClass,\n\t\t\t\tcolumnIndex: i,\n\t\t\t\tdata:        dt.cell( rowIdx, i ).render( that.c.orthogonal ),\n\t\t\t\thidden:      dt.column( i ).visible() && !that.s.current[ i ],\n\t\t\t\trowIndex:    rowIdx,\n\t\t\t\ttitle:       dtCol.sTitle !== null ?\n\t\t\t\t\tdtCol.sTitle :\n\t\t\t\t\t$(dt.column(i).header()).text()\n\t\t\t};\n\t\t} );\n\t},\n\n\n\t/**\n\t * Find a breakpoint object from a name\n\t *\n\t * @param  {string} name Breakpoint name to find\n\t * @return {object}      Breakpoint description object\n\t * @private\n\t */\n\t_find: function ( name )\n\t{\n\t\tvar breakpoints = this.c.breakpoints;\n\n\t\tfor ( var i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n\t\t\tif ( breakpoints[i].name === name ) {\n\t\t\t\treturn breakpoints[i];\n\t\t\t}\n\t\t}\n\t},\n\n\n\t/**\n\t * Re-create the contents of the child rows as the display has changed in\n\t * some way.\n\t *\n\t * @private\n\t */\n\t_redrawChildren: function ()\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dt;\n\n\t\tdt.rows( {page: 'current'} ).iterator( 'row', function ( settings, idx ) {\n\t\t\tvar row = dt.row( idx );\n\n\t\t\tthat._detailsDisplay( dt.row( idx ), true );\n\t\t} );\n\t},\n\n\n\t/**\n\t * Alter the table display for a resized viewport. This involves first\n\t * determining what breakpoint the window currently is in, getting the\n\t * column visibilities to apply and then setting them.\n\t *\n\t * @param  {boolean} forceRedraw Force a redraw\n\t * @private\n\t */\n\t_resize: function (forceRedraw)\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dt;\n\t\tvar width = $(window).innerWidth();\n\t\tvar breakpoints = this.c.breakpoints;\n\t\tvar breakpoint = breakpoints[0].name;\n\t\tvar columns = this.s.columns;\n\t\tvar i, ien;\n\t\tvar oldVis = this.s.current.slice();\n\n\t\t// Determine what breakpoint we are currently at\n\t\tfor ( i=breakpoints.length-1 ; i>=0 ; i-- ) {\n\t\t\tif ( width <= breakpoints[i].width ) {\n\t\t\t\tbreakpoint = breakpoints[i].name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Show the columns for that break point\n\t\tvar columnsVis = this._columnsVisiblity( breakpoint );\n\t\tthis.s.current = columnsVis;\n\n\t\t// Set the class before the column visibility is changed so event\n\t\t// listeners know what the state is. Need to determine if there are\n\t\t// any columns that are not visible but can be shown\n\t\tvar collapsedClass = false;\n\t\n\t\tfor ( i=0, ien=columns.length ; i<ien ; i++ ) {\n\t\t\tif ( columnsVis[i] === false && ! columns[i].never && ! columns[i].control && ! dt.column(i).visible() === false ) {\n\t\t\t\tcollapsedClass = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$( dt.table().node() ).toggleClass( 'collapsed', collapsedClass );\n\n\t\tvar changed = false;\n\t\tvar visible = 0;\n\n\t\tdt.columns().eq(0).each( function ( colIdx, i ) {\n\t\t\tif ( columnsVis[i] === true ) {\n\t\t\t\tvisible++;\n\t\t\t}\n\n\t\t\tif ( forceRedraw || columnsVis[i] !== oldVis[i] ) {\n\t\t\t\tchanged = true;\n\t\t\t\tthat._setColumnVis( colIdx, columnsVis[i] );\n\t\t\t}\n\t\t} );\n\n\t\tif ( changed ) {\n\t\t\tthis._redrawChildren();\n\n\t\t\t// Inform listeners of the change\n\t\t\t$(dt.table().node()).trigger( 'responsive-resize.dt', [dt, this.s.current] );\n\n\t\t\t// If no records, update the \"No records\" display element\n\t\t\tif ( dt.page.info().recordsDisplay === 0 ) {\n\t\t\t\t$('td', dt.table().body()).eq(0).attr('colspan', visible);\n\t\t\t}\n\t\t}\n\n\t\tthat._controlClass();\n\t},\n\n\n\t/**\n\t * Determine the width of each column in the table so the auto column hiding\n\t * has that information to work with. This method is never going to be 100%\n\t * perfect since column widths can change slightly per page, but without\n\t * seriously compromising performance this is quite effective.\n\t *\n\t * @private\n\t */\n\t_resizeAuto: function ()\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar columns = this.s.columns;\n\n\t\t// Are we allowed to do auto sizing?\n\t\tif ( ! this.c.auto ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Are there any columns that actually need auto-sizing, or do they all\n\t\t// have classes defined\n\t\tif ( $.inArray( true, $.map( columns, function (c) { return c.auto; } ) ) === -1 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Need to restore all children. They will be reinstated by a re-render\n\t\tif ( ! $.isEmptyObject( _childNodeStore ) ) {\n\t\t\t$.each( _childNodeStore, function ( key ) {\n\t\t\t\tvar idx = key.split('-');\n\n\t\t\t\t_childNodesRestore( dt, idx[0]*1, idx[1]*1 );\n\t\t\t} );\n\t\t}\n\n\t\t// Clone the table with the current data in it\n\t\tvar tableWidth   = dt.table().node().offsetWidth;\n\t\tvar columnWidths = dt.columns;\n\t\tvar clonedTable  = dt.table().node().cloneNode( false );\n\t\tvar clonedHeader = $( dt.table().header().cloneNode( false ) ).appendTo( clonedTable );\n\t\tvar clonedBody   = $( dt.table().body() ).clone( false, false ).empty().appendTo( clonedTable ); // use jQuery because of IE8\n\n\t\tclonedTable.style.width = 'auto';\n\n\t\t// Header\n\t\tvar headerCells = dt.columns()\n\t\t\t.header()\n\t\t\t.filter( function (idx) {\n\t\t\t\treturn dt.column(idx).visible();\n\t\t\t} )\n\t\t\t.to$()\n\t\t\t.clone( false )\n\t\t\t.css( 'display', 'table-cell' )\n\t\t\t.css( 'width', 'auto' )\n\t\t\t.css( 'min-width', 0 );\n\n\t\t// Body rows - we don't need to take account of DataTables' column\n\t\t// visibility since we implement our own here (hence the `display` set)\n\t\t$(clonedBody)\n\t\t\t.append( $(dt.rows( { page: 'current' } ).nodes()).clone( false ) )\n\t\t\t.find( 'th, td' ).css( 'display', '' );\n\n\t\t// Footer\n\t\tvar footer = dt.table().footer();\n\t\tif ( footer ) {\n\t\t\tvar clonedFooter = $( footer.cloneNode( false ) ).appendTo( clonedTable );\n\t\t\tvar footerCells = dt.columns()\n\t\t\t\t.footer()\n\t\t\t\t.filter( function (idx) {\n\t\t\t\t\treturn dt.column(idx).visible();\n\t\t\t\t} )\n\t\t\t\t.to$()\n\t\t\t\t.clone( false )\n\t\t\t\t.css( 'display', 'table-cell' );\n\n\t\t\t$('<tr/>')\n\t\t\t\t.append( footerCells )\n\t\t\t\t.appendTo( clonedFooter );\n\t\t}\n\n\t\t$('<tr/>')\n\t\t\t.append( headerCells )\n\t\t\t.appendTo( clonedHeader );\n\n\t\t// In the inline case extra padding is applied to the first column to\n\t\t// give space for the show / hide icon. We need to use this in the\n\t\t// calculation\n\t\tif ( this.c.details.type === 'inline' ) {\n\t\t\t$(clonedTable).addClass( 'dtr-inline collapsed' );\n\t\t}\n\t\t\n\t\t// It is unsafe to insert elements with the same name into the DOM\n\t\t// multiple times. For example, cloning and inserting a checked radio\n\t\t// clears the chcecked state of the original radio.\n\t\t$( clonedTable ).find( '[name]' ).removeAttr( 'name' );\n\n\t\t// A position absolute table would take the table out of the flow of\n\t\t// our container element, bypassing the height and width (Scroller)\n\t\t$( clonedTable ).css( 'position', 'relative' )\n\t\t\n\t\tvar inserted = $('<div/>')\n\t\t\t.css( {\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1,\n\t\t\t\toverflow: 'hidden',\n\t\t\t\tclear: 'both'\n\t\t\t} )\n\t\t\t.append( clonedTable );\n\n\t\tinserted.insertBefore( dt.table().node() );\n\n\t\t// The cloned header now contains the smallest that each column can be\n\t\theaderCells.each( function (i) {\n\t\t\tvar idx = dt.column.index( 'fromVisible', i );\n\t\t\tcolumns[ idx ].minWidth =  this.offsetWidth || 0;\n\t\t} );\n\n\t\tinserted.remove();\n\t},\n\n\t/**\n\t * Get the state of the current hidden columns - controlled by Responsive only\n\t */\n\t_responsiveOnlyHidden: function ()\n\t{\n\t\tvar dt = this.s.dt;\n\n\t\treturn $.map( this.s.current, function (v, i) {\n\t\t\t// If the column is hidden by DataTables then it can't be hidden by\n\t\t\t// Responsive!\n\t\t\tif ( dt.column(i).visible() === false ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn v;\n\t\t} );\n\t},\n\n\t/**\n\t * Set a column's visibility.\n\t *\n\t * We don't use DataTables' column visibility controls in order to ensure\n\t * that column visibility can Responsive can no-exist. Since only IE8+ is\n\t * supported (and all evergreen browsers of course) the control of the\n\t * display attribute works well.\n\t *\n\t * @param {integer} col      Column index\n\t * @param {boolean} showHide Show or hide (true or false)\n\t * @private\n\t */\n\t_setColumnVis: function ( col, showHide )\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar display = showHide ? '' : 'none'; // empty string will remove the attr\n\n\t\t$( dt.column( col ).header() )\n\t\t\t.css( 'display', display )\n\t\t\t.toggleClass('dtr-hidden', !showHide);\n\n\t\t$( dt.column( col ).footer() )\n\t\t\t.css( 'display', display )\n\t\t\t.toggleClass('dtr-hidden', !showHide);\n\n\t\tdt.column( col ).nodes().to$()\n\t\t\t.css( 'display', display )\n\t\t\t.toggleClass('dtr-hidden', !showHide);\n\n\t\t// If the are child nodes stored, we might need to reinsert them\n\t\tif ( ! $.isEmptyObject( _childNodeStore ) ) {\n\t\t\tdt.cells( null, col ).indexes().each( function (idx) {\n\t\t\t\t_childNodesRestore( dt, idx.row, idx.column );\n\t\t\t} );\n\t\t}\n\t},\n\n\n\t/**\n\t * Update the cell tab indexes for keyboard accessibility. This is called on\n\t * every table draw - that is potentially inefficient, but also the least\n\t * complex option given that column visibility can change on the fly. Its a\n\t * shame user-focus was removed from CSS 3 UI, as it would have solved this\n\t * issue with a single CSS statement.\n\t *\n\t * @private\n\t */\n\t_tabIndexes: function ()\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar cells = dt.cells( { page: 'current' } ).nodes().to$();\n\t\tvar ctx = dt.settings()[0];\n\t\tvar target = this.c.details.target;\n\n\t\tcells.filter( '[data-dtr-keyboard]' ).removeData( '[data-dtr-keyboard]' );\n\n\t\tif ( typeof target === 'number' ) {\n\t\t\tdt.cells( null, target, { page: 'current' } ).nodes().to$()\n\t\t\t\t.attr( 'tabIndex', ctx.iTabIndex )\n\t\t\t\t.data( 'dtr-keyboard', 1 );\n\t\t}\n\t\telse {\n\t\t\t// This is a bit of a hack - we need to limit the selected nodes to just\n\t\t\t// those of this table\n\t\t\tif ( target === 'td:first-child, th:first-child' ) {\n\t\t\t\ttarget = '>td:first-child, >th:first-child';\n\t\t\t}\n\n\t\t\t$( target, dt.rows( { page: 'current' } ).nodes() )\n\t\t\t\t.attr( 'tabIndex', ctx.iTabIndex )\n\t\t\t\t.data( 'dtr-keyboard', 1 );\n\t\t}\n\t}\n} );\n\n\n/**\n * List of default breakpoints. Each item in the array is an object with two\n * properties:\n *\n * * `name` - the breakpoint name.\n * * `width` - the breakpoint width\n *\n * @name Responsive.breakpoints\n * @static\n */\nResponsive.breakpoints = [\n\t{ name: 'desktop',  width: Infinity },\n\t{ name: 'tablet-l', width: 1024 },\n\t{ name: 'tablet-p', width: 768 },\n\t{ name: 'mobile-l', width: 480 },\n\t{ name: 'mobile-p', width: 320 }\n];\n\n\n/**\n * Display methods - functions which define how the hidden data should be shown\n * in the table.\n *\n * @namespace\n * @name Responsive.defaults\n * @static\n */\nResponsive.display = {\n\tchildRow: function ( row, update, render ) {\n\t\tif ( update ) {\n\t\t\tif ( $(row.node()).hasClass('parent') ) {\n\t\t\t\trow.child( render(), 'child' ).show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( ! row.child.isShown()  ) {\n\t\t\t\trow.child( render(), 'child' ).show();\n\t\t\t\t$( row.node() ).addClass( 'parent' );\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trow.child( false );\n\t\t\t\t$( row.node() ).removeClass( 'parent' );\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t},\n\n\tchildRowImmediate: function ( row, update, render ) {\n\t\tif ( (! update && row.child.isShown()) || ! row.responsive.hasHidden() ) {\n\t\t\t// User interaction and the row is show, or nothing to show\n\t\t\trow.child( false );\n\t\t\t$( row.node() ).removeClass( 'parent' );\n\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t// Display\n\t\t\trow.child( render(), 'child' ).show();\n\t\t\t$( row.node() ).addClass( 'parent' );\n\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t// This is a wrapper so the modal options for Bootstrap and jQuery UI can\n\t// have options passed into them. This specific one doesn't need to be a\n\t// function but it is for consistency in the `modal` name\n\tmodal: function ( options ) {\n\t\treturn function ( row, update, render ) {\n\t\t\tif ( ! update ) {\n\t\t\t\t// Show a modal\n\t\t\t\tvar close = function () {\n\t\t\t\t\tmodal.remove(); // will tidy events for us\n\t\t\t\t\t$(document).off( 'keypress.dtr' );\n\t\t\t\t};\n\n\t\t\t\tvar modal = $('<div class=\"dtr-modal\"/>')\n\t\t\t\t\t.append( $('<div class=\"dtr-modal-display\"/>')\n\t\t\t\t\t\t.append( $('<div class=\"dtr-modal-content\"/>')\n\t\t\t\t\t\t\t.append( render() )\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.append( $('<div class=\"dtr-modal-close\">&times;</div>' )\n\t\t\t\t\t\t\t.click( function () {\n\t\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t.append( $('<div class=\"dtr-modal-background\"/>')\n\t\t\t\t\t\t.click( function () {\n\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t} )\n\t\t\t\t\t)\n\t\t\t\t\t.appendTo( 'body' );\n\n\t\t\t\t$(document).on( 'keyup.dtr', function (e) {\n\t\t\t\t\tif ( e.keyCode === 27 ) {\n\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\tclose();\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$('div.dtr-modal-content')\n\t\t\t\t\t.empty()\n\t\t\t\t\t.append( render() );\n\t\t\t}\n\n\t\t\tif ( options && options.header ) {\n\t\t\t\t$('div.dtr-modal-content').prepend(\n\t\t\t\t\t'<h2>'+options.header( row )+'</h2>'\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n};\n\n\nvar _childNodeStore = {};\n\nfunction _childNodes( dt, row, col ) {\n\tvar name = row+'-'+col;\n\n\tif ( _childNodeStore[ name ] ) {\n\t\treturn _childNodeStore[ name ];\n\t}\n\n\t// https://jsperf.com/childnodes-array-slice-vs-loop\n\tvar nodes = [];\n\tvar children = dt.cell( row, col ).node().childNodes;\n\tfor ( var i=0, ien=children.length ; i<ien ; i++ ) {\n\t\tnodes.push( children[i] );\n\t}\n\n\t_childNodeStore[ name ] = nodes;\n\n\treturn nodes;\n}\n\nfunction _childNodesRestore( dt, row, col ) {\n\tvar name = row+'-'+col;\n\n\tif ( ! _childNodeStore[ name ] ) {\n\t\treturn;\n\t}\n\n\tvar node = dt.cell( row, col ).node();\n\tvar store = _childNodeStore[ name ];\n\tvar parent = store[0].parentNode;\n\tvar parentChildren = parent.childNodes;\n\tvar a = [];\n\n\tfor ( var i=0, ien=parentChildren.length ; i<ien ; i++ ) {\n\t\ta.push( parentChildren[i] );\n\t}\n\n\tfor ( var j=0, jen=a.length ; j<jen ; j++ ) {\n\t\tnode.appendChild( a[j] );\n\t}\n\n\t_childNodeStore[ name ] = undefined;\n}\n\n\n/**\n * Display methods - functions which define how the hidden data should be shown\n * in the table.\n *\n * @namespace\n * @name Responsive.defaults\n * @static\n */\nResponsive.renderer = {\n\tlistHiddenNodes: function () {\n\t\treturn function ( api, rowIdx, columns ) {\n\t\t\tvar ul = $('<ul data-dtr-index=\"'+rowIdx+'\" class=\"dtr-details\"/>');\n\t\t\tvar found = false;\n\n\t\t\tvar data = $.each( columns, function ( i, col ) {\n\t\t\t\tif ( col.hidden ) {\n\t\t\t\t\tvar klass = col.className ?\n\t\t\t\t\t\t'class=\"'+ col.className +'\"' :\n\t\t\t\t\t\t'';\n\t\n\t\t\t\t\t$(\n\t\t\t\t\t\t'<li '+klass+' data-dtr-index=\"'+col.columnIndex+'\" data-dt-row=\"'+col.rowIndex+'\" data-dt-column=\"'+col.columnIndex+'\">'+\n\t\t\t\t\t\t\t'<span class=\"dtr-title\">'+\n\t\t\t\t\t\t\t\tcol.title+\n\t\t\t\t\t\t\t'</span> '+\n\t\t\t\t\t\t'</li>'\n\t\t\t\t\t)\n\t\t\t\t\t\t.append( $('<span class=\"dtr-data\"/>').append( _childNodes( api, col.rowIndex, col.columnIndex ) ) )// api.cell( col.rowIndex, col.columnIndex ).node().childNodes ) )\n\t\t\t\t\t\t.appendTo( ul );\n\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn found ?\n\t\t\t\tul :\n\t\t\t\tfalse;\n\t\t};\n\t},\n\n\tlistHidden: function () {\n\t\treturn function ( api, rowIdx, columns ) {\n\t\t\tvar data = $.map( columns, function ( col ) {\n\t\t\t\tvar klass = col.className ?\n\t\t\t\t\t'class=\"'+ col.className +'\"' :\n\t\t\t\t\t'';\n\n\t\t\t\treturn col.hidden ?\n\t\t\t\t\t'<li '+klass+' data-dtr-index=\"'+col.columnIndex+'\" data-dt-row=\"'+col.rowIndex+'\" data-dt-column=\"'+col.columnIndex+'\">'+\n\t\t\t\t\t\t'<span class=\"dtr-title\">'+\n\t\t\t\t\t\t\tcol.title+\n\t\t\t\t\t\t'</span> '+\n\t\t\t\t\t\t'<span class=\"dtr-data\">'+\n\t\t\t\t\t\t\tcol.data+\n\t\t\t\t\t\t'</span>'+\n\t\t\t\t\t'</li>' :\n\t\t\t\t\t'';\n\t\t\t} ).join('');\n\n\t\t\treturn data ?\n\t\t\t\t$('<ul data-dtr-index=\"'+rowIdx+'\" class=\"dtr-details\"/>').append( data ) :\n\t\t\t\tfalse;\n\t\t}\n\t},\n\n\ttableAll: function ( options ) {\n\t\toptions = $.extend( {\n\t\t\ttableClass: ''\n\t\t}, options );\n\n\t\treturn function ( api, rowIdx, columns ) {\n\t\t\tvar data = $.map( columns, function ( col ) {\n\t\t\t\tvar klass = col.className ?\n\t\t\t\t\t'class=\"'+ col.className +'\"' :\n\t\t\t\t\t'';\n\n\t\t\t\treturn '<tr '+klass+' data-dt-row=\"'+col.rowIndex+'\" data-dt-column=\"'+col.columnIndex+'\">'+\n\t\t\t\t\t\t'<td>'+col.title+':'+'</td> '+\n\t\t\t\t\t\t'<td>'+col.data+'</td>'+\n\t\t\t\t\t'</tr>';\n\t\t\t} ).join('');\n\n\t\t\treturn $('<table class=\"'+options.tableClass+' dtr-details\" width=\"100%\"/>').append( data );\n\t\t}\n\t}\n};\n\n/**\n * Responsive default settings for initialisation\n *\n * @namespace\n * @name Responsive.defaults\n * @static\n */\nResponsive.defaults = {\n\t/**\n\t * List of breakpoints for the instance. Note that this means that each\n\t * instance can have its own breakpoints. Additionally, the breakpoints\n\t * cannot be changed once an instance has been creased.\n\t *\n\t * @type {Array}\n\t * @default Takes the value of `Responsive.breakpoints`\n\t */\n\tbreakpoints: Responsive.breakpoints,\n\n\t/**\n\t * Enable / disable auto hiding calculations. It can help to increase\n\t * performance slightly if you disable this option, but all columns would\n\t * need to have breakpoint classes assigned to them\n\t *\n\t * @type {Boolean}\n\t * @default  `true`\n\t */\n\tauto: true,\n\n\t/**\n\t * Details control. If given as a string value, the `type` property of the\n\t * default object is set to that value, and the defaults used for the rest\n\t * of the object - this is for ease of implementation.\n\t *\n\t * The object consists of the following properties:\n\t *\n\t * * `display` - A function that is used to show and hide the hidden details\n\t * * `renderer` - function that is called for display of the child row data.\n\t *   The default function will show the data from the hidden columns\n\t * * `target` - Used as the selector for what objects to attach the child\n\t *   open / close to\n\t * * `type` - `false` to disable the details display, `inline` or `column`\n\t *   for the two control types\n\t *\n\t * @type {Object|string}\n\t */\n\tdetails: {\n\t\tdisplay: Responsive.display.childRow,\n\n\t\trenderer: Responsive.renderer.listHidden(),\n\n\t\ttarget: 0,\n\n\t\ttype: 'inline'\n\t},\n\n\t/**\n\t * Orthogonal data request option. This is used to define the data type\n\t * requested when Responsive gets the data to show in the child row.\n\t *\n\t * @type {String}\n\t */\n\torthogonal: 'display'\n};\n\n\n/*\n * API\n */\nvar Api = $.fn.dataTable.Api;\n\n// Doesn't do anything - work around for a bug in DT... Not documented\nApi.register( 'responsive()', function () {\n\treturn this;\n} );\n\nApi.register( 'responsive.index()', function ( li ) {\n\tli = $(li);\n\n\treturn {\n\t\tcolumn: li.data('dtr-index'),\n\t\trow:    li.parent().data('dtr-index')\n\t};\n} );\n\nApi.register( 'responsive.rebuild()', function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ctx._responsive ) {\n\t\t\tctx._responsive._classLogic();\n\t\t}\n\t} );\n} );\n\nApi.register( 'responsive.recalc()', function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ctx._responsive ) {\n\t\t\tctx._responsive._resizeAuto();\n\t\t\tctx._responsive._resize();\n\t\t}\n\t} );\n} );\n\nApi.register( 'responsive.hasHidden()', function () {\n\tvar ctx = this.context[0];\n\n\treturn ctx._responsive ?\n\t\t$.inArray( false, ctx._responsive._responsiveOnlyHidden() ) !== -1 :\n\t\tfalse;\n} );\n\nApi.registerPlural( 'columns().responsiveHidden()', 'column().responsiveHidden()', function () {\n\treturn this.iterator( 'column', function ( settings, column ) {\n\t\treturn settings._responsive ?\n\t\t\tsettings._responsive._responsiveOnlyHidden()[ column ] :\n\t\t\tfalse;\n\t}, 1 );\n} );\n\n\n/**\n * Version information\n *\n * @name Responsive.version\n * @static\n */\nResponsive.version = '2.2.9';\n\n\n$.fn.dataTable.Responsive = Responsive;\n$.fn.DataTable.Responsive = Responsive;\n\n// Attach a listener to the document which listens for DataTables initialisation\n// events so we can automatically initialise\n$(document).on( 'preInit.dt.dtr', function (e, settings, json) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tif ( $(settings.nTable).hasClass( 'responsive' ) ||\n\t\t $(settings.nTable).hasClass( 'dt-responsive' ) ||\n\t\t settings.oInit.responsive ||\n\t\t DataTable.defaults.responsive\n\t) {\n\t\tvar init = settings.oInit.responsive;\n\n\t\tif ( init !== false ) {\n\t\t\tnew Responsive( settings, $.isPlainObject( init ) ? init : {}  );\n\t\t}\n\t}\n} );\n\n\nreturn Responsive;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtcmVzcG9uc2l2ZS9qcy9kYXRhVGFibGVzLnJlc3BvbnNpdmUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsRUFBRSxpQ0FBUSxDQUFDLDJDQUFRLEVBQUUsMkRBQWdCLENBQUMsbUNBQUU7QUFDeEM7QUFDQSxHQUFHO0FBQUEsa0dBQUU7QUFDTDtBQUNBLE1BQU0sRUFpQko7QUFDRixDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGlCQUFpQjtBQUM3Qjs7QUFFQTtBQUNBLElBQUk7QUFDSixFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELGlCQUFpQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7O0FBRW5HOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUNBQW1DO0FBQ3RDLEdBQUcsK0JBQStCO0FBQ2xDLEdBQUcsOEJBQThCO0FBQ2pDLEdBQUcsOEJBQThCO0FBQ2pDLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBOztBQUVBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZXN0Ly4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LXJlc3BvbnNpdmUvanMvZGF0YVRhYmxlcy5yZXNwb25zaXZlLmpzPzgwZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIFJlc3BvbnNpdmUgMi4yLjlcbiAqIDIwMTQtMjAyMSBTcHJ5TWVkaWEgTHRkIC0gZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxuICovXG5cbi8qKlxuICogQHN1bW1hcnkgICAgIFJlc3BvbnNpdmVcbiAqIEBkZXNjcmlwdGlvbiBSZXNwb25zaXZlIHRhYmxlcyBwbHVnLWluIGZvciBEYXRhVGFibGVzXG4gKiBAdmVyc2lvbiAgICAgMi4yLjlcbiAqIEBmaWxlICAgICAgICBkYXRhVGFibGVzLnJlc3BvbnNpdmUuanNcbiAqIEBhdXRob3IgICAgICBTcHJ5TWVkaWEgTHRkICh3d3cuc3ByeW1lZGlhLmNvLnVrKVxuICogQGNvbnRhY3QgICAgIHd3dy5zcHJ5bWVkaWEuY28udWsvY29udGFjdFxuICogQGNvcHlyaWdodCAgIENvcHlyaWdodCAyMDE0LTIwMjEgU3ByeU1lZGlhIEx0ZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGZyZWUgc29mdHdhcmUsIGF2YWlsYWJsZSB1bmRlciB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XG4gKiAgIE1JVCBsaWNlbnNlIC0gaHR0cDovL2RhdGF0YWJsZXMubmV0L2xpY2Vuc2UvbWl0XG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXRcbiAqIFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBsaWNlbnNlIGZpbGVzIGZvciBkZXRhaWxzLlxuICpcbiAqIEZvciBkZXRhaWxzIHBsZWFzZSByZWZlciB0bzogaHR0cDovL3d3dy5kYXRhdGFibGVzLm5ldFxuICovXG4oZnVuY3Rpb24oIGZhY3RvcnkgKXtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldCddLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xuXHRcdFx0aWYgKCAhIHJvb3QgKSB7XG5cdFx0XHRcdHJvb3QgPSB3aW5kb3c7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISAkIHx8ICEgJC5mbi5kYXRhVGFibGUgKSB7XG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldCcpKHJvb3QsICQpLiQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCByb290LCByb290LmRvY3VtZW50ICk7XG5cdFx0fTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcbid1c2Ugc3RyaWN0JztcbnZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcblxuXG4vKipcbiAqIFJlc3BvbnNpdmUgaXMgYSBwbHVnLWluIGZvciB0aGUgRGF0YVRhYmxlcyBsaWJyYXJ5IHRoYXQgbWFrZXMgdXNlIG9mXG4gKiBEYXRhVGFibGVzJyBhYmlsaXR5IHRvIGNoYW5nZSB0aGUgdmlzaWJpbGl0eSBvZiBjb2x1bW5zLCBjaGFuZ2luZyB0aGVcbiAqIHZpc2liaWxpdHkgb2YgY29sdW1ucyBzbyB0aGUgZGlzcGxheWVkIGNvbHVtbnMgZml0IGludG8gdGhlIHRhYmxlIGNvbnRhaW5lci5cbiAqIFRoZSBlbmQgcmVzdWx0IGlzIHRoYXQgY29tcGxleCB0YWJsZXMgd2lsbCBiZSBkeW5hbWljYWxseSBhZGp1c3RlZCB0byBmaXRcbiAqIGludG8gdGhlIHZpZXdwb3J0LCBiZSBpdCBvbiBhIGRlc2t0b3AsIHRhYmxldCBvciBtb2JpbGUgYnJvd3Nlci5cbiAqXG4gKiBSZXNwb25zaXZlIGZvciBEYXRhVGFibGVzIGhhcyB0d28gbW9kZXMgb2Ygb3BlcmF0aW9uLCB3aGljaCBjYW4gdXNlZFxuICogaW5kaXZpZHVhbGx5IG9yIGNvbWJpbmVkOlxuICpcbiAqICogQ2xhc3MgbmFtZSBiYXNlZCBjb250cm9sIC0gY29sdW1ucyBhc3NpZ25lZCBjbGFzcyBuYW1lcyB0aGF0IG1hdGNoIHRoZVxuICogICBicmVha3BvaW50IGxvZ2ljIGNhbiBiZSBzaG93biAvIGhpZGRlbiBhcyByZXF1aXJlZCBmb3IgZWFjaCBicmVha3BvaW50LlxuICogKiBBdXRvbWF0aWMgY29udHJvbCAtIGNvbHVtbnMgYXJlIGF1dG9tYXRpY2FsbHkgaGlkZGVuIHdoZW4gdGhlcmUgaXMgbm9cbiAqICAgcm9vbSBsZWZ0IHRvIGRpc3BsYXkgdGhlbS4gQ29sdW1ucyByZW1vdmVkIGZyb20gdGhlIHJpZ2h0LlxuICpcbiAqIEluIGFkZGl0aW9uYWwgdG8gY29sdW1uIHZpc2liaWxpdHkgY29udHJvbCwgUmVzcG9uc2l2ZSBhbHNvIGhhcyBidWlsdCBpbnRvXG4gKiBvcHRpb25zIHRvIHVzZSBEYXRhVGFibGVzJyBjaGlsZCByb3cgZGlzcGxheSB0byBzaG93IC8gaGlkZSB0aGUgaW5mb3JtYXRpb25cbiAqIGZyb20gdGhlIHRhYmxlIHRoYXQgaGFzIGJlZW4gaGlkZGVuLiBUaGVyZSBhcmUgYWxzbyB0d28gbW9kZXMgb2Ygb3BlcmF0aW9uXG4gKiBmb3IgdGhpcyBjaGlsZCByb3cgZGlzcGxheTpcbiAqXG4gKiAqIElubGluZSAtIHdoZW4gdGhlIGNvbnRyb2wgZWxlbWVudCB0aGF0IHRoZSB1c2VyIGNhbiB1c2UgdG8gc2hvdyAvIGhpZGVcbiAqICAgY2hpbGQgcm93cyBpcyBkaXNwbGF5ZWQgaW5zaWRlIHRoZSBmaXJzdCBjb2x1bW4gb2YgdGhlIHRhYmxlLlxuICogKiBDb2x1bW4gLSB3aGVyZSBhIHdob2xlIGNvbHVtbiBpcyBkZWRpY2F0ZWQgdG8gYmUgdGhlIHNob3cgLyBoaWRlIGNvbnRyb2wuXG4gKlxuICogSW5pdGlhbGlzYXRpb24gb2YgUmVzcG9uc2l2ZSBpcyBwZXJmb3JtZWQgYnk6XG4gKlxuICogKiBBZGRpbmcgdGhlIGNsYXNzIGByZXNwb25zaXZlYCBvciBgZHQtcmVzcG9uc2l2ZWAgdG8gdGhlIHRhYmxlLiBJbiB0aGlzIGNhc2VcbiAqICAgUmVzcG9uc2l2ZSB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgaW5pdGlhbGlzZWQgd2l0aCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gKiAgIG9wdGlvbnMgd2hlbiB0aGUgRGF0YVRhYmxlIGlzIGNyZWF0ZWQuXG4gKiAqIFVzaW5nIHRoZSBgcmVzcG9uc2l2ZWAgb3B0aW9uIGluIHRoZSBEYXRhVGFibGVzIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gVGhpc1xuICogICBjYW4gYWxzbyBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucywgb3Igc2ltcGx5IHNldCB0b1xuICogICBgdHJ1ZWAgdG8gdXNlIHRoZSBkZWZhdWx0cy5cbiAqXG4gKiAgQGNsYXNzXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgaG9zdCB0YWJsZVxuICogIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAgQHJlcXVpcmVzIGpRdWVyeSAxLjcrXG4gKiAgQHJlcXVpcmVzIERhdGFUYWJsZXMgMS4xMC4zK1xuICpcbiAqICBAZXhhbXBsZVxuICogICAgICAkKCcjZXhhbXBsZScpLkRhdGFUYWJsZSgge1xuICogICAgICAgIHJlc3BvbnNpdmU6IHRydWVcbiAqICAgICAgfSApO1xuICogICAgfSApO1xuICovXG52YXIgUmVzcG9uc2l2ZSA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIG9wdHMgKSB7XG5cdC8vIFNhbml0eSBjaGVjayB0aGF0IHdlIGFyZSB1c2luZyBEYXRhVGFibGVzIDEuMTAgb3IgbmV3ZXJcblx0aWYgKCAhIERhdGFUYWJsZS52ZXJzaW9uQ2hlY2sgfHwgISBEYXRhVGFibGUudmVyc2lvbkNoZWNrKCAnMS4xMC4xMCcgKSApIHtcblx0XHR0aHJvdyAnRGF0YVRhYmxlcyBSZXNwb25zaXZlIHJlcXVpcmVzIERhdGFUYWJsZXMgMS4xMC4xMCBvciBuZXdlcic7XG5cdH1cblxuXHR0aGlzLnMgPSB7XG5cdFx0ZHQ6IG5ldyBEYXRhVGFibGUuQXBpKCBzZXR0aW5ncyApLFxuXHRcdGNvbHVtbnM6IFtdLFxuXHRcdGN1cnJlbnQ6IFtdXG5cdH07XG5cblx0Ly8gQ2hlY2sgaWYgcmVzcG9uc2l2ZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpc2VkIG9uIHRoaXMgdGFibGVcblx0aWYgKCB0aGlzLnMuZHQuc2V0dGluZ3MoKVswXS5yZXNwb25zaXZlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGRldGFpbHMgaXMgYW4gb2JqZWN0LCBidXQgZm9yIHNpbXBsaWNpdHkgdGhlIHVzZXIgY2FuIGdpdmUgaXQgYXMgYSBzdHJpbmdcblx0Ly8gb3IgYSBib29sZWFuXG5cdGlmICggb3B0cyAmJiB0eXBlb2Ygb3B0cy5kZXRhaWxzID09PSAnc3RyaW5nJyApIHtcblx0XHRvcHRzLmRldGFpbHMgPSB7IHR5cGU6IG9wdHMuZGV0YWlscyB9O1xuXHR9XG5cdGVsc2UgaWYgKCBvcHRzICYmIG9wdHMuZGV0YWlscyA9PT0gZmFsc2UgKSB7XG5cdFx0b3B0cy5kZXRhaWxzID0geyB0eXBlOiBmYWxzZSB9O1xuXHR9XG5cdGVsc2UgaWYgKCBvcHRzICYmIG9wdHMuZGV0YWlscyA9PT0gdHJ1ZSApIHtcblx0XHRvcHRzLmRldGFpbHMgPSB7IHR5cGU6ICdpbmxpbmUnIH07XG5cdH1cblxuXHR0aGlzLmMgPSAkLmV4dGVuZCggdHJ1ZSwge30sIFJlc3BvbnNpdmUuZGVmYXVsdHMsIERhdGFUYWJsZS5kZWZhdWx0cy5yZXNwb25zaXZlLCBvcHRzICk7XG5cdHNldHRpbmdzLnJlc3BvbnNpdmUgPSB0aGlzO1xuXHR0aGlzLl9jb25zdHJ1Y3RvcigpO1xufTtcblxuJC5leHRlbmQoIFJlc3BvbnNpdmUucHJvdG90eXBlLCB7XG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogQ29uc3RydWN0b3Jcblx0ICovXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpc2UgdGhlIFJlc3BvbnNpdmUgaW5zdGFuY2Vcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jb25zdHJ1Y3RvcjogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGR0UHJpdmF0ZVNldHRpbmdzID0gZHQuc2V0dGluZ3MoKVswXTtcblx0XHR2YXIgb2xkV2luZG93V2lkdGggPSAkKHdpbmRvdykuaW5uZXJXaWR0aCgpO1xuXG5cdFx0ZHQuc2V0dGluZ3MoKVswXS5fcmVzcG9uc2l2ZSA9IHRoaXM7XG5cblx0XHQvLyBVc2UgRGF0YVRhYmxlcycgdGhyb3R0bGUgZnVuY3Rpb24gdG8gYXZvaWQgcHJvY2Vzc29yIHRocmFzaGluZyBvblxuXHRcdC8vIHJlc2l6ZVxuXHRcdCQod2luZG93KS5vbiggJ3Jlc2l6ZS5kdHIgb3JpZW50YXRpb25jaGFuZ2UuZHRyJywgRGF0YVRhYmxlLnV0aWwudGhyb3R0bGUoIGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIGlPUyBoYXMgYSBidWcgd2hlcmVieSByZXNpemUgY2FuIGZpcmUgd2hlbiBvbmx5IHNjcm9sbGluZ1xuXHRcdFx0Ly8gU2VlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg4OTg0MTJcblx0XHRcdHZhciB3aWR0aCA9ICQod2luZG93KS5pbm5lcldpZHRoKCk7XG5cblx0XHRcdGlmICggd2lkdGggIT09IG9sZFdpbmRvd1dpZHRoICkge1xuXHRcdFx0XHR0aGF0Ll9yZXNpemUoKTtcblx0XHRcdFx0b2xkV2luZG93V2lkdGggPSB3aWR0aDtcblx0XHRcdH1cblx0XHR9ICkgKTtcblxuXHRcdC8vIERhdGFUYWJsZXMgZG9lc24ndCBjdXJyZW50bHkgdHJpZ2dlciBhbiBldmVudCB3aGVuIGEgcm93IGlzIGFkZGVkLCBzb1xuXHRcdC8vIHdlIG5lZWQgdG8gaG9vayBpbnRvIGl0cyBwcml2YXRlIEFQSSB0byBlbmZvcmNlIHRoZSBoaWRkZW4gcm93cyB3aGVuXG5cdFx0Ly8gbmV3IGRhdGEgaXMgYWRkZWRcblx0XHRkdFByaXZhdGVTZXR0aW5ncy5vQXBpLl9mbkNhbGxiYWNrUmVnKCBkdFByaXZhdGVTZXR0aW5ncywgJ2FvUm93Q3JlYXRlZENhbGxiYWNrJywgZnVuY3Rpb24gKHRyLCBkYXRhLCBpZHgpIHtcblx0XHRcdGlmICggJC5pbkFycmF5KCBmYWxzZSwgdGhhdC5zLmN1cnJlbnQgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdCQoJz50ZCwgPnRoJywgdHIpLmVhY2goIGZ1bmN0aW9uICggaSApIHtcblx0XHRcdFx0XHR2YXIgaWR4ID0gZHQuY29sdW1uLmluZGV4KCAndG9EYXRhJywgaSApO1xuXG5cdFx0XHRcdFx0aWYgKCB0aGF0LnMuY3VycmVudFtpZHhdID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdCQodGhpcykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvLyBEZXN0cm95IGV2ZW50IGhhbmRsZXJcblx0XHRkdC5vbiggJ2Rlc3Ryb3kuZHRyJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0ZHQub2ZmKCAnLmR0cicgKTtcblx0XHRcdCQoIGR0LnRhYmxlKCkuYm9keSgpICkub2ZmKCAnLmR0cicgKTtcblx0XHRcdCQod2luZG93KS5vZmYoICdyZXNpemUuZHRyIG9yaWVudGF0aW9uY2hhbmdlLmR0cicgKTtcblx0XHRcdGR0LmNlbGxzKCcuZHRyLWNvbnRyb2wnKS5ub2RlcygpLnRvJCgpLnJlbW92ZUNsYXNzKCdkdHItY29udHJvbCcpO1xuXG5cdFx0XHQvLyBSZXN0b3JlIHRoZSBjb2x1bW5zIHRoYXQgd2UndmUgaGlkZGVuXG5cdFx0XHQkLmVhY2goIHRoYXQucy5jdXJyZW50LCBmdW5jdGlvbiAoIGksIHZhbCApIHtcblx0XHRcdFx0aWYgKCB2YWwgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHRoYXQuX3NldENvbHVtblZpcyggaSwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gUmVvcmRlciB0aGUgYnJlYWtwb2ludHMgYXJyYXkgaGVyZSBpbiBjYXNlIHRoZXkgaGF2ZSBiZWVuIGFkZGVkIG91dFxuXHRcdC8vIG9mIG9yZGVyXG5cdFx0dGhpcy5jLmJyZWFrcG9pbnRzLnNvcnQoIGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS53aWR0aCA8IGIud2lkdGggPyAxIDpcblx0XHRcdFx0YS53aWR0aCA+IGIud2lkdGggPyAtMSA6IDA7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5fY2xhc3NMb2dpYygpO1xuXHRcdHRoaXMuX3Jlc2l6ZUF1dG8oKTtcblxuXHRcdC8vIERldGFpbHMgaGFuZGxlclxuXHRcdHZhciBkZXRhaWxzID0gdGhpcy5jLmRldGFpbHM7XG5cblx0XHRpZiAoIGRldGFpbHMudHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGF0Ll9kZXRhaWxzSW5pdCgpO1xuXG5cdFx0XHQvLyBEYXRhVGFibGVzIHdpbGwgdHJpZ2dlciB0aGlzIGV2ZW50IG9uIGV2ZXJ5IGNvbHVtbiBpdCBzaG93cyBhbmRcblx0XHRcdC8vIGhpZGVzIGluZGl2aWR1YWxseVxuXHRcdFx0ZHQub24oICdjb2x1bW4tdmlzaWJpbGl0eS5kdHInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIFVzZSBhIHNtYWxsIGRlYm91bmNlIHRvIGFsbG93IG11bHRpcGxlIGNvbHVtbnMgdG8gYmUgc2V0IHRvZ2V0aGVyXG5cdFx0XHRcdGlmICggdGhhdC5fdGltZXIgKSB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGF0Ll90aW1lciApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhhdC5fdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhhdC5fdGltZXIgPSBudWxsO1xuXG5cdFx0XHRcdFx0dGhhdC5fY2xhc3NMb2dpYygpO1xuXHRcdFx0XHRcdHRoYXQuX3Jlc2l6ZUF1dG8oKTtcblx0XHRcdFx0XHR0aGF0Ll9yZXNpemUodHJ1ZSk7XG5cblx0XHRcdFx0XHR0aGF0Ll9yZWRyYXdDaGlsZHJlbigpO1xuXHRcdFx0XHR9LCAxMDAgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gUmVkcmF3IHRoZSBkZXRhaWxzIGJveCBvbiBlYWNoIGRyYXcgd2hpY2ggd2lsbCBoYXBwZW4gaWYgdGhlIGRhdGFcblx0XHRcdC8vIGhhcyBjaGFuZ2VkLiBUaGlzIGlzIHVzZWQgdW50aWwgRGF0YVRhYmxlcyBpbXBsZW1lbnRzIGEgbmF0aXZlXG5cdFx0XHQvLyBgdXBkYXRlZGAgZXZlbnQgZm9yIHJvd3Ncblx0XHRcdGR0Lm9uKCAnZHJhdy5kdHInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoYXQuX3JlZHJhd0NoaWxkcmVuKCk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdCQoZHQudGFibGUoKS5ub2RlKCkpLmFkZENsYXNzKCAnZHRyLScrZGV0YWlscy50eXBlICk7XG5cdFx0fVxuXG5cdFx0ZHQub24oICdjb2x1bW4tcmVvcmRlci5kdHInLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGRldGFpbHMpIHtcblx0XHRcdHRoYXQuX2NsYXNzTG9naWMoKTtcblx0XHRcdHRoYXQuX3Jlc2l6ZUF1dG8oKTtcblx0XHRcdHRoYXQuX3Jlc2l6ZSh0cnVlKTtcblx0XHR9ICk7XG5cblx0XHQvLyBDaGFuZ2UgaW4gY29sdW1uIHNpemVzIG1lYW5zIHdlIG5lZWQgdG8gY2FsY1xuXHRcdGR0Lm9uKCAnY29sdW1uLXNpemluZy5kdHInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGF0Ll9yZXNpemVBdXRvKCk7XG5cdFx0XHR0aGF0Ll9yZXNpemUoKTtcblx0XHR9KTtcblxuXHRcdC8vIERUMiBsZXQncyB1cyB0ZWxsIGl0IGlmIHdlIGFyZSBoaWRpbmcgY29sdW1uc1xuXHRcdGR0Lm9uKCAnY29sdW1uLWNhbGMuZHQnLCBmdW5jdGlvbiAoZSwgZCkge1xuXHRcdFx0dmFyIGN1cnIgPSB0aGF0LnMuY3VycmVudDtcblxuXHRcdFx0Zm9yICh2YXIgaT0wIDsgaTxjdXJyLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0XHR2YXIgaWR4ID0gZC52aXNpYmxlLmluZGV4T2YoaSk7XG5cblx0XHRcdFx0aWYgKGN1cnJbaV0gPT09IGZhbHNlICYmIGlkeCA+PSAwKSB7XG5cdFx0XHRcdFx0ZC52aXNpYmxlLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0Ly8gT24gQWpheCByZWxvYWQgd2Ugd2FudCB0byByZW9wZW4gYW55IGNoaWxkIHJvd3Mgd2hpY2ggYXJlIGRpc3BsYXllZFxuXHRcdC8vIGJ5IHJlc3BvbnNpdmVcblx0XHRkdC5vbiggJ3ByZVhoci5kdHInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcm93SWRzID0gW107XG5cdFx0XHRkdC5yb3dzKCkuZXZlcnkoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmNoaWxkLmlzU2hvd24oKSApIHtcblx0XHRcdFx0XHRyb3dJZHMucHVzaCggdGhpcy5pZCh0cnVlKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRcdGR0Lm9uZSggJ2RyYXcuZHRyJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0Ll9yZXNpemVBdXRvKCk7XG5cdFx0XHRcdHRoYXQuX3Jlc2l6ZSgpO1xuXG5cdFx0XHRcdGR0LnJvd3MoIHJvd0lkcyApLmV2ZXJ5KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhhdC5fZGV0YWlsc0Rpc3BsYXkoIHRoaXMsIGZhbHNlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gKTtcblx0XHR9KTtcblxuXHRcdGR0XG5cdFx0XHQub24oICdkcmF3LmR0cicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhhdC5fY29udHJvbENsYXNzKCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCAnaW5pdC5kdHInLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGRldGFpbHMpIHtcblx0XHRcdFx0aWYgKCBlLm5hbWVzcGFjZSAhPT0gJ2R0JyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGF0Ll9yZXNpemVBdXRvKCk7XG5cdFx0XHRcdHRoYXQuX3Jlc2l6ZSgpO1xuXG5cdFx0XHRcdC8vIElmIGNvbHVtbnMgd2VyZSBoaWRkZW4sIHRoZW4gRGF0YVRhYmxlcyBuZWVkcyB0byBhZGp1c3QgdGhlXG5cdFx0XHRcdC8vIGNvbHVtbiBzaXppbmdcblx0XHRcdFx0aWYgKCAkLmluQXJyYXkoIGZhbHNlLCB0aGF0LnMuY3VycmVudCApICkge1xuXHRcdFx0XHRcdGR0LmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdC8vIEZpcnN0IHBhc3MgLSBkcmF3IHRoZSB0YWJsZSBmb3IgdGhlIGN1cnJlbnQgdmlld3BvcnQgc2l6ZVxuXHRcdHRoaXMuX3Jlc2l6ZSgpO1xuXHR9LFxuXG5cblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBQcml2YXRlIG1ldGhvZHNcblx0ICovXG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgdmlzaWJpbGl0eSBmb3IgdGhlIGNvbHVtbnMgaW4gYSB0YWJsZSBmb3IgYSBnaXZlblxuXHQgKiBicmVha3BvaW50LiBUaGUgcmVzdWx0IGlzIHByZS1kZXRlcm1pbmVkIGJhc2VkIG9uIHRoZSBjbGFzcyBsb2dpYyBpZlxuXHQgKiBjbGFzcyBuYW1lcyBhcmUgdXNlZCB0byBjb250cm9sIGFsbCBjb2x1bW5zLCBidXQgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZVxuXHQgKiBpcyBhbHNvIHVzZWQgaWYgdGhlcmUgYXJlIGNvbHVtbnMgd2hpY2ggYXJlIHRvIGJlIGF1dG9tYXRpY2FsbHkgc2hvd25cblx0ICogYW5kIGhpZGRlbi5cblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfSBicmVha3BvaW50IEJyZWFrcG9pbnQgbmFtZSB0byB1c2UgZm9yIHRoZSBjYWxjdWxhdGlvblxuXHQgKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXMgaW5pdGlhdGluZyB0aGUgdmlzaWJpbGl0eSBvZiBlYWNoXG5cdCAqICAgY29sdW1uLlxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdF9jb2x1bW5zVmlzaWJsaXR5OiBmdW5jdGlvbiAoIGJyZWFrcG9pbnQgKVxuXHR7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciBjb2x1bW5zID0gdGhpcy5zLmNvbHVtbnM7XG5cdFx0dmFyIGksIGllbjtcblxuXHRcdC8vIENyZWF0ZSBhbiBhcnJheSB0aGF0IGRlZmluZXMgdGhlIGNvbHVtbiBvcmRlcmluZyBiYXNlZCBmaXJzdCBvbiB0aGVcblx0XHQvLyBjb2x1bW4ncyBwcmlvcml0eSwgYW5kIHNlY29uZGx5IHRoZSBjb2x1bW4gaW5kZXguIFRoaXMgYWxsb3dzIHRoZVxuXHRcdC8vIGNvbHVtbnMgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSByaWdodCBpZiB0aGUgcHJpb3JpdHkgbWF0Y2hlc1xuXHRcdHZhciBvcmRlciA9IGNvbHVtbnNcblx0XHRcdC5tYXAoIGZ1bmN0aW9uICggY29sLCBpZHggKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y29sdW1uSWR4OiBpZHgsXG5cdFx0XHRcdFx0cHJpb3JpdHk6IGNvbC5wcmlvcml0eVxuXHRcdFx0XHR9O1xuXHRcdFx0fSApXG5cdFx0XHQuc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXHRcdFx0XHRpZiAoIGEucHJpb3JpdHkgIT09IGIucHJpb3JpdHkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhLmNvbHVtbklkeCAtIGIuY29sdW1uSWR4O1xuXHRcdFx0fSApO1xuXG5cdFx0Ly8gQ2xhc3MgbG9naWMgLSBkZXRlcm1pbmUgd2hpY2ggY29sdW1ucyBhcmUgaW4gdGhpcyBicmVha3BvaW50IGJhc2VkXG5cdFx0Ly8gb24gdGhlIGNsYXNzZXMuIElmIG5vIGNsYXNzIGNvbnRyb2wgKGkuZS4gYGF1dG9gKSB0aGVuIGAtYCBpcyB1c2VkXG5cdFx0Ly8gdG8gaW5kaWNhdGUgdGhpcyB0byB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb25cblx0XHR2YXIgZGlzcGxheSA9ICQubWFwKCBjb2x1bW5zLCBmdW5jdGlvbiAoIGNvbCwgaSApIHtcblx0XHRcdGlmICggZHQuY29sdW1uKGkpLnZpc2libGUoKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybiAnbm90LXZpc2libGUnO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbC5hdXRvICYmIGNvbC5taW5XaWR0aCA9PT0gbnVsbCA/XG5cdFx0XHRcdGZhbHNlIDpcblx0XHRcdFx0Y29sLmF1dG8gPT09IHRydWUgP1xuXHRcdFx0XHRcdCctJyA6XG5cdFx0XHRcdFx0JC5pbkFycmF5KCBicmVha3BvaW50LCBjb2wuaW5jbHVkZUluICkgIT09IC0xO1xuXHRcdH0gKTtcblxuXHRcdC8vIEF1dG8gY29sdW1uIGNvbnRyb2wgLSBmaXJzdCBwYXNzOiBob3cgbXVjaCB3aWR0aCBpcyB0YWtlbiBieSB0aGVcblx0XHQvLyBvbmVzIHRoYXQgbXVzdCBiZSBpbmNsdWRlZCBmcm9tIHRoZSBub24tYXV0byBjb2x1bW5zXG5cdFx0dmFyIHJlcXVpcmVkV2lkdGggPSAwO1xuXHRcdGZvciAoIGk9MCwgaWVuPWRpc3BsYXkubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGRpc3BsYXlbaV0gPT09IHRydWUgKSB7XG5cdFx0XHRcdHJlcXVpcmVkV2lkdGggKz0gY29sdW1uc1tpXS5taW5XaWR0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZWNvbmQgcGFzcywgdXNlIHVwIGFueSByZW1haW5pbmcgd2lkdGggZm9yIG90aGVyIGNvbHVtbnMuIEZvclxuXHRcdC8vIHNjcm9sbGluZyB0YWJsZXMgd2UgbmVlZCB0byBzdWJ0cmFjdCB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbGJhci4gSXRcblx0XHQvLyBtYXkgbm90IGJlIHJlcXVpcmVzIHdoaWNoIG1ha2VzIHRoaXMgc3ViLW9wdGltYWwsIGJ1dCBpdCB3b3VsZFxuXHRcdC8vIHJlcXVpcmUgYW5vdGhlciBmdWxsIHJlZHJhdyB0byBtYWtlIGNvbXBsZXRlIHVzZSBvZiB0aG9zZSBleHRyYSBmZXdcblx0XHQvLyBwaXhlbHNcblx0XHR2YXIgc2Nyb2xsaW5nID0gZHQuc2V0dGluZ3MoKVswXS5vU2Nyb2xsO1xuXHRcdHZhciBiYXIgPSBzY3JvbGxpbmcuc1kgfHwgc2Nyb2xsaW5nLnNYID8gc2Nyb2xsaW5nLmlCYXJXaWR0aCA6IDA7XG5cdFx0dmFyIHdpZHRoQXZhaWxhYmxlID0gZHQudGFibGUoKS5jb250YWluZXIoKS5vZmZzZXRXaWR0aCAtIGJhcjtcblx0XHR2YXIgdXNlZFdpZHRoID0gd2lkdGhBdmFpbGFibGUgLSByZXF1aXJlZFdpZHRoO1xuXG5cdFx0Ly8gQ29udHJvbCBjb2x1bW4gbmVlZHMgdG8gYWx3YXlzIGJlIGluY2x1ZGVkLiBUaGlzIG1ha2VzIGl0IHN1Yi1cblx0XHQvLyBvcHRpbWFsIGluIHRlcm1zIG9mIHVzaW5nIHRoZSBhdmFpbGFibGUgd2l0aCwgYnV0IHRvIHN0b3AgbGF5b3V0XG5cdFx0Ly8gdGhyYXNoaW5nIG9yIG92ZXJmbG93LiBBbHNvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIGNvbnRyb2wgY29sdW1uXG5cdFx0Ly8gd2lkdGggZmlyc3Qgc28gd2Uga25vdyBob3cgbXVjaCB3aWR0aCBpcyBhdmFpbGFibGUgZm9yIHRoZSBvdGhlclxuXHRcdC8vIGNvbHVtbnMsIHNpbmNlIHRoZSBjb250cm9sIGNvbHVtbiBtaWdodCBub3QgYmUgdGhlIGZpcnN0IG9uZSBzaG93blxuXHRcdGZvciAoIGk9MCwgaWVuPWRpc3BsYXkubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGNvbHVtbnNbaV0uY29udHJvbCApIHtcblx0XHRcdFx0dXNlZFdpZHRoIC09IGNvbHVtbnNbaV0ubWluV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY29sdW1ucyB0byBiZSBzaG93biAoY291bnRpbmcgYnkgcHJpb3JpdHkgYW5kIHRoZW4gcmlnaHQgdG9cblx0XHQvLyBsZWZ0KSB1bnRpbCB3ZSBydW4gb3V0IG9mIHJvb21cblx0XHR2YXIgZW1wdHkgPSBmYWxzZTtcblx0XHRmb3IgKCBpPTAsIGllbj1vcmRlci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhciBjb2xJZHggPSBvcmRlcltpXS5jb2x1bW5JZHg7XG5cblx0XHRcdGlmICggZGlzcGxheVtjb2xJZHhdID09PSAnLScgJiYgISBjb2x1bW5zW2NvbElkeF0uY29udHJvbCAmJiBjb2x1bW5zW2NvbElkeF0ubWluV2lkdGggKSB7XG5cdFx0XHRcdC8vIE9uY2Ugd2UndmUgZm91bmQgYSBjb2x1bW4gdGhhdCB3b24ndCBmaXQgd2UgZG9uJ3QgbGV0IGFueVxuXHRcdFx0XHQvLyBvdGhlcnMgZGlzcGxheSBlaXRoZXIsIG9yIGNvbHVtbnMgbWlnaHQgZGlzYXBwZWFyIGluIHRoZVxuXHRcdFx0XHQvLyBtaWRkbGUgb2YgdGhlIHRhYmxlXG5cdFx0XHRcdGlmICggZW1wdHkgfHwgdXNlZFdpZHRoIC0gY29sdW1uc1tjb2xJZHhdLm1pbldpZHRoIDwgMCApIHtcblx0XHRcdFx0XHRlbXB0eSA9IHRydWU7XG5cdFx0XHRcdFx0ZGlzcGxheVtjb2xJZHhdID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZGlzcGxheVtjb2xJZHhdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVzZWRXaWR0aCAtPSBjb2x1bW5zW2NvbElkeF0ubWluV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHRoZSAnY29udHJvbCcgY29sdW1uIHNob3VsZCBiZSBzaG93biAoaWYgdGhlcmUgaXMgb25lKS5cblx0XHQvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgYSBoaWRkZW4gY29sdW1uICh0aGF0IGlzIG5vdCB0aGVcblx0XHQvLyBjb250cm9sIGNvbHVtbikuIFRoZSB0d28gbG9vcHMgbG9vayBpbmVmZmljaWVudCBoZXJlLCBidXQgdGhleSBhcmVcblx0XHQvLyB0cml2aWFsIGFuZCB3aWxsIGZseSB0aHJvdWdoLiBXZSBuZWVkIHRvIGtub3cgdGhlIG91dGNvbWUgZnJvbSB0aGVcblx0XHQvLyBmaXJzdCAsIGJlZm9yZSB0aGUgYWN0aW9uIGluIHRoZSBzZWNvbmQgY2FuIGJlIHRha2VuXG5cdFx0dmFyIHNob3dDb250cm9sID0gZmFsc2U7XG5cblx0XHRmb3IgKCBpPTAsIGllbj1jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCAhIGNvbHVtbnNbaV0uY29udHJvbCAmJiAhIGNvbHVtbnNbaV0ubmV2ZXIgJiYgZGlzcGxheVtpXSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHNob3dDb250cm9sID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICggaT0wLCBpZW49Y29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggY29sdW1uc1tpXS5jb250cm9sICkge1xuXHRcdFx0XHRkaXNwbGF5W2ldID0gc2hvd0NvbnRyb2w7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlcGxhY2Ugbm90IHZpc2libGUgc3RyaW5nIHdpdGggZmFsc2UgZnJvbSB0aGUgY29udHJvbCBjb2x1bW4gZGV0ZWN0aW9uIGFib3ZlXG5cdFx0XHRpZiAoIGRpc3BsYXlbaV0gPT09ICdub3QtdmlzaWJsZScgKSB7XG5cdFx0XHRcdGRpc3BsYXlbaV0gPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaW5hbGx5IHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGNvbHVtbiB0aGF0XG5cdFx0Ly8gaXMgdmlzaWJsZVxuXHRcdGlmICggJC5pbkFycmF5KCB0cnVlLCBkaXNwbGF5ICkgPT09IC0xICkge1xuXHRcdFx0ZGlzcGxheVswXSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH0sXG5cblxuXHQvKipcblx0ICogQ3JlYXRlIHRoZSBpbnRlcm5hbCBgY29sdW1uc2AgYXJyYXkgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29sdW1uc1xuXHQgKiBmb3IgdGhlIHRhYmxlLiBUaGlzIGluY2x1ZGVzIGRldGVybWluaW5nIHdoaWNoIGJyZWFrcG9pbnRzIHRoZSBjb2x1bW5cblx0ICogd2lsbCBhcHBlYXIgaW4sIGJhc2VkIHVwb24gY2xhc3MgbmFtZXMgaW4gdGhlIGNvbHVtbiwgd2hpY2ggbWFrZXMgdXAgdGhlXG5cdCAqIHZhc3QgbWFqb3JpdHkgb2YgdGhpcyBtZXRob2QuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY2xhc3NMb2dpYzogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgY2FsYyA9IHt9O1xuXHRcdHZhciBicmVha3BvaW50cyA9IHRoaXMuYy5icmVha3BvaW50cztcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGNvbHVtbnMgPSBkdC5jb2x1bW5zKCkuZXEoMCkubWFwKCBmdW5jdGlvbiAoaSkge1xuXHRcdFx0dmFyIGNvbHVtbiA9IHRoaXMuY29sdW1uKGkpO1xuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGNvbHVtbi5oZWFkZXIoKS5jbGFzc05hbWU7XG5cdFx0XHR2YXIgcHJpb3JpdHkgPSBkdC5zZXR0aW5ncygpWzBdLmFvQ29sdW1uc1tpXS5yZXNwb25zaXZlUHJpb3JpdHk7XG5cdFx0XHR2YXIgZGF0YVByaW9yaXR5ID0gY29sdW1uLmhlYWRlcigpLmdldEF0dHJpYnV0ZSgnZGF0YS1wcmlvcml0eScpO1xuXG5cdFx0XHRpZiAoIHByaW9yaXR5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHByaW9yaXR5ID0gZGF0YVByaW9yaXR5ID09PSB1bmRlZmluZWQgfHwgZGF0YVByaW9yaXR5ID09PSBudWxsP1xuXHRcdFx0XHRcdDEwMDAwIDpcblx0XHRcdFx0XHRkYXRhUHJpb3JpdHkgKiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjbGFzc05hbWU6IGNsYXNzTmFtZSxcblx0XHRcdFx0aW5jbHVkZUluOiBbXSxcblx0XHRcdFx0YXV0bzogICAgICBmYWxzZSxcblx0XHRcdFx0Y29udHJvbDogICBmYWxzZSxcblx0XHRcdFx0bmV2ZXI6ICAgICBjbGFzc05hbWUubWF0Y2goL1xcYihkdHJcXC0pP25ldmVyXFxiLykgPyB0cnVlIDogZmFsc2UsXG5cdFx0XHRcdHByaW9yaXR5OiAgcHJpb3JpdHlcblx0XHRcdH07XG5cdFx0fSApO1xuXG5cdFx0Ly8gU2ltcGx5IGFkZCBhIGJyZWFrcG9pbnQgdG8gYGluY2x1ZGVJbmAgYXJyYXksIGVuc3VyaW5nIHRoYXQgdGhlcmUgYXJlXG5cdFx0Ly8gbm8gZHVwbGljYXRlc1xuXHRcdHZhciBhZGQgPSBmdW5jdGlvbiAoIGNvbElkeCwgbmFtZSApIHtcblx0XHRcdHZhciBpbmNsdWRlSW4gPSBjb2x1bW5zWyBjb2xJZHggXS5pbmNsdWRlSW47XG5cblx0XHRcdGlmICggJC5pbkFycmF5KCBuYW1lLCBpbmNsdWRlSW4gKSA9PT0gLTEgKSB7XG5cdFx0XHRcdGluY2x1ZGVJbi5wdXNoKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBjb2x1bW4gPSBmdW5jdGlvbiAoIGNvbElkeCwgbmFtZSwgb3BlcmF0b3IsIG1hdGNoZWQgKSB7XG5cdFx0XHR2YXIgc2l6ZSwgaSwgaWVuO1xuXG5cdFx0XHRpZiAoICEgb3BlcmF0b3IgKSB7XG5cdFx0XHRcdGNvbHVtbnNbIGNvbElkeCBdLmluY2x1ZGVJbi5wdXNoKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggb3BlcmF0b3IgPT09ICdtYXgtJyApIHtcblx0XHRcdFx0Ly8gQWRkIHRoaXMgYnJlYWtwb2ludCBhbmQgYWxsIHNtYWxsZXJcblx0XHRcdFx0c2l6ZSA9IHRoYXQuX2ZpbmQoIG5hbWUgKS53aWR0aDtcblxuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1icmVha3BvaW50cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGJyZWFrcG9pbnRzW2ldLndpZHRoIDw9IHNpemUgKSB7XG5cdFx0XHRcdFx0XHRhZGQoIGNvbElkeCwgYnJlYWtwb2ludHNbaV0ubmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG9wZXJhdG9yID09PSAnbWluLScgKSB7XG5cdFx0XHRcdC8vIEFkZCB0aGlzIGJyZWFrcG9pbnQgYW5kIGFsbCBsYXJnZXJcblx0XHRcdFx0c2l6ZSA9IHRoYXQuX2ZpbmQoIG5hbWUgKS53aWR0aDtcblxuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1icmVha3BvaW50cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGJyZWFrcG9pbnRzW2ldLndpZHRoID49IHNpemUgKSB7XG5cdFx0XHRcdFx0XHRhZGQoIGNvbElkeCwgYnJlYWtwb2ludHNbaV0ubmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG9wZXJhdG9yID09PSAnbm90LScgKSB7XG5cdFx0XHRcdC8vIEFkZCBhbGwgYnV0IHRoaXMgYnJlYWtwb2ludFxuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1icmVha3BvaW50cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGJyZWFrcG9pbnRzW2ldLm5hbWUuaW5kZXhPZiggbWF0Y2hlZCApID09PSAtMSApIHtcblx0XHRcdFx0XHRcdGFkZCggY29sSWR4LCBicmVha3BvaW50c1tpXS5uYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIExvb3Agb3ZlciBlYWNoIGNvbHVtbiBhbmQgZGV0ZXJtaW5lIGlmIGl0IGhhcyBhIHJlc3BvbnNpdmUgY29udHJvbFxuXHRcdC8vIGNsYXNzXG5cdFx0Y29sdW1ucy5lYWNoKCBmdW5jdGlvbiAoIGNvbCwgaSApIHtcblx0XHRcdHZhciBjbGFzc05hbWVzID0gY29sLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXHRcdFx0dmFyIGhhc0NsYXNzID0gZmFsc2U7XG5cblx0XHRcdC8vIFNwbGl0IHRoZSBjbGFzcyBuYW1lIHVwIHNvIG11bHRpcGxlIHJ1bGVzIGNhbiBiZSBhcHBsaWVkIGlmIG5lZWRlZFxuXHRcdFx0Zm9yICggdmFyIGs9MCwga2VuPWNsYXNzTmFtZXMubGVuZ3RoIDsgazxrZW4gOyBrKysgKSB7XG5cdFx0XHRcdHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2tdLnRyaW0oKTtcblxuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSA9PT0gJ2FsbCcgfHwgY2xhc3NOYW1lID09PSAnZHRyLWFsbCcgKSB7XG5cdFx0XHRcdFx0Ly8gSW5jbHVkZSBpbiBhbGxcblx0XHRcdFx0XHRoYXNDbGFzcyA9IHRydWU7XG5cdFx0XHRcdFx0Y29sLmluY2x1ZGVJbiA9ICQubWFwKCBicmVha3BvaW50cywgZnVuY3Rpb24gKGEpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhLm5hbWU7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggY2xhc3NOYW1lID09PSAnbm9uZScgfHwgY2xhc3NOYW1lID09PSAnZHRyLW5vbmUnIHx8IGNvbC5uZXZlciApIHtcblx0XHRcdFx0XHQvLyBJbmNsdWRlIGluIG5vbmUgKGRlZmF1bHQpIGFuZCBubyBhdXRvXG5cdFx0XHRcdFx0aGFzQ2xhc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggY2xhc3NOYW1lID09PSAnY29udHJvbCcgfHwgY2xhc3NOYW1lID09PSAnZHRyLWNvbnRyb2wnICkge1xuXHRcdFx0XHRcdC8vIFNwZWNpYWwgY29sdW1uIHRoYXQgaXMgb25seSB2aXNpYmxlLCB3aGVuIG9uZSBvZiB0aGUgb3RoZXJcblx0XHRcdFx0XHQvLyBjb2x1bW5zIGlzIGhpZGRlbi4gVGhpcyBpcyB1c2VkIGZvciB0aGUgZGV0YWlscyBjb250cm9sXG5cdFx0XHRcdFx0aGFzQ2xhc3MgPSB0cnVlO1xuXHRcdFx0XHRcdGNvbC5jb250cm9sID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQkLmVhY2goIGJyZWFrcG9pbnRzLCBmdW5jdGlvbiAoIGosIGJyZWFrcG9pbnQgKSB7XG5cdFx0XHRcdFx0Ly8gRG9lcyB0aGlzIGNvbHVtbiBoYXZlIGEgY2xhc3MgdGhhdCBtYXRjaGVzIHRoaXMgYnJlYWtwb2ludD9cblx0XHRcdFx0XHR2YXIgYnJva2VuUG9pbnQgPSBicmVha3BvaW50Lm5hbWUuc3BsaXQoJy0nKTtcblx0XHRcdFx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKCAnKG1pblxcXFwtfG1heFxcXFwtfG5vdFxcXFwtKT8oJyticm9rZW5Qb2ludFswXSsnKShcXFxcLVtfYS16QS1aMC05XSk/JyApO1xuXHRcdFx0XHRcdHZhciBtYXRjaCA9IGNsYXNzTmFtZS5tYXRjaCggcmUgKTtcblxuXHRcdFx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdFx0XHRoYXNDbGFzcyA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hbMl0gPT09IGJyb2tlblBvaW50WzBdICYmIG1hdGNoWzNdID09PSAnLScrYnJva2VuUG9pbnRbMV0gKSB7XG5cdFx0XHRcdFx0XHRcdC8vIENsYXNzIG5hbWUgbWF0Y2hlcyBicmVha3BvaW50IG5hbWUgZnVsbHlcblx0XHRcdFx0XHRcdFx0Y29sdW1uKCBpLCBicmVha3BvaW50Lm5hbWUsIG1hdGNoWzFdLCBtYXRjaFsyXSttYXRjaFszXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoIG1hdGNoWzJdID09PSBicm9rZW5Qb2ludFswXSAmJiAhIG1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFx0XHQvLyBDbGFzcyBuYW1lIG1hdGNoZWQgcHJpbWFyeSBicmVha3BvaW50IG5hbWUgd2l0aCBubyBxdWFsaWZpZXJcblx0XHRcdFx0XHRcdFx0Y29sdW1uKCBpLCBicmVha3BvaW50Lm5hbWUsIG1hdGNoWzFdLCBtYXRjaFsyXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGVyZSB3YXMgbm8gY29udHJvbCBjbGFzcywgdGhlbiBhdXRvbWF0aWMgc2l6aW5nIGlzIHVzZWRcblx0XHRcdGlmICggISBoYXNDbGFzcyApIHtcblx0XHRcdFx0Y29sLmF1dG8gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHRoaXMucy5jb2x1bW5zID0gY29sdW1ucztcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBjZWxscyB0byBzaG93IHRoZSBjb3JyZWN0IGNvbnRyb2wgY2xhc3MgLyBidXR0b25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jb250cm9sQ2xhc3M6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRpZiAoIHRoaXMuYy5kZXRhaWxzLnR5cGUgPT09ICdpbmxpbmUnICkge1xuXHRcdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdFx0dmFyIGNvbHVtbnNWaXMgPSB0aGlzLnMuY3VycmVudDtcblx0XHRcdHZhciBmaXJzdFZpc2libGUgPSAkLmluQXJyYXkodHJ1ZSwgY29sdW1uc1Zpcyk7XG5cblx0XHRcdC8vIFJlbW92ZSBmcm9tIGFueSBjZWxscyB3aGljaCBzaG91bGRuJ3QgaGF2ZSBpdFxuXHRcdFx0ZHQuY2VsbHMoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGZ1bmN0aW9uKGlkeCkge1xuXHRcdFx0XHRcdHJldHVybiBpZHggIT09IGZpcnN0VmlzaWJsZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0e3BhZ2U6ICdjdXJyZW50J31cblx0XHRcdClcblx0XHRcdFx0Lm5vZGVzKClcblx0XHRcdFx0LnRvJCgpXG5cdFx0XHRcdC5maWx0ZXIoJy5kdHItY29udHJvbCcpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcygnZHRyLWNvbnRyb2wnKTtcblxuXHRcdFx0ZHQuY2VsbHMobnVsbCwgZmlyc3RWaXNpYmxlLCB7cGFnZTogJ2N1cnJlbnQnfSlcblx0XHRcdFx0Lm5vZGVzKClcblx0XHRcdFx0LnRvJCgpXG5cdFx0XHRcdC5hZGRDbGFzcygnZHRyLWNvbnRyb2wnKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNob3cgdGhlIGRldGFpbHMgZm9yIHRoZSBjaGlsZCByb3dcblx0ICpcblx0ICogQHBhcmFtICB7RGF0YVRhYmxlcy5BcGl9IHJvdyAgICBBUEkgaW5zdGFuY2UgZm9yIHRoZSByb3dcblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIHVwZGF0ZSBVcGRhdGUgZmxhZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RldGFpbHNEaXNwbGF5OiBmdW5jdGlvbiAoIHJvdywgdXBkYXRlIClcblx0e1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGRldGFpbHMgPSB0aGlzLmMuZGV0YWlscztcblxuXHRcdGlmICggZGV0YWlscyAmJiBkZXRhaWxzLnR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dmFyIHJlbmRlcmVyID0gdHlwZW9mIGRldGFpbHMucmVuZGVyZXIgPT09ICdzdHJpbmcnXG5cdFx0XHRcdD8gUmVzcG9uc2l2ZS5yZW5kZXJlcltkZXRhaWxzLnJlbmRlcmVyXSgpXG5cdFx0XHRcdDogZGV0YWlscy5yZW5kZXJlcjtcblxuXHRcdFx0dmFyIHJlcyA9IGRldGFpbHMuZGlzcGxheSggcm93LCB1cGRhdGUsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHJlbmRlcmVyKFxuXHRcdFx0XHRcdGR0LCByb3dbMF0sIHRoYXQuX2RldGFpbHNPYmoocm93WzBdKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXG5cdFx0XHRpZiAoIHJlcyA9PT0gdHJ1ZSB8fCByZXMgPT09IGZhbHNlICkge1xuXHRcdFx0XHQkKGR0LnRhYmxlKCkubm9kZSgpKS50cmlnZ2VySGFuZGxlciggJ3Jlc3BvbnNpdmUtZGlzcGxheS5kdCcsIFtkdCwgcm93LCByZXMsIHVwZGF0ZV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvKipcblx0ICogSW5pdGlhbGlzYXRpb24gZm9yIHRoZSBkZXRhaWxzIGhhbmRsZXJcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kZXRhaWxzSW5pdDogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciB0aGF0ICAgID0gdGhpcztcblx0XHR2YXIgZHQgICAgICA9IHRoaXMucy5kdDtcblx0XHR2YXIgZGV0YWlscyA9IHRoaXMuYy5kZXRhaWxzO1xuXG5cdFx0Ly8gVGhlIGlubGluZSB0eXBlIGFsd2F5cyB1c2VzIHRoZSBmaXJzdCBjaGlsZCBhcyB0aGUgdGFyZ2V0XG5cdFx0aWYgKCBkZXRhaWxzLnR5cGUgPT09ICdpbmxpbmUnICkge1xuXHRcdFx0ZGV0YWlscy50YXJnZXQgPSAndGQuZHRyLWNvbnRyb2wsIHRoLmR0ci1jb250cm9sJztcblx0XHR9XG5cblx0XHQvLyBLZXlib2FyZCBhY2Nlc3NpYmlsaXR5XG5cdFx0ZHQub24oICdkcmF3LmR0cicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQuX3RhYkluZGV4ZXMoKTtcblx0XHR9ICk7XG5cdFx0dGhhdC5fdGFiSW5kZXhlcygpOyAvLyBJbml0aWFsIGRyYXcgaGFzIGFscmVhZHkgaGFwcGVuZWRcblxuXHRcdCQoIGR0LnRhYmxlKCkuYm9keSgpICkub24oICdrZXl1cC5kdHInLCAndGQsIHRoJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmICggZS5rZXlDb2RlID09PSAxMyAmJiAkKHRoaXMpLmRhdGEoJ2R0ci1rZXlib2FyZCcpICkge1xuXHRcdFx0XHQkKHRoaXMpLmNsaWNrKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0Ly8gdHlwZS50YXJnZXQgY2FuIGJlIGEgc3RyaW5nIGpRdWVyeSBzZWxlY3RvciBvciBhIGNvbHVtbiBpbmRleFxuXHRcdHZhciB0YXJnZXQgICA9IGRldGFpbHMudGFyZ2V0O1xuXHRcdHZhciBzZWxlY3RvciA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogJ3RkLCB0aCc7XG5cblx0XHRpZiAoIHRhcmdldCAhPT0gdW5kZWZpbmVkIHx8IHRhcmdldCAhPT0gbnVsbCApIHtcblx0XHRcdC8vIENsaWNrIGhhbmRsZXIgdG8gc2hvdyAvIGhpZGUgdGhlIGRldGFpbHMgcm93cyB3aGVuIHRoZXkgYXJlIGF2YWlsYWJsZVxuXHRcdFx0JCggZHQudGFibGUoKS5ib2R5KCkgKVxuXHRcdFx0XHQub24oICdjbGljay5kdHIgbW91c2Vkb3duLmR0ciBtb3VzZXVwLmR0cicsIHNlbGVjdG9yLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdC8vIElmIHRoZSB0YWJsZSBpcyBub3QgY29sbGFwc2VkIChpLmUuIHRoZXJlIGlzIG5vIGhpZGRlbiBjb2x1bW5zKVxuXHRcdFx0XHRcdC8vIHRoZW4gdGFrZSBubyBhY3Rpb25cblx0XHRcdFx0XHRpZiAoICEgJChkdC50YWJsZSgpLm5vZGUoKSkuaGFzQ2xhc3MoJ2NvbGxhcHNlZCcgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDaGVjayB0aGF0IHRoZSByb3cgaXMgYWN0dWFsbHkgYSBEYXRhVGFibGUncyBjb250cm9sbGVkIG5vZGVcblx0XHRcdFx0XHRpZiAoICQuaW5BcnJheSggJCh0aGlzKS5jbG9zZXN0KCd0cicpLmdldCgwKSwgZHQucm93cygpLm5vZGVzKCkudG9BcnJheSgpICkgPT09IC0xICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZvciBjb2x1bW4gaW5kZXgsIHdlIGRldGVybWluZSBpZiB3ZSBzaG91bGQgYWN0IG9yIG5vdCBpbiB0aGVcblx0XHRcdFx0XHQvLyBoYW5kbGVyIC0gb3RoZXJ3aXNlIGl0IGlzIGFscmVhZHkgb2theVxuXHRcdFx0XHRcdGlmICggdHlwZW9mIHRhcmdldCA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHRcdFx0XHR2YXIgdGFyZ2V0SWR4ID0gdGFyZ2V0IDwgMCA/XG5cdFx0XHRcdFx0XHRcdGR0LmNvbHVtbnMoKS5lcSgwKS5sZW5ndGggKyB0YXJnZXQgOlxuXHRcdFx0XHRcdFx0XHR0YXJnZXQ7XG5cblx0XHRcdFx0XHRcdGlmICggZHQuY2VsbCggdGhpcyApLmluZGV4KCkuY29sdW1uICE9PSB0YXJnZXRJZHggKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyAkKCkuY2xvc2VzdCgpIGluY2x1ZGVzIGl0c2VsZiBpbiBpdHMgY2hlY2tcblx0XHRcdFx0XHR2YXIgcm93ID0gZHQucm93KCAkKHRoaXMpLmNsb3Nlc3QoJ3RyJykgKTtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGV2ZW50IHR5cGUgdG8gZG8gYW4gYWN0aW9uXG5cdFx0XHRcdFx0aWYgKCBlLnR5cGUgPT09ICdjbGljaycgKSB7XG5cdFx0XHRcdFx0XHQvLyBUaGUgcmVuZGVyZXIgaXMgZ2l2ZW4gYXMgYSBmdW5jdGlvbiBzbyB0aGUgY2FsbGVyIGNhbiBleGVjdXRlIGl0XG5cdFx0XHRcdFx0XHQvLyBvbmx5IHdoZW4gdGhleSBuZWVkIChpLmUuIGlmIGhpZGluZyB0aGVyZSBpcyBubyBwb2ludCBpcyBydW5uaW5nXG5cdFx0XHRcdFx0XHQvLyB0aGUgcmVuZGVyZXIpXG5cdFx0XHRcdFx0XHR0aGF0Ll9kZXRhaWxzRGlzcGxheSggcm93LCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggZS50eXBlID09PSAnbW91c2Vkb3duJyApIHtcblx0XHRcdFx0XHRcdC8vIEZvciBtb3VzZSB1c2VycywgcHJldmVudCB0aGUgZm9jdXMgcmluZyBmcm9tIHNob3dpbmdcblx0XHRcdFx0XHRcdCQodGhpcykuY3NzKCdvdXRsaW5lJywgJ25vbmUnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGUudHlwZSA9PT0gJ21vdXNldXAnICkge1xuXHRcdFx0XHRcdFx0Ly8gQW5kIHRoZW4gcmUtYWxsb3cgYXQgdGhlIGVuZCBvZiB0aGUgY2xpY2tcblx0XHRcdFx0XHRcdCQodGhpcykudHJpZ2dlcignYmx1cicpLmNzcygnb3V0bGluZScsICcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvKipcblx0ICogR2V0IHRoZSBkZXRhaWxzIHRvIHBhc3MgdG8gYSByZW5kZXJlciBmb3IgYSByb3dcblx0ICogQHBhcmFtICB7aW50fSByb3dJZHggUm93IGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZGV0YWlsc09iajogZnVuY3Rpb24gKCByb3dJZHggKVxuXHR7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblxuXHRcdHJldHVybiAkLm1hcCggdGhpcy5zLmNvbHVtbnMsIGZ1bmN0aW9uKCBjb2wsIGkgKSB7XG5cdFx0XHQvLyBOZXZlciBhbmQgY29udHJvbCBjb2x1bW5zIHNob3VsZCBub3QgYmUgcGFzc2VkIHRvIHRoZSByZW5kZXJlclxuXHRcdFx0aWYgKCBjb2wubmV2ZXIgfHwgY29sLmNvbnRyb2wgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGR0Q29sID0gZHQuc2V0dGluZ3MoKVswXS5hb0NvbHVtbnNbIGkgXTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2xhc3NOYW1lOiAgIGR0Q29sLnNDbGFzcyxcblx0XHRcdFx0Y29sdW1uSW5kZXg6IGksXG5cdFx0XHRcdGRhdGE6ICAgICAgICBkdC5jZWxsKCByb3dJZHgsIGkgKS5yZW5kZXIoIHRoYXQuYy5vcnRob2dvbmFsICksXG5cdFx0XHRcdGhpZGRlbjogICAgICBkdC5jb2x1bW4oIGkgKS52aXNpYmxlKCkgJiYgIXRoYXQucy5jdXJyZW50WyBpIF0sXG5cdFx0XHRcdHJvd0luZGV4OiAgICByb3dJZHgsXG5cdFx0XHRcdHRpdGxlOiAgICAgICBkdENvbC5zVGl0bGUgIT09IG51bGwgP1xuXHRcdFx0XHRcdGR0Q29sLnNUaXRsZSA6XG5cdFx0XHRcdFx0JChkdC5jb2x1bW4oaSkuaGVhZGVyKCkpLnRleHQoKVxuXHRcdFx0fTtcblx0XHR9ICk7XG5cdH0sXG5cblxuXHQvKipcblx0ICogRmluZCBhIGJyZWFrcG9pbnQgb2JqZWN0IGZyb20gYSBuYW1lXG5cdCAqXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSBCcmVha3BvaW50IG5hbWUgdG8gZmluZFxuXHQgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgQnJlYWtwb2ludCBkZXNjcmlwdGlvbiBvYmplY3Rcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9maW5kOiBmdW5jdGlvbiAoIG5hbWUgKVxuXHR7XG5cdFx0dmFyIGJyZWFrcG9pbnRzID0gdGhpcy5jLmJyZWFrcG9pbnRzO1xuXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWJyZWFrcG9pbnRzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBicmVha3BvaW50c1tpXS5uYW1lID09PSBuYW1lICkge1xuXHRcdFx0XHRyZXR1cm4gYnJlYWtwb2ludHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIFJlLWNyZWF0ZSB0aGUgY29udGVudHMgb2YgdGhlIGNoaWxkIHJvd3MgYXMgdGhlIGRpc3BsYXkgaGFzIGNoYW5nZWQgaW5cblx0ICogc29tZSB3YXkuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVkcmF3Q2hpbGRyZW46IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXG5cdFx0ZHQucm93cygge3BhZ2U6ICdjdXJyZW50J30gKS5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGlkeCApIHtcblx0XHRcdHZhciByb3cgPSBkdC5yb3coIGlkeCApO1xuXG5cdFx0XHR0aGF0Ll9kZXRhaWxzRGlzcGxheSggZHQucm93KCBpZHggKSwgdHJ1ZSApO1xuXHRcdH0gKTtcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBBbHRlciB0aGUgdGFibGUgZGlzcGxheSBmb3IgYSByZXNpemVkIHZpZXdwb3J0LiBUaGlzIGludm9sdmVzIGZpcnN0XG5cdCAqIGRldGVybWluaW5nIHdoYXQgYnJlYWtwb2ludCB0aGUgd2luZG93IGN1cnJlbnRseSBpcyBpbiwgZ2V0dGluZyB0aGVcblx0ICogY29sdW1uIHZpc2liaWxpdGllcyB0byBhcHBseSBhbmQgdGhlbiBzZXR0aW5nIHRoZW0uXG5cdCAqXG5cdCAqIEBwYXJhbSAge2Jvb2xlYW59IGZvcmNlUmVkcmF3IEZvcmNlIGEgcmVkcmF3XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzaXplOiBmdW5jdGlvbiAoZm9yY2VSZWRyYXcpXG5cdHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciB3aWR0aCA9ICQod2luZG93KS5pbm5lcldpZHRoKCk7XG5cdFx0dmFyIGJyZWFrcG9pbnRzID0gdGhpcy5jLmJyZWFrcG9pbnRzO1xuXHRcdHZhciBicmVha3BvaW50ID0gYnJlYWtwb2ludHNbMF0ubmFtZTtcblx0XHR2YXIgY29sdW1ucyA9IHRoaXMucy5jb2x1bW5zO1xuXHRcdHZhciBpLCBpZW47XG5cdFx0dmFyIG9sZFZpcyA9IHRoaXMucy5jdXJyZW50LnNsaWNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgd2hhdCBicmVha3BvaW50IHdlIGFyZSBjdXJyZW50bHkgYXRcblx0XHRmb3IgKCBpPWJyZWFrcG9pbnRzLmxlbmd0aC0xIDsgaT49MCA7IGktLSApIHtcblx0XHRcdGlmICggd2lkdGggPD0gYnJlYWtwb2ludHNbaV0ud2lkdGggKSB7XG5cdFx0XHRcdGJyZWFrcG9pbnQgPSBicmVha3BvaW50c1tpXS5uYW1lO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gU2hvdyB0aGUgY29sdW1ucyBmb3IgdGhhdCBicmVhayBwb2ludFxuXHRcdHZhciBjb2x1bW5zVmlzID0gdGhpcy5fY29sdW1uc1Zpc2libGl0eSggYnJlYWtwb2ludCApO1xuXHRcdHRoaXMucy5jdXJyZW50ID0gY29sdW1uc1ZpcztcblxuXHRcdC8vIFNldCB0aGUgY2xhc3MgYmVmb3JlIHRoZSBjb2x1bW4gdmlzaWJpbGl0eSBpcyBjaGFuZ2VkIHNvIGV2ZW50XG5cdFx0Ly8gbGlzdGVuZXJzIGtub3cgd2hhdCB0aGUgc3RhdGUgaXMuIE5lZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZXJlIGFyZVxuXHRcdC8vIGFueSBjb2x1bW5zIHRoYXQgYXJlIG5vdCB2aXNpYmxlIGJ1dCBjYW4gYmUgc2hvd25cblx0XHR2YXIgY29sbGFwc2VkQ2xhc3MgPSBmYWxzZTtcblx0XG5cdFx0Zm9yICggaT0wLCBpZW49Y29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggY29sdW1uc1Zpc1tpXSA9PT0gZmFsc2UgJiYgISBjb2x1bW5zW2ldLm5ldmVyICYmICEgY29sdW1uc1tpXS5jb250cm9sICYmICEgZHQuY29sdW1uKGkpLnZpc2libGUoKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNvbGxhcHNlZENsYXNzID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0JCggZHQudGFibGUoKS5ub2RlKCkgKS50b2dnbGVDbGFzcyggJ2NvbGxhcHNlZCcsIGNvbGxhcHNlZENsYXNzICk7XG5cblx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXHRcdHZhciB2aXNpYmxlID0gMDtcblxuXHRcdGR0LmNvbHVtbnMoKS5lcSgwKS5lYWNoKCBmdW5jdGlvbiAoIGNvbElkeCwgaSApIHtcblx0XHRcdGlmICggY29sdW1uc1Zpc1tpXSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0dmlzaWJsZSsrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGZvcmNlUmVkcmF3IHx8IGNvbHVtbnNWaXNbaV0gIT09IG9sZFZpc1tpXSApIHtcblx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdHRoYXQuX3NldENvbHVtblZpcyggY29sSWR4LCBjb2x1bW5zVmlzW2ldICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0aWYgKCBjaGFuZ2VkICkge1xuXHRcdFx0dGhpcy5fcmVkcmF3Q2hpbGRyZW4oKTtcblxuXHRcdFx0Ly8gSW5mb3JtIGxpc3RlbmVycyBvZiB0aGUgY2hhbmdlXG5cdFx0XHQkKGR0LnRhYmxlKCkubm9kZSgpKS50cmlnZ2VyKCAncmVzcG9uc2l2ZS1yZXNpemUuZHQnLCBbZHQsIHRoaXMucy5jdXJyZW50XSApO1xuXG5cdFx0XHQvLyBJZiBubyByZWNvcmRzLCB1cGRhdGUgdGhlIFwiTm8gcmVjb3Jkc1wiIGRpc3BsYXkgZWxlbWVudFxuXHRcdFx0aWYgKCBkdC5wYWdlLmluZm8oKS5yZWNvcmRzRGlzcGxheSA9PT0gMCApIHtcblx0XHRcdFx0JCgndGQnLCBkdC50YWJsZSgpLmJvZHkoKSkuZXEoMCkuYXR0cignY29sc3BhbicsIHZpc2libGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoYXQuX2NvbnRyb2xDbGFzcygpO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgd2lkdGggb2YgZWFjaCBjb2x1bW4gaW4gdGhlIHRhYmxlIHNvIHRoZSBhdXRvIGNvbHVtbiBoaWRpbmdcblx0ICogaGFzIHRoYXQgaW5mb3JtYXRpb24gdG8gd29yayB3aXRoLiBUaGlzIG1ldGhvZCBpcyBuZXZlciBnb2luZyB0byBiZSAxMDAlXG5cdCAqIHBlcmZlY3Qgc2luY2UgY29sdW1uIHdpZHRocyBjYW4gY2hhbmdlIHNsaWdodGx5IHBlciBwYWdlLCBidXQgd2l0aG91dFxuXHQgKiBzZXJpb3VzbHkgY29tcHJvbWlzaW5nIHBlcmZvcm1hbmNlIHRoaXMgaXMgcXVpdGUgZWZmZWN0aXZlLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc2l6ZUF1dG86IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGNvbHVtbnMgPSB0aGlzLnMuY29sdW1ucztcblxuXHRcdC8vIEFyZSB3ZSBhbGxvd2VkIHRvIGRvIGF1dG8gc2l6aW5nP1xuXHRcdGlmICggISB0aGlzLmMuYXV0byApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBBcmUgdGhlcmUgYW55IGNvbHVtbnMgdGhhdCBhY3R1YWxseSBuZWVkIGF1dG8tc2l6aW5nLCBvciBkbyB0aGV5IGFsbFxuXHRcdC8vIGhhdmUgY2xhc3NlcyBkZWZpbmVkXG5cdFx0aWYgKCAkLmluQXJyYXkoIHRydWUsICQubWFwKCBjb2x1bW5zLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5hdXRvOyB9ICkgKSA9PT0gLTEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTmVlZCB0byByZXN0b3JlIGFsbCBjaGlsZHJlbi4gVGhleSB3aWxsIGJlIHJlaW5zdGF0ZWQgYnkgYSByZS1yZW5kZXJcblx0XHRpZiAoICEgJC5pc0VtcHR5T2JqZWN0KCBfY2hpbGROb2RlU3RvcmUgKSApIHtcblx0XHRcdCQuZWFjaCggX2NoaWxkTm9kZVN0b3JlLCBmdW5jdGlvbiAoIGtleSApIHtcblx0XHRcdFx0dmFyIGlkeCA9IGtleS5zcGxpdCgnLScpO1xuXG5cdFx0XHRcdF9jaGlsZE5vZGVzUmVzdG9yZSggZHQsIGlkeFswXSoxLCBpZHhbMV0qMSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIHRoZSB0YWJsZSB3aXRoIHRoZSBjdXJyZW50IGRhdGEgaW4gaXRcblx0XHR2YXIgdGFibGVXaWR0aCAgID0gZHQudGFibGUoKS5ub2RlKCkub2Zmc2V0V2lkdGg7XG5cdFx0dmFyIGNvbHVtbldpZHRocyA9IGR0LmNvbHVtbnM7XG5cdFx0dmFyIGNsb25lZFRhYmxlICA9IGR0LnRhYmxlKCkubm9kZSgpLmNsb25lTm9kZSggZmFsc2UgKTtcblx0XHR2YXIgY2xvbmVkSGVhZGVyID0gJCggZHQudGFibGUoKS5oZWFkZXIoKS5jbG9uZU5vZGUoIGZhbHNlICkgKS5hcHBlbmRUbyggY2xvbmVkVGFibGUgKTtcblx0XHR2YXIgY2xvbmVkQm9keSAgID0gJCggZHQudGFibGUoKS5ib2R5KCkgKS5jbG9uZSggZmFsc2UsIGZhbHNlICkuZW1wdHkoKS5hcHBlbmRUbyggY2xvbmVkVGFibGUgKTsgLy8gdXNlIGpRdWVyeSBiZWNhdXNlIG9mIElFOFxuXG5cdFx0Y2xvbmVkVGFibGUuc3R5bGUud2lkdGggPSAnYXV0byc7XG5cblx0XHQvLyBIZWFkZXJcblx0XHR2YXIgaGVhZGVyQ2VsbHMgPSBkdC5jb2x1bW5zKClcblx0XHRcdC5oZWFkZXIoKVxuXHRcdFx0LmZpbHRlciggZnVuY3Rpb24gKGlkeCkge1xuXHRcdFx0XHRyZXR1cm4gZHQuY29sdW1uKGlkeCkudmlzaWJsZSgpO1xuXHRcdFx0fSApXG5cdFx0XHQudG8kKClcblx0XHRcdC5jbG9uZSggZmFsc2UgKVxuXHRcdFx0LmNzcyggJ2Rpc3BsYXknLCAndGFibGUtY2VsbCcgKVxuXHRcdFx0LmNzcyggJ3dpZHRoJywgJ2F1dG8nIClcblx0XHRcdC5jc3MoICdtaW4td2lkdGgnLCAwICk7XG5cblx0XHQvLyBCb2R5IHJvd3MgLSB3ZSBkb24ndCBuZWVkIHRvIHRha2UgYWNjb3VudCBvZiBEYXRhVGFibGVzJyBjb2x1bW5cblx0XHQvLyB2aXNpYmlsaXR5IHNpbmNlIHdlIGltcGxlbWVudCBvdXIgb3duIGhlcmUgKGhlbmNlIHRoZSBgZGlzcGxheWAgc2V0KVxuXHRcdCQoY2xvbmVkQm9keSlcblx0XHRcdC5hcHBlbmQoICQoZHQucm93cyggeyBwYWdlOiAnY3VycmVudCcgfSApLm5vZGVzKCkpLmNsb25lKCBmYWxzZSApIClcblx0XHRcdC5maW5kKCAndGgsIHRkJyApLmNzcyggJ2Rpc3BsYXknLCAnJyApO1xuXG5cdFx0Ly8gRm9vdGVyXG5cdFx0dmFyIGZvb3RlciA9IGR0LnRhYmxlKCkuZm9vdGVyKCk7XG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHR2YXIgY2xvbmVkRm9vdGVyID0gJCggZm9vdGVyLmNsb25lTm9kZSggZmFsc2UgKSApLmFwcGVuZFRvKCBjbG9uZWRUYWJsZSApO1xuXHRcdFx0dmFyIGZvb3RlckNlbGxzID0gZHQuY29sdW1ucygpXG5cdFx0XHRcdC5mb290ZXIoKVxuXHRcdFx0XHQuZmlsdGVyKCBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGR0LmNvbHVtbihpZHgpLnZpc2libGUoKTtcblx0XHRcdFx0fSApXG5cdFx0XHRcdC50byQoKVxuXHRcdFx0XHQuY2xvbmUoIGZhbHNlIClcblx0XHRcdFx0LmNzcyggJ2Rpc3BsYXknLCAndGFibGUtY2VsbCcgKTtcblxuXHRcdFx0JCgnPHRyLz4nKVxuXHRcdFx0XHQuYXBwZW5kKCBmb290ZXJDZWxscyApXG5cdFx0XHRcdC5hcHBlbmRUbyggY2xvbmVkRm9vdGVyICk7XG5cdFx0fVxuXG5cdFx0JCgnPHRyLz4nKVxuXHRcdFx0LmFwcGVuZCggaGVhZGVyQ2VsbHMgKVxuXHRcdFx0LmFwcGVuZFRvKCBjbG9uZWRIZWFkZXIgKTtcblxuXHRcdC8vIEluIHRoZSBpbmxpbmUgY2FzZSBleHRyYSBwYWRkaW5nIGlzIGFwcGxpZWQgdG8gdGhlIGZpcnN0IGNvbHVtbiB0b1xuXHRcdC8vIGdpdmUgc3BhY2UgZm9yIHRoZSBzaG93IC8gaGlkZSBpY29uLiBXZSBuZWVkIHRvIHVzZSB0aGlzIGluIHRoZVxuXHRcdC8vIGNhbGN1bGF0aW9uXG5cdFx0aWYgKCB0aGlzLmMuZGV0YWlscy50eXBlID09PSAnaW5saW5lJyApIHtcblx0XHRcdCQoY2xvbmVkVGFibGUpLmFkZENsYXNzKCAnZHRyLWlubGluZSBjb2xsYXBzZWQnICk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEl0IGlzIHVuc2FmZSB0byBpbnNlcnQgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSBuYW1lIGludG8gdGhlIERPTVxuXHRcdC8vIG11bHRpcGxlIHRpbWVzLiBGb3IgZXhhbXBsZSwgY2xvbmluZyBhbmQgaW5zZXJ0aW5nIGEgY2hlY2tlZCByYWRpb1xuXHRcdC8vIGNsZWFycyB0aGUgY2hjZWNrZWQgc3RhdGUgb2YgdGhlIG9yaWdpbmFsIHJhZGlvLlxuXHRcdCQoIGNsb25lZFRhYmxlICkuZmluZCggJ1tuYW1lXScgKS5yZW1vdmVBdHRyKCAnbmFtZScgKTtcblxuXHRcdC8vIEEgcG9zaXRpb24gYWJzb2x1dGUgdGFibGUgd291bGQgdGFrZSB0aGUgdGFibGUgb3V0IG9mIHRoZSBmbG93IG9mXG5cdFx0Ly8gb3VyIGNvbnRhaW5lciBlbGVtZW50LCBieXBhc3NpbmcgdGhlIGhlaWdodCBhbmQgd2lkdGggKFNjcm9sbGVyKVxuXHRcdCQoIGNsb25lZFRhYmxlICkuY3NzKCAncG9zaXRpb24nLCAncmVsYXRpdmUnIClcblx0XHRcblx0XHR2YXIgaW5zZXJ0ZWQgPSAkKCc8ZGl2Lz4nKVxuXHRcdFx0LmNzcygge1xuXHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdFx0aGVpZ2h0OiAxLFxuXHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdGNsZWFyOiAnYm90aCdcblx0XHRcdH0gKVxuXHRcdFx0LmFwcGVuZCggY2xvbmVkVGFibGUgKTtcblxuXHRcdGluc2VydGVkLmluc2VydEJlZm9yZSggZHQudGFibGUoKS5ub2RlKCkgKTtcblxuXHRcdC8vIFRoZSBjbG9uZWQgaGVhZGVyIG5vdyBjb250YWlucyB0aGUgc21hbGxlc3QgdGhhdCBlYWNoIGNvbHVtbiBjYW4gYmVcblx0XHRoZWFkZXJDZWxscy5lYWNoKCBmdW5jdGlvbiAoaSkge1xuXHRcdFx0dmFyIGlkeCA9IGR0LmNvbHVtbi5pbmRleCggJ2Zyb21WaXNpYmxlJywgaSApO1xuXHRcdFx0Y29sdW1uc1sgaWR4IF0ubWluV2lkdGggPSAgdGhpcy5vZmZzZXRXaWR0aCB8fCAwO1xuXHRcdH0gKTtcblxuXHRcdGluc2VydGVkLnJlbW92ZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGhpZGRlbiBjb2x1bW5zIC0gY29udHJvbGxlZCBieSBSZXNwb25zaXZlIG9ubHlcblx0ICovXG5cdF9yZXNwb25zaXZlT25seUhpZGRlbjogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblxuXHRcdHJldHVybiAkLm1hcCggdGhpcy5zLmN1cnJlbnQsIGZ1bmN0aW9uICh2LCBpKSB7XG5cdFx0XHQvLyBJZiB0aGUgY29sdW1uIGlzIGhpZGRlbiBieSBEYXRhVGFibGVzIHRoZW4gaXQgY2FuJ3QgYmUgaGlkZGVuIGJ5XG5cdFx0XHQvLyBSZXNwb25zaXZlIVxuXHRcdFx0aWYgKCBkdC5jb2x1bW4oaSkudmlzaWJsZSgpID09PSBmYWxzZSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdjtcblx0XHR9ICk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBhIGNvbHVtbidzIHZpc2liaWxpdHkuXG5cdCAqXG5cdCAqIFdlIGRvbid0IHVzZSBEYXRhVGFibGVzJyBjb2x1bW4gdmlzaWJpbGl0eSBjb250cm9scyBpbiBvcmRlciB0byBlbnN1cmVcblx0ICogdGhhdCBjb2x1bW4gdmlzaWJpbGl0eSBjYW4gUmVzcG9uc2l2ZSBjYW4gbm8tZXhpc3QuIFNpbmNlIG9ubHkgSUU4KyBpc1xuXHQgKiBzdXBwb3J0ZWQgKGFuZCBhbGwgZXZlcmdyZWVuIGJyb3dzZXJzIG9mIGNvdXJzZSkgdGhlIGNvbnRyb2wgb2YgdGhlXG5cdCAqIGRpc3BsYXkgYXR0cmlidXRlIHdvcmtzIHdlbGwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7aW50ZWdlcn0gY29sICAgICAgQ29sdW1uIGluZGV4XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd0hpZGUgU2hvdyBvciBoaWRlICh0cnVlIG9yIGZhbHNlKVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NldENvbHVtblZpczogZnVuY3Rpb24gKCBjb2wsIHNob3dIaWRlIClcblx0e1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblx0XHR2YXIgZGlzcGxheSA9IHNob3dIaWRlID8gJycgOiAnbm9uZSc7IC8vIGVtcHR5IHN0cmluZyB3aWxsIHJlbW92ZSB0aGUgYXR0clxuXG5cdFx0JCggZHQuY29sdW1uKCBjb2wgKS5oZWFkZXIoKSApXG5cdFx0XHQuY3NzKCAnZGlzcGxheScsIGRpc3BsYXkgKVxuXHRcdFx0LnRvZ2dsZUNsYXNzKCdkdHItaGlkZGVuJywgIXNob3dIaWRlKTtcblxuXHRcdCQoIGR0LmNvbHVtbiggY29sICkuZm9vdGVyKCkgKVxuXHRcdFx0LmNzcyggJ2Rpc3BsYXknLCBkaXNwbGF5IClcblx0XHRcdC50b2dnbGVDbGFzcygnZHRyLWhpZGRlbicsICFzaG93SGlkZSk7XG5cblx0XHRkdC5jb2x1bW4oIGNvbCApLm5vZGVzKCkudG8kKClcblx0XHRcdC5jc3MoICdkaXNwbGF5JywgZGlzcGxheSApXG5cdFx0XHQudG9nZ2xlQ2xhc3MoJ2R0ci1oaWRkZW4nLCAhc2hvd0hpZGUpO1xuXG5cdFx0Ly8gSWYgdGhlIGFyZSBjaGlsZCBub2RlcyBzdG9yZWQsIHdlIG1pZ2h0IG5lZWQgdG8gcmVpbnNlcnQgdGhlbVxuXHRcdGlmICggISAkLmlzRW1wdHlPYmplY3QoIF9jaGlsZE5vZGVTdG9yZSApICkge1xuXHRcdFx0ZHQuY2VsbHMoIG51bGwsIGNvbCApLmluZGV4ZXMoKS5lYWNoKCBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdF9jaGlsZE5vZGVzUmVzdG9yZSggZHQsIGlkeC5yb3csIGlkeC5jb2x1bW4gKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBjZWxsIHRhYiBpbmRleGVzIGZvciBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5LiBUaGlzIGlzIGNhbGxlZCBvblxuXHQgKiBldmVyeSB0YWJsZSBkcmF3IC0gdGhhdCBpcyBwb3RlbnRpYWxseSBpbmVmZmljaWVudCwgYnV0IGFsc28gdGhlIGxlYXN0XG5cdCAqIGNvbXBsZXggb3B0aW9uIGdpdmVuIHRoYXQgY29sdW1uIHZpc2liaWxpdHkgY2FuIGNoYW5nZSBvbiB0aGUgZmx5LiBJdHMgYVxuXHQgKiBzaGFtZSB1c2VyLWZvY3VzIHdhcyByZW1vdmVkIGZyb20gQ1NTIDMgVUksIGFzIGl0IHdvdWxkIGhhdmUgc29sdmVkIHRoaXNcblx0ICogaXNzdWUgd2l0aCBhIHNpbmdsZSBDU1Mgc3RhdGVtZW50LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3RhYkluZGV4ZXM6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGNlbGxzID0gZHQuY2VsbHMoIHsgcGFnZTogJ2N1cnJlbnQnIH0gKS5ub2RlcygpLnRvJCgpO1xuXHRcdHZhciBjdHggPSBkdC5zZXR0aW5ncygpWzBdO1xuXHRcdHZhciB0YXJnZXQgPSB0aGlzLmMuZGV0YWlscy50YXJnZXQ7XG5cblx0XHRjZWxscy5maWx0ZXIoICdbZGF0YS1kdHIta2V5Ym9hcmRdJyApLnJlbW92ZURhdGEoICdbZGF0YS1kdHIta2V5Ym9hcmRdJyApO1xuXG5cdFx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJyApIHtcblx0XHRcdGR0LmNlbGxzKCBudWxsLCB0YXJnZXQsIHsgcGFnZTogJ2N1cnJlbnQnIH0gKS5ub2RlcygpLnRvJCgpXG5cdFx0XHRcdC5hdHRyKCAndGFiSW5kZXgnLCBjdHguaVRhYkluZGV4IClcblx0XHRcdFx0LmRhdGEoICdkdHIta2V5Ym9hcmQnLCAxICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2sgLSB3ZSBuZWVkIHRvIGxpbWl0IHRoZSBzZWxlY3RlZCBub2RlcyB0byBqdXN0XG5cdFx0XHQvLyB0aG9zZSBvZiB0aGlzIHRhYmxlXG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gJ3RkOmZpcnN0LWNoaWxkLCB0aDpmaXJzdC1jaGlsZCcgKSB7XG5cdFx0XHRcdHRhcmdldCA9ICc+dGQ6Zmlyc3QtY2hpbGQsID50aDpmaXJzdC1jaGlsZCc7XG5cdFx0XHR9XG5cblx0XHRcdCQoIHRhcmdldCwgZHQucm93cyggeyBwYWdlOiAnY3VycmVudCcgfSApLm5vZGVzKCkgKVxuXHRcdFx0XHQuYXR0ciggJ3RhYkluZGV4JywgY3R4LmlUYWJJbmRleCApXG5cdFx0XHRcdC5kYXRhKCAnZHRyLWtleWJvYXJkJywgMSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8qKlxuICogTGlzdCBvZiBkZWZhdWx0IGJyZWFrcG9pbnRzLiBFYWNoIGl0ZW0gaW4gdGhlIGFycmF5IGlzIGFuIG9iamVjdCB3aXRoIHR3b1xuICogcHJvcGVydGllczpcbiAqXG4gKiAqIGBuYW1lYCAtIHRoZSBicmVha3BvaW50IG5hbWUuXG4gKiAqIGB3aWR0aGAgLSB0aGUgYnJlYWtwb2ludCB3aWR0aFxuICpcbiAqIEBuYW1lIFJlc3BvbnNpdmUuYnJlYWtwb2ludHNcbiAqIEBzdGF0aWNcbiAqL1xuUmVzcG9uc2l2ZS5icmVha3BvaW50cyA9IFtcblx0eyBuYW1lOiAnZGVza3RvcCcsICB3aWR0aDogSW5maW5pdHkgfSxcblx0eyBuYW1lOiAndGFibGV0LWwnLCB3aWR0aDogMTAyNCB9LFxuXHR7IG5hbWU6ICd0YWJsZXQtcCcsIHdpZHRoOiA3NjggfSxcblx0eyBuYW1lOiAnbW9iaWxlLWwnLCB3aWR0aDogNDgwIH0sXG5cdHsgbmFtZTogJ21vYmlsZS1wJywgd2lkdGg6IDMyMCB9XG5dO1xuXG5cbi8qKlxuICogRGlzcGxheSBtZXRob2RzIC0gZnVuY3Rpb25zIHdoaWNoIGRlZmluZSBob3cgdGhlIGhpZGRlbiBkYXRhIHNob3VsZCBiZSBzaG93blxuICogaW4gdGhlIHRhYmxlLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBuYW1lIFJlc3BvbnNpdmUuZGVmYXVsdHNcbiAqIEBzdGF0aWNcbiAqL1xuUmVzcG9uc2l2ZS5kaXNwbGF5ID0ge1xuXHRjaGlsZFJvdzogZnVuY3Rpb24gKCByb3csIHVwZGF0ZSwgcmVuZGVyICkge1xuXHRcdGlmICggdXBkYXRlICkge1xuXHRcdFx0aWYgKCAkKHJvdy5ub2RlKCkpLmhhc0NsYXNzKCdwYXJlbnQnKSApIHtcblx0XHRcdFx0cm93LmNoaWxkKCByZW5kZXIoKSwgJ2NoaWxkJyApLnNob3coKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAoICEgcm93LmNoaWxkLmlzU2hvd24oKSAgKSB7XG5cdFx0XHRcdHJvdy5jaGlsZCggcmVuZGVyKCksICdjaGlsZCcgKS5zaG93KCk7XG5cdFx0XHRcdCQoIHJvdy5ub2RlKCkgKS5hZGRDbGFzcyggJ3BhcmVudCcgKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyb3cuY2hpbGQoIGZhbHNlICk7XG5cdFx0XHRcdCQoIHJvdy5ub2RlKCkgKS5yZW1vdmVDbGFzcyggJ3BhcmVudCcgKTtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGNoaWxkUm93SW1tZWRpYXRlOiBmdW5jdGlvbiAoIHJvdywgdXBkYXRlLCByZW5kZXIgKSB7XG5cdFx0aWYgKCAoISB1cGRhdGUgJiYgcm93LmNoaWxkLmlzU2hvd24oKSkgfHwgISByb3cucmVzcG9uc2l2ZS5oYXNIaWRkZW4oKSApIHtcblx0XHRcdC8vIFVzZXIgaW50ZXJhY3Rpb24gYW5kIHRoZSByb3cgaXMgc2hvdywgb3Igbm90aGluZyB0byBzaG93XG5cdFx0XHRyb3cuY2hpbGQoIGZhbHNlICk7XG5cdFx0XHQkKCByb3cubm9kZSgpICkucmVtb3ZlQ2xhc3MoICdwYXJlbnQnICk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBEaXNwbGF5XG5cdFx0XHRyb3cuY2hpbGQoIHJlbmRlcigpLCAnY2hpbGQnICkuc2hvdygpO1xuXHRcdFx0JCggcm93Lm5vZGUoKSApLmFkZENsYXNzKCAncGFyZW50JyApO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gVGhpcyBpcyBhIHdyYXBwZXIgc28gdGhlIG1vZGFsIG9wdGlvbnMgZm9yIEJvb3RzdHJhcCBhbmQgalF1ZXJ5IFVJIGNhblxuXHQvLyBoYXZlIG9wdGlvbnMgcGFzc2VkIGludG8gdGhlbS4gVGhpcyBzcGVjaWZpYyBvbmUgZG9lc24ndCBuZWVkIHRvIGJlIGFcblx0Ly8gZnVuY3Rpb24gYnV0IGl0IGlzIGZvciBjb25zaXN0ZW5jeSBpbiB0aGUgYG1vZGFsYCBuYW1lXG5cdG1vZGFsOiBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcm93LCB1cGRhdGUsIHJlbmRlciApIHtcblx0XHRcdGlmICggISB1cGRhdGUgKSB7XG5cdFx0XHRcdC8vIFNob3cgYSBtb2RhbFxuXHRcdFx0XHR2YXIgY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bW9kYWwucmVtb3ZlKCk7IC8vIHdpbGwgdGlkeSBldmVudHMgZm9yIHVzXG5cdFx0XHRcdFx0JChkb2N1bWVudCkub2ZmKCAna2V5cHJlc3MuZHRyJyApO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHZhciBtb2RhbCA9ICQoJzxkaXYgY2xhc3M9XCJkdHItbW9kYWxcIi8+Jylcblx0XHRcdFx0XHQuYXBwZW5kKCAkKCc8ZGl2IGNsYXNzPVwiZHRyLW1vZGFsLWRpc3BsYXlcIi8+Jylcblx0XHRcdFx0XHRcdC5hcHBlbmQoICQoJzxkaXYgY2xhc3M9XCJkdHItbW9kYWwtY29udGVudFwiLz4nKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kKCByZW5kZXIoKSApXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYXBwZW5kKCAkKCc8ZGl2IGNsYXNzPVwiZHRyLW1vZGFsLWNsb3NlXCI+JnRpbWVzOzwvZGl2PicgKVxuXHRcdFx0XHRcdFx0XHQuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9zZSgpO1xuXHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmFwcGVuZCggJCgnPGRpdiBjbGFzcz1cImR0ci1tb2RhbC1iYWNrZ3JvdW5kXCIvPicpXG5cdFx0XHRcdFx0XHQuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0Y2xvc2UoKTtcblx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuYXBwZW5kVG8oICdib2R5JyApO1xuXG5cdFx0XHRcdCQoZG9jdW1lbnQpLm9uKCAna2V5dXAuZHRyJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRpZiAoIGUua2V5Q29kZSA9PT0gMjcgKSB7XG5cdFx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHRcdFx0XHRjbG9zZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdCQoJ2Rpdi5kdHItbW9kYWwtY29udGVudCcpXG5cdFx0XHRcdFx0LmVtcHR5KClcblx0XHRcdFx0XHQuYXBwZW5kKCByZW5kZXIoKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5oZWFkZXIgKSB7XG5cdFx0XHRcdCQoJ2Rpdi5kdHItbW9kYWwtY29udGVudCcpLnByZXBlbmQoXG5cdFx0XHRcdFx0JzxoMj4nK29wdGlvbnMuaGVhZGVyKCByb3cgKSsnPC9oMj4nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufTtcblxuXG52YXIgX2NoaWxkTm9kZVN0b3JlID0ge307XG5cbmZ1bmN0aW9uIF9jaGlsZE5vZGVzKCBkdCwgcm93LCBjb2wgKSB7XG5cdHZhciBuYW1lID0gcm93KyctJytjb2w7XG5cblx0aWYgKCBfY2hpbGROb2RlU3RvcmVbIG5hbWUgXSApIHtcblx0XHRyZXR1cm4gX2NoaWxkTm9kZVN0b3JlWyBuYW1lIF07XG5cdH1cblxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vY2hpbGRub2Rlcy1hcnJheS1zbGljZS12cy1sb29wXG5cdHZhciBub2RlcyA9IFtdO1xuXHR2YXIgY2hpbGRyZW4gPSBkdC5jZWxsKCByb3csIGNvbCApLm5vZGUoKS5jaGlsZE5vZGVzO1xuXHRmb3IgKCB2YXIgaT0wLCBpZW49Y2hpbGRyZW4ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0bm9kZXMucHVzaCggY2hpbGRyZW5baV0gKTtcblx0fVxuXG5cdF9jaGlsZE5vZGVTdG9yZVsgbmFtZSBdID0gbm9kZXM7XG5cblx0cmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBfY2hpbGROb2Rlc1Jlc3RvcmUoIGR0LCByb3csIGNvbCApIHtcblx0dmFyIG5hbWUgPSByb3crJy0nK2NvbDtcblxuXHRpZiAoICEgX2NoaWxkTm9kZVN0b3JlWyBuYW1lIF0gKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIG5vZGUgPSBkdC5jZWxsKCByb3csIGNvbCApLm5vZGUoKTtcblx0dmFyIHN0b3JlID0gX2NoaWxkTm9kZVN0b3JlWyBuYW1lIF07XG5cdHZhciBwYXJlbnQgPSBzdG9yZVswXS5wYXJlbnROb2RlO1xuXHR2YXIgcGFyZW50Q2hpbGRyZW4gPSBwYXJlbnQuY2hpbGROb2Rlcztcblx0dmFyIGEgPSBbXTtcblxuXHRmb3IgKCB2YXIgaT0wLCBpZW49cGFyZW50Q2hpbGRyZW4ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0YS5wdXNoKCBwYXJlbnRDaGlsZHJlbltpXSApO1xuXHR9XG5cblx0Zm9yICggdmFyIGo9MCwgamVuPWEubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0bm9kZS5hcHBlbmRDaGlsZCggYVtqXSApO1xuXHR9XG5cblx0X2NoaWxkTm9kZVN0b3JlWyBuYW1lIF0gPSB1bmRlZmluZWQ7XG59XG5cblxuLyoqXG4gKiBEaXNwbGF5IG1ldGhvZHMgLSBmdW5jdGlvbnMgd2hpY2ggZGVmaW5lIGhvdyB0aGUgaGlkZGVuIGRhdGEgc2hvdWxkIGJlIHNob3duXG4gKiBpbiB0aGUgdGFibGUuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQG5hbWUgUmVzcG9uc2l2ZS5kZWZhdWx0c1xuICogQHN0YXRpY1xuICovXG5SZXNwb25zaXZlLnJlbmRlcmVyID0ge1xuXHRsaXN0SGlkZGVuTm9kZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhcGksIHJvd0lkeCwgY29sdW1ucyApIHtcblx0XHRcdHZhciB1bCA9ICQoJzx1bCBkYXRhLWR0ci1pbmRleD1cIicrcm93SWR4KydcIiBjbGFzcz1cImR0ci1kZXRhaWxzXCIvPicpO1xuXHRcdFx0dmFyIGZvdW5kID0gZmFsc2U7XG5cblx0XHRcdHZhciBkYXRhID0gJC5lYWNoKCBjb2x1bW5zLCBmdW5jdGlvbiAoIGksIGNvbCApIHtcblx0XHRcdFx0aWYgKCBjb2wuaGlkZGVuICkge1xuXHRcdFx0XHRcdHZhciBrbGFzcyA9IGNvbC5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdFx0J2NsYXNzPVwiJysgY29sLmNsYXNzTmFtZSArJ1wiJyA6XG5cdFx0XHRcdFx0XHQnJztcblx0XG5cdFx0XHRcdFx0JChcblx0XHRcdFx0XHRcdCc8bGkgJytrbGFzcysnIGRhdGEtZHRyLWluZGV4PVwiJytjb2wuY29sdW1uSW5kZXgrJ1wiIGRhdGEtZHQtcm93PVwiJytjb2wucm93SW5kZXgrJ1wiIGRhdGEtZHQtY29sdW1uPVwiJytjb2wuY29sdW1uSW5kZXgrJ1wiPicrXG5cdFx0XHRcdFx0XHRcdCc8c3BhbiBjbGFzcz1cImR0ci10aXRsZVwiPicrXG5cdFx0XHRcdFx0XHRcdFx0Y29sLnRpdGxlK1xuXHRcdFx0XHRcdFx0XHQnPC9zcGFuPiAnK1xuXHRcdFx0XHRcdFx0JzwvbGk+J1xuXHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hcHBlbmQoICQoJzxzcGFuIGNsYXNzPVwiZHRyLWRhdGFcIi8+JykuYXBwZW5kKCBfY2hpbGROb2RlcyggYXBpLCBjb2wucm93SW5kZXgsIGNvbC5jb2x1bW5JbmRleCApICkgKS8vIGFwaS5jZWxsKCBjb2wucm93SW5kZXgsIGNvbC5jb2x1bW5JbmRleCApLm5vZGUoKS5jaGlsZE5vZGVzICkgKVxuXHRcdFx0XHRcdFx0LmFwcGVuZFRvKCB1bCApO1xuXG5cdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiBmb3VuZCA/XG5cdFx0XHRcdHVsIDpcblx0XHRcdFx0ZmFsc2U7XG5cdFx0fTtcblx0fSxcblxuXHRsaXN0SGlkZGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXBpLCByb3dJZHgsIGNvbHVtbnMgKSB7XG5cdFx0XHR2YXIgZGF0YSA9ICQubWFwKCBjb2x1bW5zLCBmdW5jdGlvbiAoIGNvbCApIHtcblx0XHRcdFx0dmFyIGtsYXNzID0gY29sLmNsYXNzTmFtZSA/XG5cdFx0XHRcdFx0J2NsYXNzPVwiJysgY29sLmNsYXNzTmFtZSArJ1wiJyA6XG5cdFx0XHRcdFx0Jyc7XG5cblx0XHRcdFx0cmV0dXJuIGNvbC5oaWRkZW4gP1xuXHRcdFx0XHRcdCc8bGkgJytrbGFzcysnIGRhdGEtZHRyLWluZGV4PVwiJytjb2wuY29sdW1uSW5kZXgrJ1wiIGRhdGEtZHQtcm93PVwiJytjb2wucm93SW5kZXgrJ1wiIGRhdGEtZHQtY29sdW1uPVwiJytjb2wuY29sdW1uSW5kZXgrJ1wiPicrXG5cdFx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJkdHItdGl0bGVcIj4nK1xuXHRcdFx0XHRcdFx0XHRjb2wudGl0bGUrXG5cdFx0XHRcdFx0XHQnPC9zcGFuPiAnK1xuXHRcdFx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiZHRyLWRhdGFcIj4nK1xuXHRcdFx0XHRcdFx0XHRjb2wuZGF0YStcblx0XHRcdFx0XHRcdCc8L3NwYW4+Jytcblx0XHRcdFx0XHQnPC9saT4nIDpcblx0XHRcdFx0XHQnJztcblx0XHRcdH0gKS5qb2luKCcnKTtcblxuXHRcdFx0cmV0dXJuIGRhdGEgP1xuXHRcdFx0XHQkKCc8dWwgZGF0YS1kdHItaW5kZXg9XCInK3Jvd0lkeCsnXCIgY2xhc3M9XCJkdHItZGV0YWlsc1wiLz4nKS5hcHBlbmQoIGRhdGEgKSA6XG5cdFx0XHRcdGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHR0YWJsZUFsbDogZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCgge1xuXHRcdFx0dGFibGVDbGFzczogJydcblx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhcGksIHJvd0lkeCwgY29sdW1ucyApIHtcblx0XHRcdHZhciBkYXRhID0gJC5tYXAoIGNvbHVtbnMsIGZ1bmN0aW9uICggY29sICkge1xuXHRcdFx0XHR2YXIga2xhc3MgPSBjb2wuY2xhc3NOYW1lID9cblx0XHRcdFx0XHQnY2xhc3M9XCInKyBjb2wuY2xhc3NOYW1lICsnXCInIDpcblx0XHRcdFx0XHQnJztcblxuXHRcdFx0XHRyZXR1cm4gJzx0ciAnK2tsYXNzKycgZGF0YS1kdC1yb3c9XCInK2NvbC5yb3dJbmRleCsnXCIgZGF0YS1kdC1jb2x1bW49XCInK2NvbC5jb2x1bW5JbmRleCsnXCI+Jytcblx0XHRcdFx0XHRcdCc8dGQ+Jytjb2wudGl0bGUrJzonKyc8L3RkPiAnK1xuXHRcdFx0XHRcdFx0Jzx0ZD4nK2NvbC5kYXRhKyc8L3RkPicrXG5cdFx0XHRcdFx0JzwvdHI+Jztcblx0XHRcdH0gKS5qb2luKCcnKTtcblxuXHRcdFx0cmV0dXJuICQoJzx0YWJsZSBjbGFzcz1cIicrb3B0aW9ucy50YWJsZUNsYXNzKycgZHRyLWRldGFpbHNcIiB3aWR0aD1cIjEwMCVcIi8+JykuYXBwZW5kKCBkYXRhICk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIFJlc3BvbnNpdmUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgaW5pdGlhbGlzYXRpb25cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAbmFtZSBSZXNwb25zaXZlLmRlZmF1bHRzXG4gKiBAc3RhdGljXG4gKi9cblJlc3BvbnNpdmUuZGVmYXVsdHMgPSB7XG5cdC8qKlxuXHQgKiBMaXN0IG9mIGJyZWFrcG9pbnRzIGZvciB0aGUgaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGlzIG1lYW5zIHRoYXQgZWFjaFxuXHQgKiBpbnN0YW5jZSBjYW4gaGF2ZSBpdHMgb3duIGJyZWFrcG9pbnRzLiBBZGRpdGlvbmFsbHksIHRoZSBicmVha3BvaW50c1xuXHQgKiBjYW5ub3QgYmUgY2hhbmdlZCBvbmNlIGFuIGluc3RhbmNlIGhhcyBiZWVuIGNyZWFzZWQuXG5cdCAqXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQGRlZmF1bHQgVGFrZXMgdGhlIHZhbHVlIG9mIGBSZXNwb25zaXZlLmJyZWFrcG9pbnRzYFxuXHQgKi9cblx0YnJlYWtwb2ludHM6IFJlc3BvbnNpdmUuYnJlYWtwb2ludHMsXG5cblx0LyoqXG5cdCAqIEVuYWJsZSAvIGRpc2FibGUgYXV0byBoaWRpbmcgY2FsY3VsYXRpb25zLiBJdCBjYW4gaGVscCB0byBpbmNyZWFzZVxuXHQgKiBwZXJmb3JtYW5jZSBzbGlnaHRseSBpZiB5b3UgZGlzYWJsZSB0aGlzIG9wdGlvbiwgYnV0IGFsbCBjb2x1bW5zIHdvdWxkXG5cdCAqIG5lZWQgdG8gaGF2ZSBicmVha3BvaW50IGNsYXNzZXMgYXNzaWduZWQgdG8gdGhlbVxuXHQgKlxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgIGB0cnVlYFxuXHQgKi9cblx0YXV0bzogdHJ1ZSxcblxuXHQvKipcblx0ICogRGV0YWlscyBjb250cm9sLiBJZiBnaXZlbiBhcyBhIHN0cmluZyB2YWx1ZSwgdGhlIGB0eXBlYCBwcm9wZXJ0eSBvZiB0aGVcblx0ICogZGVmYXVsdCBvYmplY3QgaXMgc2V0IHRvIHRoYXQgdmFsdWUsIGFuZCB0aGUgZGVmYXVsdHMgdXNlZCBmb3IgdGhlIHJlc3Rcblx0ICogb2YgdGhlIG9iamVjdCAtIHRoaXMgaXMgZm9yIGVhc2Ugb2YgaW1wbGVtZW50YXRpb24uXG5cdCAqXG5cdCAqIFRoZSBvYmplY3QgY29uc2lzdHMgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHQgKlxuXHQgKiAqIGBkaXNwbGF5YCAtIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHNob3cgYW5kIGhpZGUgdGhlIGhpZGRlbiBkZXRhaWxzXG5cdCAqICogYHJlbmRlcmVyYCAtIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvciBkaXNwbGF5IG9mIHRoZSBjaGlsZCByb3cgZGF0YS5cblx0ICogICBUaGUgZGVmYXVsdCBmdW5jdGlvbiB3aWxsIHNob3cgdGhlIGRhdGEgZnJvbSB0aGUgaGlkZGVuIGNvbHVtbnNcblx0ICogKiBgdGFyZ2V0YCAtIFVzZWQgYXMgdGhlIHNlbGVjdG9yIGZvciB3aGF0IG9iamVjdHMgdG8gYXR0YWNoIHRoZSBjaGlsZFxuXHQgKiAgIG9wZW4gLyBjbG9zZSB0b1xuXHQgKiAqIGB0eXBlYCAtIGBmYWxzZWAgdG8gZGlzYWJsZSB0aGUgZGV0YWlscyBkaXNwbGF5LCBgaW5saW5lYCBvciBgY29sdW1uYFxuXHQgKiAgIGZvciB0aGUgdHdvIGNvbnRyb2wgdHlwZXNcblx0ICpcblx0ICogQHR5cGUge09iamVjdHxzdHJpbmd9XG5cdCAqL1xuXHRkZXRhaWxzOiB7XG5cdFx0ZGlzcGxheTogUmVzcG9uc2l2ZS5kaXNwbGF5LmNoaWxkUm93LFxuXG5cdFx0cmVuZGVyZXI6IFJlc3BvbnNpdmUucmVuZGVyZXIubGlzdEhpZGRlbigpLFxuXG5cdFx0dGFyZ2V0OiAwLFxuXG5cdFx0dHlwZTogJ2lubGluZSdcblx0fSxcblxuXHQvKipcblx0ICogT3J0aG9nb25hbCBkYXRhIHJlcXVlc3Qgb3B0aW9uLiBUaGlzIGlzIHVzZWQgdG8gZGVmaW5lIHRoZSBkYXRhIHR5cGVcblx0ICogcmVxdWVzdGVkIHdoZW4gUmVzcG9uc2l2ZSBnZXRzIHRoZSBkYXRhIHRvIHNob3cgaW4gdGhlIGNoaWxkIHJvdy5cblx0ICpcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICovXG5cdG9ydGhvZ29uYWw6ICdkaXNwbGF5J1xufTtcblxuXG4vKlxuICogQVBJXG4gKi9cbnZhciBBcGkgPSAkLmZuLmRhdGFUYWJsZS5BcGk7XG5cbi8vIERvZXNuJ3QgZG8gYW55dGhpbmcgLSB3b3JrIGFyb3VuZCBmb3IgYSBidWcgaW4gRFQuLi4gTm90IGRvY3VtZW50ZWRcbkFwaS5yZWdpc3RlciggJ3Jlc3BvbnNpdmUoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cbkFwaS5yZWdpc3RlciggJ3Jlc3BvbnNpdmUuaW5kZXgoKScsIGZ1bmN0aW9uICggbGkgKSB7XG5cdGxpID0gJChsaSk7XG5cblx0cmV0dXJuIHtcblx0XHRjb2x1bW46IGxpLmRhdGEoJ2R0ci1pbmRleCcpLFxuXHRcdHJvdzogICAgbGkucGFyZW50KCkuZGF0YSgnZHRyLWluZGV4Jylcblx0fTtcbn0gKTtcblxuQXBpLnJlZ2lzdGVyKCAncmVzcG9uc2l2ZS5yZWJ1aWxkKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRpZiAoIGN0eC5fcmVzcG9uc2l2ZSApIHtcblx0XHRcdGN0eC5fcmVzcG9uc2l2ZS5fY2xhc3NMb2dpYygpO1xuXHRcdH1cblx0fSApO1xufSApO1xuXG5BcGkucmVnaXN0ZXIoICdyZXNwb25zaXZlLnJlY2FsYygpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0aWYgKCBjdHguX3Jlc3BvbnNpdmUgKSB7XG5cdFx0XHRjdHguX3Jlc3BvbnNpdmUuX3Jlc2l6ZUF1dG8oKTtcblx0XHRcdGN0eC5fcmVzcG9uc2l2ZS5fcmVzaXplKCk7XG5cdFx0fVxuXHR9ICk7XG59ICk7XG5cbkFwaS5yZWdpc3RlciggJ3Jlc3BvbnNpdmUuaGFzSGlkZGVuKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cblx0cmV0dXJuIGN0eC5fcmVzcG9uc2l2ZSA/XG5cdFx0JC5pbkFycmF5KCBmYWxzZSwgY3R4Ll9yZXNwb25zaXZlLl9yZXNwb25zaXZlT25seUhpZGRlbigpICkgIT09IC0xIDpcblx0XHRmYWxzZTtcbn0gKTtcblxuQXBpLnJlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnJlc3BvbnNpdmVIaWRkZW4oKScsICdjb2x1bW4oKS5yZXNwb25zaXZlSGlkZGVuKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5fcmVzcG9uc2l2ZSA/XG5cdFx0XHRzZXR0aW5ncy5fcmVzcG9uc2l2ZS5fcmVzcG9uc2l2ZU9ubHlIaWRkZW4oKVsgY29sdW1uIF0gOlxuXHRcdFx0ZmFsc2U7XG5cdH0sIDEgKTtcbn0gKTtcblxuXG4vKipcbiAqIFZlcnNpb24gaW5mb3JtYXRpb25cbiAqXG4gKiBAbmFtZSBSZXNwb25zaXZlLnZlcnNpb25cbiAqIEBzdGF0aWNcbiAqL1xuUmVzcG9uc2l2ZS52ZXJzaW9uID0gJzIuMi45JztcblxuXG4kLmZuLmRhdGFUYWJsZS5SZXNwb25zaXZlID0gUmVzcG9uc2l2ZTtcbiQuZm4uRGF0YVRhYmxlLlJlc3BvbnNpdmUgPSBSZXNwb25zaXZlO1xuXG4vLyBBdHRhY2ggYSBsaXN0ZW5lciB0byB0aGUgZG9jdW1lbnQgd2hpY2ggbGlzdGVucyBmb3IgRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvblxuLy8gZXZlbnRzIHNvIHdlIGNhbiBhdXRvbWF0aWNhbGx5IGluaXRpYWxpc2VcbiQoZG9jdW1lbnQpLm9uKCAncHJlSW5pdC5kdC5kdHInLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGpzb24pIHtcblx0aWYgKCBlLm5hbWVzcGFjZSAhPT0gJ2R0JyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoICQoc2V0dGluZ3MublRhYmxlKS5oYXNDbGFzcyggJ3Jlc3BvbnNpdmUnICkgfHxcblx0XHQgJChzZXR0aW5ncy5uVGFibGUpLmhhc0NsYXNzKCAnZHQtcmVzcG9uc2l2ZScgKSB8fFxuXHRcdCBzZXR0aW5ncy5vSW5pdC5yZXNwb25zaXZlIHx8XG5cdFx0IERhdGFUYWJsZS5kZWZhdWx0cy5yZXNwb25zaXZlXG5cdCkge1xuXHRcdHZhciBpbml0ID0gc2V0dGluZ3Mub0luaXQucmVzcG9uc2l2ZTtcblxuXHRcdGlmICggaW5pdCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRuZXcgUmVzcG9uc2l2ZSggc2V0dGluZ3MsICQuaXNQbGFpbk9iamVjdCggaW5pdCApID8gaW5pdCA6IHt9ICApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbnJldHVybiBSZXNwb25zaXZlO1xufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-responsive/js/dataTables.responsive.js\n");

/***/ }),

/***/ "datatables.net":
/*!*********************************!*\
  !*** external "$.fn.dataTable" ***!
  \*********************************/
/***/ (function(module) {

"use strict";
module.exports = window["$.fn.dataTable"];

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ (function(module) {

"use strict";
module.exports = window["jQuery"];

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/datatables-responsive/datatables.responsive.js");
/******/ 	var __webpack_export_target__ = window;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;