/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/shepherd/shepherd.js":
/*!***********************************!*\
  !*** ./libs/shepherd/shepherd.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shepherd\": function() { return /* reexport default from dynamic */ shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shepherd.js/dist/js/shepherd */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL3NoZXBoZXJkL3NoZXBoZXJkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlc3QvLi9saWJzL3NoZXBoZXJkL3NoZXBoZXJkLmpzPzdhODMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFNoZXBoZXJkIGZyb20gJ3NoZXBoZXJkLmpzL2Rpc3QvanMvc2hlcGhlcmQnO1xyXG5cclxuZXhwb3J0IHsgU2hlcGhlcmQgfTtcclxuIl0sIm5hbWVzIjpbIlNoZXBoZXJkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/shepherd/shepherd.js\n");

/***/ }),

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*! shepherd.js 10.0.1 */\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  var isMergeableObject = function isMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n  };\n\n  function isNonNullObject(value) {\n    return !!value && _typeof(value) === 'object';\n  }\n\n  function isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);\n  } // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\n\n  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\n  function isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE;\n  }\n\n  function emptyTarget(val) {\n    return Array.isArray(val) ? [] : {};\n  }\n\n  function cloneUnlessOtherwiseSpecified(value, options) {\n    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n  }\n\n  function defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n      return cloneUnlessOtherwiseSpecified(element, options);\n    });\n  }\n\n  function getMergeFunction(key, options) {\n    if (!options.customMerge) {\n      return deepmerge;\n    }\n\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepmerge;\n  }\n\n  function getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n      return target.propertyIsEnumerable(symbol);\n    }) : [];\n  }\n\n  function getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n  }\n\n  function propertyIsOnObject(object, property) {\n    try {\n      return property in object;\n    } catch (_) {\n      return false;\n    }\n  } // Protects from prototype poisoning and unexpected merging up the prototype chain.\n\n\n  function propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n  }\n\n  function mergeObject(target, source, options) {\n    var destination = {};\n\n    if (options.isMergeableObject(target)) {\n      getKeys(target).forEach(function (key) {\n        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n      });\n    }\n\n    getKeys(source).forEach(function (key) {\n      if (propertyIsUnsafe(target, key)) {\n        return;\n      }\n\n      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n      } else {\n        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n      }\n    });\n    return destination;\n  }\n\n  function deepmerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || isMergeableObject; // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n    if (!sourceAndTargetTypesMatch) {\n      return cloneUnlessOtherwiseSpecified(source, options);\n    } else if (sourceIsArray) {\n      return options.arrayMerge(target, source, options);\n    } else {\n      return mergeObject(target, source, options);\n    }\n  }\n\n  deepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n      throw new Error('first argument should be an array');\n    }\n\n    return array.reduce(function (prev, next) {\n      return deepmerge(prev, next, options);\n    }, {});\n  };\n\n  var deepmerge_1 = deepmerge;\n  var cjs = deepmerge_1;\n  /**\n   * Checks if `value` is classified as an `Element`.\n   * @param {*} value The param to check if it is an Element\n   */\n\n  function isElement$1(value) {\n    return value instanceof Element;\n  }\n  /**\n   * Checks if `value` is classified as an `HTMLElement`.\n   * @param {*} value The param to check if it is an HTMLElement\n   */\n\n\n  function isHTMLElement$1(value) {\n    return value instanceof HTMLElement;\n  }\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  var Evented = /*#__PURE__*/function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n\n    _createClass(Evented, [{\n      key: \"on\",\n      value: function on(event, handler, ctx, once) {\n        if (once === void 0) {\n          once = false;\n        }\n\n        if (isUndefined(this.bindings)) {\n          this.bindings = {};\n        }\n\n        if (isUndefined(this.bindings[event])) {\n          this.bindings[event] = [];\n        }\n\n        this.bindings[event].push({\n          handler: handler,\n          ctx: ctx,\n          once: once\n        });\n        return this;\n      }\n    }, {\n      key: \"once\",\n      value: function once(event, handler, ctx) {\n        return this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: \"off\",\n      value: function off(event, handler) {\n        var _this = this;\n\n        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n          return this;\n        }\n\n        if (isUndefined(handler)) {\n          delete this.bindings[event];\n        } else {\n          this.bindings[event].forEach(function (binding, index) {\n            if (binding.handler === handler) {\n              _this.bindings[event].splice(index, 1);\n            }\n          });\n        }\n\n        return this;\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event) {\n        var _this2 = this;\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        if (!isUndefined(this.bindings) && this.bindings[event]) {\n          this.bindings[event].forEach(function (binding, index) {\n            var ctx = binding.ctx,\n                handler = binding.handler,\n                once = binding.once;\n            var context = ctx || _this2;\n            handler.apply(context, args);\n\n            if (once) {\n              _this2.bindings[event].splice(index, 1);\n            }\n          });\n        }\n\n        return this;\n      }\n    }]);\n\n    return Evented;\n  }();\n  /**\n   * Binds all the methods on a JS Class to the `this` context of the class.\n   * Adapted from https://github.com/sindresorhus/auto-bind\n   * @param {object} self The `this` context of the class\n   * @return {object} The `this` context of the class\n   */\n\n\n  function autoBind(self) {\n    var keys = Object.getOwnPropertyNames(self.constructor.prototype);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = self[key];\n\n      if (key !== 'constructor' && typeof val === 'function') {\n        self[key] = val.bind(self);\n      }\n    }\n\n    return self;\n  }\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @param {string} selector\n   * @param {Step} step The step instance\n   * @return {Function}\n   * @private\n   */\n\n\n  function _setupAdvanceOnHandler(selector, step) {\n    return function (event) {\n      if (step.isOpen()) {\n        var targetIsEl = step.el && event.currentTarget === step.el;\n        var targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);\n\n        if (targetIsSelector || targetIsEl) {\n          step.tour.next();\n        }\n      }\n    };\n  }\n  /**\n   * Bind the event handler for advanceOn\n   * @param {Step} step The step instance\n   */\n\n\n  function bindAdvance(step) {\n    // An empty selector matches the step element\n    var _ref6 = step.options.advanceOn || {},\n        event = _ref6.event,\n        selector = _ref6.selector;\n\n    if (event) {\n      var handler = _setupAdvanceOnHandler(selector, step); // TODO: this should also bind/unbind on show/hide\n\n\n      var el;\n\n      try {\n        el = document.querySelector(selector);\n      } catch (e) {// TODO\n      }\n\n      if (!isUndefined(selector) && !el) {\n        return console.error(\"No element was found for the selector supplied to advanceOn: \".concat(selector));\n      } else if (el) {\n        el.addEventListener(event, handler);\n        step.on('destroy', function () {\n          return el.removeEventListener(event, handler);\n        });\n      } else {\n        document.body.addEventListener(event, handler, true);\n        step.on('destroy', function () {\n          return document.body.removeEventListener(event, handler, true);\n        });\n      }\n    } else {\n      return console.error('advanceOn was defined, but no event name was passed.');\n    }\n  }\n\n  var top = 'top';\n  var bottom = 'bottom';\n  var right = 'right';\n  var left = 'left';\n  var auto = 'auto';\n  var basePlacements = [top, bottom, right, left];\n  var start = 'start';\n  var end = 'end';\n  var clippingParents = 'clippingParents';\n  var viewport = 'viewport';\n  var popper = 'popper';\n  var reference = 'reference';\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []); // modifiers that need to read the DOM\n\n  var beforeRead = 'beforeRead';\n  var read = 'read';\n  var afterRead = 'afterRead'; // pure-logic modifiers\n\n  var beforeMain = 'beforeMain';\n  var main = 'main';\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\n  var beforeWrite = 'beforeWrite';\n  var write = 'write';\n  var afterWrite = 'afterWrite';\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\n  function getNodeName(element) {\n    return element ? (element.nodeName || '').toLowerCase() : null;\n  }\n\n  function getWindow(node) {\n    if (node == null) {\n      return window;\n    }\n\n    if (node.toString() !== '[object Window]') {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n\n    return node;\n  }\n\n  function isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n\n  function isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n\n  function isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  } // and applies them to the HTMLElements such as popper and arrow\n\n\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function (name) {\n      var style = state.styles[name] || {};\n      var attributes = state.attributes[name] || {};\n      var element = state.elements[name]; // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe[cannot-write]\n\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (name) {\n        var value = attributes[name];\n\n        if (value === false) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      });\n    });\n  }\n\n  function effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n\n    return function () {\n      Object.keys(state.elements).forEach(function (name) {\n        var element = state.elements[name];\n        var attributes = state.attributes[name] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n        var style = styleProperties.reduce(function (style, property) {\n          style[property] = '';\n          return style;\n        }, {}); // arrow is optional + virtual elements\n\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        }\n\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function (attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var applyStyles$1 = {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect: effect$2,\n    requires: ['computeStyles']\n  };\n\n  function getBasePlacement(placement) {\n    return placement.split('-')[0];\n  }\n\n  var max = Math.max;\n  var min = Math.min;\n  var round = Math.round;\n\n  function getBoundingClientRect(element, includeScale) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n\n    var rect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n\n    if (isHTMLElement(element) && includeScale) {\n      var offsetHeight = element.offsetHeight;\n      var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale\n      // Fallback to 1 in case both values are `0`\n\n      if (offsetWidth > 0) {\n        scaleX = round(rect.width) / offsetWidth || 1;\n      }\n\n      if (offsetHeight > 0) {\n        scaleY = round(rect.height) / offsetHeight || 1;\n      }\n    }\n\n    return {\n      width: rect.width / scaleX,\n      height: rect.height / scaleY,\n      top: rect.top / scaleY,\n      right: rect.right / scaleX,\n      bottom: rect.bottom / scaleY,\n      left: rect.left / scaleX,\n      x: rect.left / scaleX,\n      y: rect.top / scaleY\n    };\n  } // means it doesn't take into account transforms.\n\n\n  function getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n\n    if (Math.abs(clientRect.width - width) <= 1) {\n      width = clientRect.width;\n    }\n\n    if (Math.abs(clientRect.height - height) <= 1) {\n      height = clientRect.height;\n    }\n\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: width,\n      height: height\n    };\n  }\n\n  function contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n    if (parent.contains(child)) {\n      return true;\n    } // then fallback to custom implementation with Shadow DOM support\n    else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n    return false;\n  }\n\n  function getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n  }\n\n  function getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n    element.document) || window.document).documentElement;\n  }\n\n  function getParentNode(element) {\n    if (getNodeName(element) === 'html') {\n      return element;\n    }\n\n    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      // $FlowFixMe[incompatible-return]\n      // $FlowFixMe[prop-missing]\n      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || ( // DOM Element detected\n      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n      getDocumentElement(element) // fallback\n\n    );\n  }\n\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === 'fixed') {\n      return null;\n    }\n\n    return element.offsetParent;\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n  // return the containing block\n\n\n  function getContainingBlock(element) {\n    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;\n    var isIE = navigator.userAgent.indexOf('Trident') !== -1;\n\n    if (isIE && isHTMLElement(element)) {\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n      var elementCss = getComputedStyle(element);\n\n      if (elementCss.position === 'fixed') {\n        return null;\n      }\n    }\n\n    var currentNode = getParentNode(element);\n\n    if (isShadowRoot(currentNode)) {\n      currentNode = currentNode.host;\n    }\n\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n      // create a containing block.\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n        return currentNode;\n      } else {\n        currentNode = currentNode.parentNode;\n      }\n    }\n\n    return null;\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n\n\n  function getOffsetParent(element) {\n    var window = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n      return window;\n    }\n\n    return offsetParent || getContainingBlock(element) || window;\n  }\n\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n  }\n\n  function within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n  }\n\n  function withinMaxClamp(min, value, max) {\n    var v = within(min, value, max);\n    return v > max ? max : v;\n  }\n\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n  }\n\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function (hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n\n  var toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  };\n\n  function arrow(_ref) {\n    var _state$modifiersData$;\n\n    var state = _ref.state,\n        name = _ref.name,\n        options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? 'height' : 'width';\n\n    if (!arrowElement || !popperOffsets) {\n      return;\n    }\n\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === 'y' ? top : left;\n    var maxProp = axis === 'y' ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n  }\n\n  function effect$1(_ref2) {\n    var state = _ref2.state,\n        options = _ref2.options;\n    var _options$element = options.element,\n        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n    if (arrowElement == null) {\n      return;\n    } // CSS selector\n\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n\n      if (!arrowElement) {\n        return;\n      }\n    }\n\n    if (!contains(state.elements.popper, arrowElement)) {\n      return;\n    }\n\n    state.elements.arrow = arrowElement;\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var arrow$1 = {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect: effect$1,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n  };\n\n  function getVariation(placement) {\n    return placement.split('-')[1];\n  }\n\n  var unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n\n  function roundOffsetsByDPR(_ref) {\n    var x = _ref.x,\n        y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: round(x * dpr) / dpr || 0,\n      y: round(y * dpr) / dpr || 0\n    };\n  }\n\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n\n    var popper = _ref2.popper,\n        popperRect = _ref2.popperRect,\n        placement = _ref2.placement,\n        variation = _ref2.variation,\n        offsets = _ref2.offsets,\n        position = _ref2.position,\n        gpuAcceleration = _ref2.gpuAcceleration,\n        adaptive = _ref2.adaptive,\n        roundOffsets = _ref2.roundOffsets,\n        isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x,\n        x = _offsets$x === void 0 ? 0 : _offsets$x,\n        _offsets$y = offsets.y,\n        y = _offsets$y === void 0 ? 0 : _offsets$y;\n\n    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty('x');\n    var hasY = offsets.hasOwnProperty('y');\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper);\n      var heightProp = 'clientHeight';\n      var widthProp = 'clientWidth';\n\n      if (offsetParent === getWindow(popper)) {\n        offsetParent = getDocumentElement(popper);\n\n        if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n          heightProp = 'scrollHeight';\n          widthProp = 'scrollWidth';\n        }\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n      offsetParent = offsetParent;\n\n      if (placement === top || (placement === left || placement === right) && variation === end) {\n        sideY = bottom;\n        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n        offsetParent[heightProp];\n        y -= offsetY - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n\n      if (placement === left || (placement === top || placement === bottom) && variation === end) {\n        sideX = right;\n        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n        offsetParent[widthProp];\n        x -= offsetX - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n\n    var commonStyles = Object.assign({\n      position: position\n    }, adaptive && unsetSides);\n\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n\n    x = _ref4.x;\n    y = _ref4.y;\n\n    if (gpuAcceleration) {\n      var _Object$assign;\n\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n  }\n\n  function computeStyles(_ref5) {\n    var state = _ref5.state,\n        options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration,\n        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n        _options$adaptive = options.adaptive,\n        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n        _options$roundOffsets = options.roundOffsets,\n        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      variation: getVariation(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration: gpuAcceleration,\n      isFixed: state.options.strategy === 'fixed'\n    };\n\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive: adaptive,\n        roundOffsets: roundOffsets\n      })));\n    }\n\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n        roundOffsets: roundOffsets\n      })));\n    }\n\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-placement': state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var computeStyles$1 = {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n  };\n  var passive = {\n    passive: true\n  };\n\n  function effect(_ref) {\n    var state = _ref.state,\n        instance = _ref.instance,\n        options = _ref.options;\n    var _options$scroll = options.scroll,\n        scroll = _options$scroll === void 0 ? true : _options$scroll,\n        _options$resize = options.resize,\n        resize = _options$resize === void 0 ? true : _options$resize;\n    var window = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.addEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.addEventListener('resize', instance.update, passive);\n    }\n\n    return function () {\n      if (scroll) {\n        scrollParents.forEach(function (scrollParent) {\n          scrollParent.removeEventListener('scroll', instance.update, passive);\n        });\n      }\n\n      if (resize) {\n        window.removeEventListener('resize', instance.update, passive);\n      }\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var eventListeners = {\n    name: 'eventListeners',\n    enabled: true,\n    phase: 'write',\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n  };\n  var hash$1 = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash$1[matched];\n    });\n  }\n\n  var hash = {\n    start: 'end',\n    end: 'start'\n  };\n\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function (matched) {\n      return hash[matched];\n    });\n  }\n\n  function getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  }\n\n  function getViewportRect(element) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n    // can be obscured underneath it.\n    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n    // if it isn't open, so if this isn't available, the popper will be detected\n    // to overflow the bottom of the screen too early.\n\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n      // errors due to floating point numbers, so we need to check precision.\n      // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n      // Feature detection fails in mobile emulation mode in Chrome.\n      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n      // 0.001\n      // Fallback here: \"Not Safari\" userAgent\n\n      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n\n    return {\n      width: width,\n      height: height,\n      x: x + getWindowScrollBarX(element),\n      y: y\n    };\n  } // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n\n  function getDocumentRect(element) {\n    var _element$ownerDocumen;\n\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n\n    if (getComputedStyle(body || html).direction === 'rtl') {\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n\n  function isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle(element),\n        overflow = _getComputedStyle.overflow,\n        overflowX = _getComputedStyle.overflowX,\n        overflowY = _getComputedStyle.overflowY;\n\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n  }\n\n  function getScrollParent(node) {\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n      // $FlowFixMe[incompatible-return]: assume body is always available\n      return node.ownerDocument.body;\n    }\n\n    if (isHTMLElement(node) && isScrollParent(node)) {\n      return node;\n    }\n\n    return getScrollParent(getParentNode(node));\n  }\n  /*\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\n  until we get to the top window object. This list is what we attach scroll listeners\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\n  reference element's position.\n  */\n\n\n  function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n\n    if (list === void 0) {\n      list = [];\n    }\n\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)));\n  }\n\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n\n  function getInnerBoundingClientRect(element) {\n    var rect = getBoundingClientRect(element);\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n  }\n\n  function getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\n  // clipping (or hiding) overflowing elements with a position different from\n  // `initial`\n\n\n  function getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n    if (!isElement(clipperElement)) {\n      return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n    return clippingParents.filter(function (clippingParent) {\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n    });\n  } // Gets the maximum area that the element is visible in due to any number of\n  // clipping parents\n\n\n  function getClippingRect(element, boundary, rootBoundary) {\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n\n  function computeOffsets(_ref) {\n    var reference = _ref.reference,\n        element = _ref.element,\n        placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference.y - element.height\n        };\n        break;\n\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n\n      case right:\n        offsets = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n\n      case left:\n        offsets = {\n          x: reference.x - element.width,\n          y: commonY\n        };\n        break;\n\n      default:\n        offsets = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n    if (mainAxis != null) {\n      var len = mainAxis === 'y' ? 'height' : 'width';\n\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n          break;\n\n        case end:\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n          break;\n      }\n    }\n\n    return offsets;\n  }\n\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        _options$placement = _options.placement,\n        placement = _options$placement === void 0 ? state.placement : _options$placement,\n        _options$boundary = _options.boundary,\n        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n        _options$rootBoundary = _options.rootBoundary,\n        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n        _options$elementConte = _options.elementContext,\n        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n        _options$altBoundary = _options.altBoundary,\n        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n        _options$padding = _options.padding,\n        padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: 'absolute',\n      placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n    if (elementContext === popper && offsetData) {\n      var offset = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function (key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n        overflowOffsets[key] += offset[axis] * multiply;\n      });\n    }\n\n    return overflowOffsets;\n  }\n\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        placement = _options.placement,\n        boundary = _options.boundary,\n        rootBoundary = _options.rootBoundary,\n        padding = _options.padding,\n        flipVariations = _options.flipVariations,\n        _options$allowedAutoP = _options.allowedAutoPlacements,\n        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n      return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function (placement) {\n      return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n\n    if (allowedPlacements.length === 0) {\n      allowedPlacements = placements$1;\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\n      acc[placement] = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding\n      })[getBasePlacement(placement)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function (a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n\n  function flip(_ref) {\n    var state = _ref.state,\n        options = _ref.options,\n        name = _ref.name;\n\n    if (state.modifiersData[name]._skip) {\n      return;\n    }\n\n    var _options$mainAxis = options.mainAxis,\n        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n        _options$altAxis = options.altAxis,\n        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n        specifiedFallbackPlacements = options.fallbackPlacements,\n        padding = options.padding,\n        boundary = options.boundary,\n        rootBoundary = options.rootBoundary,\n        altBoundary = options.altBoundary,\n        _options$flipVariatio = options.flipVariations,\n        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n        allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        flipVariations: flipVariations,\n        allowedAutoPlacements: allowedAutoPlacements\n      }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n\n    for (var i = 0; i < placements.length; i++) {\n      var placement = placements[i];\n\n      var _basePlacement = getBasePlacement(placement);\n\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? 'width' : 'height';\n      var overflow = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        altBoundary: altBoundary,\n        padding: padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [];\n\n      if (checkMainAxis) {\n        checks.push(overflow[_basePlacement] <= 0);\n      }\n\n      if (checkAltAxis) {\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n      }\n\n      if (checks.every(function (check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n\n      checksMap.set(placement, checks);\n    }\n\n    if (makeFallbackChecks) {\n      // `2` may be desired in some cases  research later\n      var numberOfChecks = flipVariations ? 3 : 1;\n\n      var _loop = function _loop(_i) {\n        var fittingPlacement = placements.find(function (placement) {\n          var checks = checksMap.get(placement);\n\n          if (checks) {\n            return checks.slice(0, _i).every(function (check) {\n              return check;\n            });\n          }\n        });\n\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n\n        if (_ret === \"break\") break;\n      }\n    }\n\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var flip$1 = {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: {\n      _skip: false\n    }\n  };\n\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function (side) {\n      return overflow[side] >= 0;\n    });\n  }\n\n  function hide(_ref) {\n    var state = _ref.state,\n        name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: 'reference'\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n      referenceClippingOffsets: referenceClippingOffsets,\n      popperEscapeOffsets: popperEscapeOffsets,\n      isReferenceHidden: isReferenceHidden,\n      hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-reference-hidden': isReferenceHidden,\n      'data-popper-escaped': hasPopperEscaped\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var hide$1 = {\n    name: 'hide',\n    enabled: true,\n    phase: 'main',\n    requiresIfExists: ['preventOverflow'],\n    fn: hide\n  };\n\n  function distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n      placement: placement\n    })) : offset,\n        skidding = _ref[0],\n        distance = _ref[1];\n\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n\n  function offset(_ref2) {\n    var state = _ref2.state,\n        options = _ref2.options,\n        name = _ref2.name;\n    var _options$offset = options.offset,\n        offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function (acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement],\n        x = _data$state$placement.x,\n        y = _data$state$placement.y;\n\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var offset$1 = {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n  };\n\n  function popperOffsets(_ref) {\n    var state = _ref.state,\n        name = _ref.name; // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n\n    state.modifiersData[name] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: 'absolute',\n      placement: state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var popperOffsets$1 = {\n    name: 'popperOffsets',\n    enabled: true,\n    phase: 'read',\n    fn: popperOffsets,\n    data: {}\n  };\n\n  function getAltAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n\n  function preventOverflow(_ref) {\n    var state = _ref.state,\n        options = _ref.options,\n        name = _ref.name;\n    var _options$mainAxis = options.mainAxis,\n        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n        _options$altAxis = options.altAxis,\n        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n        boundary = options.boundary,\n        rootBoundary = options.rootBoundary,\n        altBoundary = options.altBoundary,\n        padding = options.padding,\n        _options$tether = options.tether,\n        tether = _options$tether === void 0 ? true : _options$tether,\n        _options$tetherOffset = options.tetherOffset,\n        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n      mainAxis: tetherOffsetValue,\n      altAxis: tetherOffsetValue\n    } : Object.assign({\n      mainAxis: 0,\n      altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n      x: 0,\n      y: 0\n    };\n\n    if (!popperOffsets) {\n      return;\n    }\n\n    if (checkMainAxis) {\n      var _offsetModifierState$;\n\n      var mainSide = mainAxis === 'y' ? top : left;\n      var altSide = mainAxis === 'y' ? bottom : right;\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      var offset = popperOffsets[mainAxis];\n      var min$1 = offset + overflow[mainSide];\n      var max$1 = offset - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n      // outside the reference bounds\n\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n      // to include its full size in the calculation. If the reference is small\n      // and near the edge of a boundary, the popper can overflow even if the\n      // reference is not overflowing as well (e.g. virtual elements with no\n      // width or height)\n\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = offset + maxOffset - offsetModifierValue;\n      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n      popperOffsets[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset;\n    }\n\n    if (checkAltAxis) {\n      var _offsetModifierState$2;\n\n      var _mainSide = mainAxis === 'x' ? top : left;\n\n      var _altSide = mainAxis === 'x' ? bottom : right;\n\n      var _offset = popperOffsets[altAxis];\n\n      var _len = altAxis === 'y' ? 'height' : 'width';\n\n      var _min = _offset + overflow[_mainSide];\n\n      var _max = _offset - overflow[_altSide];\n\n      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n\n      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n      popperOffsets[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n\n  var preventOverflow$1 = {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n  };\n\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  function getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  }\n\n  function isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n  } // Returns the composite rect of an element relative to its offsetParent.\n  // Composite means it takes into account transforms as well as layout.\n\n\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n      isScrollParent(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent, true);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n\n  function order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function (modifier) {\n      map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function (dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n\n    modifiers.forEach(function (modifier) {\n      if (!visited.has(modifier.name)) {\n        // check for visited object\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n\n  function orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n\n    return modifierPhases.reduce(function (acc, phase) {\n      return acc.concat(orderedModifiers.filter(function (modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n\n  function debounce(fn) {\n    var pending;\n    return function () {\n      if (!pending) {\n        pending = new Promise(function (resolve) {\n          Promise.resolve().then(function () {\n            pending = undefined;\n            resolve(fn());\n          });\n        });\n      }\n\n      return pending;\n    };\n  }\n\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function (merged, current) {\n      var existing = merged[current.name];\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\n        options: Object.assign({}, existing.options, current.options),\n        data: Object.assign({}, existing.data, current.data)\n      }) : current;\n      return merged;\n    }, {}); // IE11 does not support Object.values\n\n    return Object.keys(merged).map(function (key) {\n      return merged[key];\n    });\n  }\n\n  var DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n  };\n\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return !args.some(function (element) {\n      return !(element && typeof element.getBoundingClientRect === 'function');\n    });\n  }\n\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n\n    var _generatorOptions = generatorOptions,\n        _generatorOptions$def = _generatorOptions.defaultModifiers,\n        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n        _generatorOptions$def2 = _generatorOptions.defaultOptions,\n        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n      if (options === void 0) {\n        options = defaultOptions;\n      }\n\n      var state = {\n        placement: 'bottom',\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n        modifiersData: {},\n        elements: {\n          reference: reference,\n          popper: popper\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state: state,\n        setOptions: function setOptions(setOptionsAction) {\n          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions, state.options, options);\n          state.scrollParents = {\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n            popper: listScrollParents(popper)\n          }; // Orders the modifiers based on their dependencies and `phase`\n          // properties\n\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\n            return m.enabled;\n          }); // Validate the provided modifiers so that the consumer will get warned\n\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update  it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n\n          var _state$elements = state.elements,\n              reference = _state$elements.reference,\n              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n          // anymore\n\n          if (!areValidElements(reference, popper)) {\n            return;\n          } // Store the reference and popper rects to be read by modifiers\n\n\n          state.rects = {\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n            popper: getLayoutRect(popper)\n          }; // Modifiers have the ability to reset the current update cycle. The\n          // most common use case for this is the `flip` modifier changing the\n          // placement, which then needs to re-run all the modifiers, because the\n          // logic was previously ran for the previous placement and is therefore\n          // stale/incorrect\n\n          state.reset = false;\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n          // is filled with the initial data specified by the modifier. This means\n          // it doesn't persist and is fresh on each update.\n          // To ensure persistent data, use `${name}#persistent`\n\n          state.orderedModifiers.forEach(function (modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n\n            var _state$orderedModifie = state.orderedModifiers[index],\n                fn = _state$orderedModifie.fn,\n                _state$orderedModifie2 = _state$orderedModifie.options,\n                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n                name = _state$orderedModifie.name;\n\n            if (typeof fn === 'function') {\n              state = fn({\n                state: state,\n                options: _options,\n                name: name,\n                instance: instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update  it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function () {\n          return new Promise(function (resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n\n      if (!areValidElements(reference, popper)) {\n        return instance;\n      }\n\n      instance.setOptions(options).then(function (state) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state);\n        }\n      }); // Modifiers have the ability to execute arbitrary code before the first\n      // update cycle runs. They will be executed in the same order as the update\n      // cycle. This is useful when a modifier adds some persistent data that\n      // other modifiers need to use, but the modifier is run after the dependent\n      // one.\n\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function (_ref3) {\n          var name = _ref3.name,\n              _ref3$options = _ref3.options,\n              options = _ref3$options === void 0 ? {} : _ref3$options,\n              effect = _ref3.effect;\n\n          if (typeof effect === 'function') {\n            var cleanupFn = effect({\n              state: state,\n              name: name,\n              instance: instance,\n              options: options\n            });\n\n            var noopFn = function noopFn() {};\n\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function (fn) {\n          return fn();\n        });\n        effectCleanupFns = [];\n      }\n\n      return instance;\n    };\n  }\n\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\n  var createPopper = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n\n  function _getCenteredStylePopperModifier() {\n    return [{\n      name: 'applyStyles',\n      fn: function fn(_ref) {\n        var state = _ref.state;\n        Object.keys(state.elements).forEach(function (name) {\n          if (name !== 'popper') {\n            return;\n          }\n\n          var style = {\n            position: 'fixed',\n            left: '50%',\n            top: '50%',\n            transform: 'translate(-50%, -50%)'\n          };\n          var attributes = state.attributes[name] || {};\n          var element = state.elements[name];\n          Object.assign(element.style, style);\n          Object.keys(attributes).forEach(function (name) {\n            var value = attributes[name];\n\n            if (value === false) {\n              element.removeAttribute(name);\n            } else {\n              element.setAttribute(name, value === true ? '' : value);\n            }\n          });\n        });\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: false\n      }\n    }];\n  }\n  /**\n   * Generates a modifier for popper that will help focus the element after it has\n   * been rendered\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The focus after render modifier configuration object\n   */\n\n\n  function generateFocusAfterRenderModifier(step) {\n    return {\n      name: 'focusAfterRender',\n      enabled: true,\n      phase: 'afterWrite',\n      fn: function fn() {\n        setTimeout(function () {\n          if (step.el) {\n            var focusOptions = {\n              preventScroll: true\n            };\n            step.el.focus(focusOptions);\n          }\n        }, 300);\n      }\n    };\n  }\n  /**\n   * Generates the array of options for a tooltip that doesn't have a\n   * target element in the DOM -- and thus is positioned in the center\n   * of the view\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The final Popper options object\n   */\n\n\n  function makeCenteredPopper(step) {\n    var centeredStylePopperModifier = _getCenteredStylePopperModifier();\n\n    var popperOptions = {\n      placement: 'top',\n      strategy: 'fixed',\n      modifiers: [generateFocusAfterRenderModifier(step)]\n    };\n    popperOptions = _extends({}, popperOptions, {\n      modifiers: Array.from(new Set([].concat(_toConsumableArray(popperOptions.modifiers), _toConsumableArray(centeredStylePopperModifier))))\n    });\n    return popperOptions;\n  }\n  /**\n   * Ensure class prefix ends in `-`\n   * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n   * @return {string} The prefix ending in `-`\n   */\n\n\n  function normalizePrefix(prefix) {\n    if (!isString(prefix) || prefix === '') {\n      return '';\n    }\n\n    return prefix.charAt(prefix.length - 1) !== '-' ? \"\".concat(prefix, \"-\") : prefix;\n  }\n  /**\n   * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n   * @param {Step} step The step instance\n   * @returns {{}|{element, on}}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n\n\n  function parseAttachTo(step) {\n    var options = step.options.attachTo || {};\n    var returnOpts = Object.assign({}, options);\n\n    if (isFunction(returnOpts.element)) {\n      // Bind the callback to step so that it has access to the object, to enable running additional logic\n      returnOpts.element = returnOpts.element.call(step);\n    }\n\n    if (isString(returnOpts.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(returnOpts.element);\n      } catch (e) {// TODO\n      }\n\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \".concat(options.element));\n      }\n    }\n\n    return returnOpts;\n  }\n  /**\n   * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n   * alternative for the deprecated step.isCentered() method.\n   * @param resolvedAttachToOptions\n   * @returns {boolean}\n   */\n\n\n  function shouldCenterStep(resolvedAttachToOptions) {\n    if (resolvedAttachToOptions === undefined || resolvedAttachToOptions === null) {\n      return true;\n    }\n\n    return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n  }\n  /**\n   * Determines options for the tooltip and initializes\n   * `step.tooltip` as a Popper instance.\n   * @param {Step} step The step instance\n   */\n\n\n  function setupTooltip(step) {\n    if (step.tooltip) {\n      step.tooltip.destroy();\n    }\n\n    var attachToOptions = step._getResolvedAttachToOptions();\n\n    var target = attachToOptions.element;\n    var popperOptions = getPopperOptions(attachToOptions, step);\n\n    if (shouldCenterStep(attachToOptions)) {\n      target = document.body;\n      var content = step.shepherdElementComponent.getElement();\n      content.classList.add('shepherd-centered');\n    }\n\n    step.tooltip = createPopper(target, step.el, popperOptions);\n    step.target = attachToOptions.element;\n    return popperOptions;\n  }\n  /**\n   * Create a unique id for steps, tours, modals, etc\n   * @return {string}\n   */\n\n\n  function uuid() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n  }\n  /**\n   * Gets the `Popper` options from a set of base `attachTo` options\n   * @param attachToOptions\n   * @param {Step} step The step instance\n   * @return {Object}\n   * @private\n   */\n\n\n  function getPopperOptions(attachToOptions, step) {\n    var popperOptions = {\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          altAxis: true,\n          tether: false\n        }\n      }, generateFocusAfterRenderModifier(step)],\n      strategy: 'absolute'\n    };\n\n    if (shouldCenterStep(attachToOptions)) {\n      popperOptions = makeCenteredPopper(step);\n    } else {\n      popperOptions.placement = attachToOptions.on;\n    }\n\n    var defaultStepOptions = step.tour && step.tour.options && step.tour.options.defaultStepOptions;\n\n    if (defaultStepOptions) {\n      popperOptions = _mergeModifiers(defaultStepOptions, popperOptions);\n    }\n\n    popperOptions = _mergeModifiers(step.options, popperOptions);\n    return popperOptions;\n  }\n\n  function _mergeModifiers(stepOptions, popperOptions) {\n    if (stepOptions.popperOptions) {\n      var mergedPopperOptions = Object.assign({}, popperOptions, stepOptions.popperOptions);\n\n      if (stepOptions.popperOptions.modifiers && stepOptions.popperOptions.modifiers.length > 0) {\n        var names = stepOptions.popperOptions.modifiers.map(function (mod) {\n          return mod.name;\n        });\n        var filteredModifiers = popperOptions.modifiers.filter(function (mod) {\n          return !names.includes(mod.name);\n        });\n        mergedPopperOptions.modifiers = Array.from(new Set([].concat(_toConsumableArray(filteredModifiers), _toConsumableArray(stepOptions.popperOptions.modifiers))));\n      }\n\n      return mergedPopperOptions;\n    }\n\n    return popperOptions;\n  }\n\n  function noop() {}\n\n  function assign(tar, src) {\n    // @ts-ignore\n    for (var k in src) {\n      tar[k] = src[k];\n    }\n\n    return tar;\n  }\n\n  function run(fn) {\n    return fn();\n  }\n\n  function blank_object() {\n    return Object.create(null);\n  }\n\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n\n  function is_function(thing) {\n    return typeof thing === 'function';\n  }\n\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n  }\n\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n\n  function append(target, node) {\n    target.appendChild(node);\n  }\n\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n\n  function detach(node) {\n    node.parentNode.removeChild(node);\n  }\n\n  function destroy_each(iterations, detaching) {\n    for (var i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n\n  function element(name) {\n    return document.createElement(name);\n  }\n\n  function svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n\n  function text(data) {\n    return document.createTextNode(data);\n  }\n\n  function space() {\n    return text(' ');\n  }\n\n  function empty() {\n    return text('');\n  }\n\n  function listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return function () {\n      return node.removeEventListener(event, handler, options);\n    };\n  }\n\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n\n  function set_attributes(node, attributes) {\n    // @ts-ignore\n    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\n    for (var key in attributes) {\n      if (attributes[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === 'style') {\n        node.style.cssText = attributes[key];\n      } else if (key === '__value') {\n        node.value = node[key] = attributes[key];\n      } else if (descriptors[key] && descriptors[key].set) {\n        node[key] = attributes[key];\n      } else {\n        attr(node, key, attributes[key]);\n      }\n    }\n  }\n\n  function children(element) {\n    return Array.from(element.childNodes);\n  }\n\n  function toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n  }\n\n  var current_component;\n\n  function set_current_component(component) {\n    current_component = component;\n  }\n\n  function get_current_component() {\n    if (!current_component) throw new Error('Function called outside component initialization');\n    return current_component;\n  }\n\n  function onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n  }\n\n  function afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n  }\n\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = Promise.resolve();\n  var update_scheduled = false;\n\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  } // 1. All beforeUpdate callbacks, in order: parents before children\n  // 2. All bind:this callbacks, in reverse order: children before parents.\n  // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n  //    for afterUpdates called during the initial onMount, which are called in\n  //    reverse order: children before parents.\n  // Since callbacks might update component values, which could trigger another\n  // call to flush(), the following steps guard against this:\n  // 1. During beforeUpdate, any updated components will be added to the\n  //    dirty_components array and will cause a reentrant call to flush(). Because\n  //    the flush index is kept outside the function, the reentrant call will pick\n  //    up where the earlier call left off and go through all dirty components. The\n  //    current_component value is saved and restored so that the reentrant call will\n  //    not interfere with the \"parent\" flush() call.\n  // 2. bind:this callbacks cannot trigger new flush() calls.\n  // 3. During afterUpdate, any updated components will NOT have their afterUpdate\n  //    callback called a second time; the seen_callbacks set, outside the flush()\n  //    function, guarantees this behavior.\n\n\n  var seen_callbacks = new Set();\n  var flushidx = 0; // Do *not* move this inside the flush() function\n\n  function flush() {\n    var saved_component = current_component;\n\n    do {\n      // first, call beforeUpdate functions\n      // and update components\n      while (flushidx < dirty_components.length) {\n        var component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n\n      set_current_component(null);\n      dirty_components.length = 0;\n      flushidx = 0;\n\n      while (binding_callbacks.length) {\n        binding_callbacks.pop()();\n      } // then, once components are updated, call\n      // afterUpdate functions. This may cause\n      // subsequent updates...\n\n\n      for (var i = 0; i < render_callbacks.length; i += 1) {\n        var callback = render_callbacks[i];\n\n        if (!seen_callbacks.has(callback)) {\n          // ...so guard against infinite loops\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n  }\n\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      var dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n\n  var outroing = new Set();\n  var outros;\n\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros // parent group\n\n    };\n  }\n\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n\n    outros = outros.p;\n  }\n\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n\n  function transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n      if (outroing.has(block)) return;\n      outroing.add(block);\n      outros.c.push(function () {\n        outroing.delete(block);\n\n        if (callback) {\n          if (detach) block.d(1);\n          callback();\n        }\n      });\n      block.o(local);\n    } else if (callback) {\n      callback();\n    }\n  }\n\n  function get_spread_update(levels, updates) {\n    var update = {};\n    var to_null_out = {};\n    var accounted_for = {\n      $$scope: 1\n    };\n    var i = levels.length;\n\n    while (i--) {\n      var o = levels[i];\n      var n = updates[i];\n\n      if (n) {\n        for (var key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n\n        for (var _key2 in n) {\n          if (!accounted_for[_key2]) {\n            update[_key2] = n[_key2];\n            accounted_for[_key2] = 1;\n          }\n        }\n\n        levels[i] = n;\n      } else {\n        for (var _key3 in o) {\n          accounted_for[_key3] = 1;\n        }\n      }\n    }\n\n    for (var _key4 in to_null_out) {\n      if (!(_key4 in update)) update[_key4] = undefined;\n    }\n\n    return update;\n  }\n\n  function create_component(block) {\n    block && block.c();\n  }\n\n  function mount_component(component, target, anchor, customElement) {\n    var _component$$$ = component.$$,\n        fragment = _component$$$.fragment,\n        on_mount = _component$$$.on_mount,\n        on_destroy = _component$$$.on_destroy,\n        after_update = _component$$$.after_update;\n    fragment && fragment.m(target, anchor);\n\n    if (!customElement) {\n      // onMount happens before the initial afterUpdate\n      add_render_callback(function () {\n        var new_on_destroy = on_mount.map(run).filter(is_function);\n\n        if (on_destroy) {\n          on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));\n        } else {\n          // Edge case - component was destroyed immediately,\n          // most likely as a result of a binding initialising\n          run_all(new_on_destroy);\n        }\n\n        component.$$.on_mount = [];\n      });\n    }\n\n    after_update.forEach(add_render_callback);\n  }\n\n  function destroy_component(component, detaching) {\n    var $$ = component.$$;\n\n    if ($$.fragment !== null) {\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to\n      // preserve final state?)\n\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n\n  function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty) {\n    if (dirty === void 0) {\n      dirty = [-1];\n    }\n\n    var parent_component = current_component;\n    set_current_component(component);\n    var $$ = component.$$ = {\n      fragment: null,\n      ctx: null,\n      // state\n      props: props,\n      update: noop,\n      not_equal: not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n      // everything else\n      callbacks: blank_object(),\n      dirty: dirty,\n      skip_bound: false,\n      root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    var ready = false;\n    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update); // `false` as a special case of no DOM component\n\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\n    if (options.target) {\n      if (options.hydrate) {\n        var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.c();\n      }\n\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor, options.customElement);\n      flush();\n    }\n\n    set_current_component(parent_component);\n  }\n  /**\n   * Base class for Svelte components. Used when dev=false.\n   */\n\n\n  var SvelteComponent = /*#__PURE__*/function () {\n    function SvelteComponent() {\n      _classCallCheck(this, SvelteComponent);\n    }\n\n    _createClass(SvelteComponent, [{\n      key: \"$destroy\",\n      value: function $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n      }\n    }, {\n      key: \"$on\",\n      value: function $on(type, callback) {\n        var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n        callbacks.push(callback);\n        return function () {\n          var index = callbacks.indexOf(callback);\n          if (index !== -1) callbacks.splice(index, 1);\n        };\n      }\n    }, {\n      key: \"$set\",\n      value: function $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n          this.$$.skip_bound = true;\n          this.$$set($$props);\n          this.$$.skip_bound = false;\n        }\n      }\n    }]);\n\n    return SvelteComponent;\n  }();\n  /* src/js/components/shepherd-button.svelte generated by Svelte v3.49.0 */\n\n\n  function create_fragment$8(ctx) {\n    var button;\n    var button_aria_label_value;\n    var button_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        attr(button, \"aria-label\", button_aria_label_value =\n        /*label*/\n        ctx[3] ?\n        /*label*/\n        ctx[3] : null);\n        attr(button, \"class\", button_class_value = \"\".concat(\n        /*classes*/\n        ctx[1] || '', \" shepherd-button \").concat(\n        /*secondary*/\n        ctx[4] ? 'shepherd-button-secondary' : ''));\n        button.disabled =\n        /*disabled*/\n        ctx[2];\n        attr(button, \"tabindex\", \"0\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        button.innerHTML =\n        /*text*/\n        ctx[5];\n\n        if (!mounted) {\n          dispose = listen(button, \"click\", function () {\n            if (is_function(\n            /*action*/\n            ctx[0]))\n              /*action*/\n              ctx[0].apply(this, arguments);\n          });\n          mounted = true;\n        }\n      },\n      p: function p(new_ctx, _ref) {\n        var _ref7 = _slicedToArray(_ref, 1),\n            dirty = _ref7[0];\n\n        ctx = new_ctx;\n        if (dirty &\n        /*text*/\n        32) button.innerHTML =\n        /*text*/\n        ctx[5];\n\n        if (dirty &\n        /*label*/\n        8 && button_aria_label_value !== (button_aria_label_value =\n        /*label*/\n        ctx[3] ?\n        /*label*/\n        ctx[3] : null)) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n\n        if (dirty &\n        /*classes, secondary*/\n        18 && button_class_value !== (button_class_value = \"\".concat(\n        /*classes*/\n        ctx[1] || '', \" shepherd-button \").concat(\n        /*secondary*/\n        ctx[4] ? 'shepherd-button-secondary' : ''))) {\n          attr(button, \"class\", button_class_value);\n        }\n\n        if (dirty &\n        /*disabled*/\n        4) {\n          button.disabled =\n          /*disabled*/\n          ctx[2];\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  function instance$8($$self, $$props, $$invalidate) {\n    var config = $$props.config,\n        step = $$props.step;\n    var action, classes, disabled, label, secondary, text;\n\n    function getConfigOption(option) {\n      if (isFunction(option)) {\n        return option = option.call(step);\n      }\n\n      return option;\n    }\n\n    $$self.$$set = function ($$props) {\n      if ('config' in $$props) $$invalidate(6, config = $$props.config);\n      if ('step' in $$props) $$invalidate(7, step = $$props.step);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*config, step*/\n      192) {\n        {\n          $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);\n          $$invalidate(1, classes = config.classes);\n          $$invalidate(2, disabled = config.disabled ? getConfigOption(config.disabled) : false);\n          $$invalidate(3, label = config.label ? getConfigOption(config.label) : null);\n          $$invalidate(4, secondary = config.secondary);\n          $$invalidate(5, text = config.text ? getConfigOption(config.text) : null);\n        }\n      }\n    };\n\n    return [action, classes, disabled, label, secondary, text, config, step];\n  }\n\n  var Shepherd_button = /*#__PURE__*/function (_SvelteComponent) {\n    _inherits(Shepherd_button, _SvelteComponent);\n\n    var _super = _createSuper(Shepherd_button);\n\n    function Shepherd_button(options) {\n      var _this3;\n\n      _classCallCheck(this, Shepherd_button);\n\n      _this3 = _super.call(this);\n      init(_assertThisInitialized(_this3), options, instance$8, create_fragment$8, safe_not_equal, {\n        config: 6,\n        step: 7\n      });\n      return _this3;\n    }\n\n    return _createClass(Shepherd_button);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-footer.svelte generated by Svelte v3.49.0 */\n\n\n  function get_each_context(ctx, list, i) {\n    var child_ctx = ctx.slice();\n    child_ctx[2] = list[i];\n    return child_ctx;\n  } // (24:4) {#if buttons}\n\n\n  function create_if_block$3(ctx) {\n    var each_1_anchor;\n    var current;\n    var each_value =\n    /*buttons*/\n    ctx[1];\n    var each_blocks = [];\n\n    for (var i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n\n    var out = function out(i) {\n      return transition_out(each_blocks[i], 1, 1, function () {\n        each_blocks[i] = null;\n      });\n    };\n\n    return {\n      c: function c() {\n        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {\n          each_blocks[_i2].c();\n        }\n\n        each_1_anchor = empty();\n      },\n      m: function m(target, anchor) {\n        for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {\n          each_blocks[_i3].m(target, anchor);\n        }\n\n        insert(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        if (dirty &\n        /*buttons, step*/\n        3) {\n          each_value =\n          /*buttons*/\n          ctx[1];\n\n          var _i4;\n\n          for (_i4 = 0; _i4 < each_value.length; _i4 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i4);\n\n            if (each_blocks[_i4]) {\n              each_blocks[_i4].p(child_ctx, dirty);\n\n              transition_in(each_blocks[_i4], 1);\n            } else {\n              each_blocks[_i4] = create_each_block(child_ctx);\n\n              each_blocks[_i4].c();\n\n              transition_in(each_blocks[_i4], 1);\n\n              each_blocks[_i4].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n\n          group_outros();\n\n          for (_i4 = each_value.length; _i4 < each_blocks.length; _i4 += 1) {\n            out(_i4);\n          }\n\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n\n        for (var _i5 = 0; _i5 < each_value.length; _i5 += 1) {\n          transition_in(each_blocks[_i5]);\n        }\n\n        current = true;\n      },\n      o: function o(local) {\n        each_blocks = each_blocks.filter(Boolean);\n\n        for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {\n          transition_out(each_blocks[_i6]);\n        }\n\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_each(each_blocks, detaching);\n        if (detaching) detach(each_1_anchor);\n      }\n    };\n  } // (25:8) {#each buttons as config}\n\n\n  function create_each_block(ctx) {\n    var shepherdbutton;\n    var current;\n    shepherdbutton = new Shepherd_button({\n      props: {\n        config:\n        /*config*/\n        ctx[2],\n        step:\n        /*step*/\n        ctx[0]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdbutton.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdbutton, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdbutton_changes = {};\n        if (dirty &\n        /*buttons*/\n        2) shepherdbutton_changes.config =\n        /*config*/\n        ctx[2];\n        if (dirty &\n        /*step*/\n        1) shepherdbutton_changes.step =\n        /*step*/\n        ctx[0];\n        shepherdbutton.$set(shepherdbutton_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdbutton.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdbutton.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdbutton, detaching);\n      }\n    };\n  }\n\n  function create_fragment$7(ctx) {\n    var footer;\n    var current;\n    var if_block =\n    /*buttons*/\n    ctx[1] && create_if_block$3(ctx);\n    return {\n      c: function c() {\n        footer = element(\"footer\");\n        if (if_block) if_block.c();\n        attr(footer, \"class\", \"shepherd-footer\");\n      },\n      m: function m(target, anchor) {\n        insert(target, footer, anchor);\n        if (if_block) if_block.m(footer, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref8 = _slicedToArray(_ref, 1),\n            dirty = _ref8[0];\n\n        if (\n        /*buttons*/\n        ctx[1]) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n\n            if (dirty &\n            /*buttons*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block$3(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(footer, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, function () {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(footer);\n        if (if_block) if_block.d();\n      }\n    };\n  }\n\n  function instance$7($$self, $$props, $$invalidate) {\n    var buttons;\n    var step = $$props.step;\n\n    $$self.$$set = function ($$props) {\n      if ('step' in $$props) $$invalidate(0, step = $$props.step);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      1) {\n        $$invalidate(1, buttons = step.options.buttons);\n      }\n    };\n\n    return [step, buttons];\n  }\n\n  var Shepherd_footer = /*#__PURE__*/function (_SvelteComponent2) {\n    _inherits(Shepherd_footer, _SvelteComponent2);\n\n    var _super2 = _createSuper(Shepherd_footer);\n\n    function Shepherd_footer(options) {\n      var _this4;\n\n      _classCallCheck(this, Shepherd_footer);\n\n      _this4 = _super2.call(this);\n      init(_assertThisInitialized(_this4), options, instance$7, create_fragment$7, safe_not_equal, {\n        step: 0\n      });\n      return _this4;\n    }\n\n    return _createClass(Shepherd_footer);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-cancel-icon.svelte generated by Svelte v3.49.0 */\n\n\n  function create_fragment$6(ctx) {\n    var button;\n    var span;\n    var button_aria_label_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        span = element(\"span\");\n        span.textContent = \"\";\n        attr(span, \"aria-hidden\", \"true\");\n        attr(button, \"aria-label\", button_aria_label_value =\n        /*cancelIcon*/\n        ctx[0].label ?\n        /*cancelIcon*/\n        ctx[0].label : 'Close Tour');\n        attr(button, \"class\", \"shepherd-cancel-icon\");\n        attr(button, \"type\", \"button\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        append(button, span);\n\n        if (!mounted) {\n          dispose = listen(button, \"click\",\n          /*handleCancelClick*/\n          ctx[1]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref9 = _slicedToArray(_ref, 1),\n            dirty = _ref9[0];\n\n        if (dirty &\n        /*cancelIcon*/\n        1 && button_aria_label_value !== (button_aria_label_value =\n        /*cancelIcon*/\n        ctx[0].label ?\n        /*cancelIcon*/\n        ctx[0].label : 'Close Tour')) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  function instance$6($$self, $$props, $$invalidate) {\n    var cancelIcon = $$props.cancelIcon,\n        step = $$props.step;\n    /**\n    * Add a click listener to the cancel link that cancels the tour\n    */\n\n    var handleCancelClick = function handleCancelClick(e) {\n      e.preventDefault();\n      step.cancel();\n    };\n\n    $$self.$$set = function ($$props) {\n      if ('cancelIcon' in $$props) $$invalidate(0, cancelIcon = $$props.cancelIcon);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [cancelIcon, handleCancelClick, step];\n  }\n\n  var Shepherd_cancel_icon = /*#__PURE__*/function (_SvelteComponent3) {\n    _inherits(Shepherd_cancel_icon, _SvelteComponent3);\n\n    var _super3 = _createSuper(Shepherd_cancel_icon);\n\n    function Shepherd_cancel_icon(options) {\n      var _this5;\n\n      _classCallCheck(this, Shepherd_cancel_icon);\n\n      _this5 = _super3.call(this);\n      init(_assertThisInitialized(_this5), options, instance$6, create_fragment$6, safe_not_equal, {\n        cancelIcon: 0,\n        step: 2\n      });\n      return _this5;\n    }\n\n    return _createClass(Shepherd_cancel_icon);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-title.svelte generated by Svelte v3.49.0 */\n\n\n  function create_fragment$5(ctx) {\n    var h3;\n    return {\n      c: function c() {\n        h3 = element(\"h3\");\n        attr(h3, \"id\",\n        /*labelId*/\n        ctx[1]);\n        attr(h3, \"class\", \"shepherd-title\");\n      },\n      m: function m(target, anchor) {\n        insert(target, h3, anchor);\n        /*h3_binding*/\n\n        ctx[3](h3);\n      },\n      p: function p(ctx, _ref) {\n        var _ref10 = _slicedToArray(_ref, 1),\n            dirty = _ref10[0];\n\n        if (dirty &\n        /*labelId*/\n        2) {\n          attr(h3, \"id\",\n          /*labelId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(h3);\n        /*h3_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n\n  function instance$5($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n        element = $$props.element,\n        title = $$props.title;\n    afterUpdate(function () {\n      if (isFunction(title)) {\n        $$invalidate(2, title = title());\n      }\n\n      $$invalidate(0, element.innerHTML = title, element);\n    });\n\n    function h3_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('title' in $$props) $$invalidate(2, title = $$props.title);\n    };\n\n    return [element, labelId, title, h3_binding];\n  }\n\n  var Shepherd_title = /*#__PURE__*/function (_SvelteComponent4) {\n    _inherits(Shepherd_title, _SvelteComponent4);\n\n    var _super4 = _createSuper(Shepherd_title);\n\n    function Shepherd_title(options) {\n      var _this6;\n\n      _classCallCheck(this, Shepherd_title);\n\n      _this6 = _super4.call(this);\n      init(_assertThisInitialized(_this6), options, instance$5, create_fragment$5, safe_not_equal, {\n        labelId: 1,\n        element: 0,\n        title: 2\n      });\n      return _this6;\n    }\n\n    return _createClass(Shepherd_title);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-header.svelte generated by Svelte v3.49.0 */\n\n\n  function create_if_block_1$1(ctx) {\n    var shepherdtitle;\n    var current;\n    shepherdtitle = new Shepherd_title({\n      props: {\n        labelId:\n        /*labelId*/\n        ctx[0],\n        title:\n        /*title*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtitle.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtitle, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtitle_changes = {};\n        if (dirty &\n        /*labelId*/\n        1) shepherdtitle_changes.labelId =\n        /*labelId*/\n        ctx[0];\n        if (dirty &\n        /*title*/\n        4) shepherdtitle_changes.title =\n        /*title*/\n        ctx[2];\n        shepherdtitle.$set(shepherdtitle_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtitle.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtitle.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtitle, detaching);\n      }\n    };\n  } // (39:4) {#if cancelIcon && cancelIcon.enabled}\n\n\n  function create_if_block$2(ctx) {\n    var shepherdcancelicon;\n    var current;\n    shepherdcancelicon = new Shepherd_cancel_icon({\n      props: {\n        cancelIcon:\n        /*cancelIcon*/\n        ctx[3],\n        step:\n        /*step*/\n        ctx[1]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdcancelicon.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdcancelicon, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdcancelicon_changes = {};\n        if (dirty &\n        /*cancelIcon*/\n        8) shepherdcancelicon_changes.cancelIcon =\n        /*cancelIcon*/\n        ctx[3];\n        if (dirty &\n        /*step*/\n        2) shepherdcancelicon_changes.step =\n        /*step*/\n        ctx[1];\n        shepherdcancelicon.$set(shepherdcancelicon_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcancelicon.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcancelicon.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdcancelicon, detaching);\n      }\n    };\n  }\n\n  function create_fragment$4(ctx) {\n    var header;\n    var t;\n    var current;\n    var if_block0 =\n    /*title*/\n    ctx[2] && create_if_block_1$1(ctx);\n    var if_block1 =\n    /*cancelIcon*/\n    ctx[3] &&\n    /*cancelIcon*/\n    ctx[3].enabled && create_if_block$2(ctx);\n    return {\n      c: function c() {\n        header = element(\"header\");\n        if (if_block0) if_block0.c();\n        t = space();\n        if (if_block1) if_block1.c();\n        attr(header, \"class\", \"shepherd-header\");\n      },\n      m: function m(target, anchor) {\n        insert(target, header, anchor);\n        if (if_block0) if_block0.m(header, null);\n        append(header, t);\n        if (if_block1) if_block1.m(header, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref11 = _slicedToArray(_ref, 1),\n            dirty = _ref11[0];\n\n        if (\n        /*title*/\n        ctx[2]) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n\n            if (dirty &\n            /*title*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1$1(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, t);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n\n        if (\n        /*cancelIcon*/\n        ctx[3] &&\n        /*cancelIcon*/\n        ctx[3].enabled) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n\n            if (dirty &\n            /*cancelIcon*/\n            8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block$2(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(header, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(header);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n  }\n\n  function instance$4($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n        step = $$props.step;\n    var title, cancelIcon;\n\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(0, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(1, step = $$props.step);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      2) {\n        {\n          $$invalidate(2, title = step.options.title);\n          $$invalidate(3, cancelIcon = step.options.cancelIcon);\n        }\n      }\n    };\n\n    return [labelId, step, title, cancelIcon];\n  }\n\n  var Shepherd_header = /*#__PURE__*/function (_SvelteComponent5) {\n    _inherits(Shepherd_header, _SvelteComponent5);\n\n    var _super5 = _createSuper(Shepherd_header);\n\n    function Shepherd_header(options) {\n      var _this7;\n\n      _classCallCheck(this, Shepherd_header);\n\n      _this7 = _super5.call(this);\n      init(_assertThisInitialized(_this7), options, instance$4, create_fragment$4, safe_not_equal, {\n        labelId: 0,\n        step: 1\n      });\n      return _this7;\n    }\n\n    return _createClass(Shepherd_header);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-text.svelte generated by Svelte v3.49.0 */\n\n\n  function create_fragment$3(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-text\");\n        attr(div, \"id\",\n        /*descriptionId*/\n        ctx[1]);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        /*div_binding*/\n\n        ctx[3](div);\n      },\n      p: function p(ctx, _ref) {\n        var _ref12 = _slicedToArray(_ref, 1),\n            dirty = _ref12[0];\n\n        if (dirty &\n        /*descriptionId*/\n        2) {\n          attr(div, \"id\",\n          /*descriptionId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        /*div_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n\n  function instance$3($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n        element = $$props.element,\n        step = $$props.step;\n    afterUpdate(function () {\n      var text = step.options.text;\n\n      if (isFunction(text)) {\n        text = text.call(step);\n      }\n\n      if (isHTMLElement$1(text)) {\n        element.appendChild(text);\n      } else {\n        $$invalidate(0, element.innerHTML = text, element);\n      }\n    });\n\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(1, descriptionId = $$props.descriptionId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [element, descriptionId, step, div_binding];\n  }\n\n  var Shepherd_text = /*#__PURE__*/function (_SvelteComponent6) {\n    _inherits(Shepherd_text, _SvelteComponent6);\n\n    var _super6 = _createSuper(Shepherd_text);\n\n    function Shepherd_text(options) {\n      var _this8;\n\n      _classCallCheck(this, Shepherd_text);\n\n      _this8 = _super6.call(this);\n      init(_assertThisInitialized(_this8), options, instance$3, create_fragment$3, safe_not_equal, {\n        descriptionId: 1,\n        element: 0,\n        step: 2\n      });\n      return _this8;\n    }\n\n    return _createClass(Shepherd_text);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-content.svelte generated by Svelte v3.49.0 */\n\n\n  function create_if_block_2(ctx) {\n    var shepherdheader;\n    var current;\n    shepherdheader = new Shepherd_header({\n      props: {\n        labelId:\n        /*labelId*/\n        ctx[1],\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdheader.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdheader, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdheader_changes = {};\n        if (dirty &\n        /*labelId*/\n        2) shepherdheader_changes.labelId =\n        /*labelId*/\n        ctx[1];\n        if (dirty &\n        /*step*/\n        4) shepherdheader_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdheader.$set(shepherdheader_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdheader.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdheader.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdheader, detaching);\n      }\n    };\n  } // (28:2) {#if !isUndefined(step.options.text)}\n\n\n  function create_if_block_1(ctx) {\n    var shepherdtext;\n    var current;\n    shepherdtext = new Shepherd_text({\n      props: {\n        descriptionId:\n        /*descriptionId*/\n        ctx[0],\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtext.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtext, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtext_changes = {};\n        if (dirty &\n        /*descriptionId*/\n        1) shepherdtext_changes.descriptionId =\n        /*descriptionId*/\n        ctx[0];\n        if (dirty &\n        /*step*/\n        4) shepherdtext_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdtext.$set(shepherdtext_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtext.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtext.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtext, detaching);\n      }\n    };\n  } // (35:2) {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n\n\n  function create_if_block$1(ctx) {\n    var shepherdfooter;\n    var current;\n    shepherdfooter = new Shepherd_footer({\n      props: {\n        step:\n        /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdfooter.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdfooter, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdfooter_changes = {};\n        if (dirty &\n        /*step*/\n        4) shepherdfooter_changes.step =\n        /*step*/\n        ctx[2];\n        shepherdfooter.$set(shepherdfooter_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdfooter.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdfooter.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdfooter, detaching);\n      }\n    };\n  }\n\n  function create_fragment$2(ctx) {\n    var div;\n    var show_if_2 = !isUndefined(\n    /*step*/\n    ctx[2].options.title) ||\n    /*step*/\n    ctx[2].options.cancelIcon &&\n    /*step*/\n    ctx[2].options.cancelIcon.enabled;\n    var t0;\n    var show_if_1 = !isUndefined(\n    /*step*/\n    ctx[2].options.text);\n    var t1;\n    var show_if = Array.isArray(\n    /*step*/\n    ctx[2].options.buttons) &&\n    /*step*/\n    ctx[2].options.buttons.length;\n    var current;\n    var if_block0 = show_if_2 && create_if_block_2(ctx);\n    var if_block1 = show_if_1 && create_if_block_1(ctx);\n    var if_block2 = show_if && create_if_block$1(ctx);\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        attr(div, \"class\", \"shepherd-content\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block0) if_block0.m(div, null);\n        append(div, t0);\n        if (if_block1) if_block1.m(div, null);\n        append(div, t1);\n        if (if_block2) if_block2.m(div, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref13 = _slicedToArray(_ref, 1),\n            dirty = _ref13[0];\n\n        if (dirty &\n        /*step*/\n        4) show_if_2 = !isUndefined(\n        /*step*/\n        ctx[2].options.title) ||\n        /*step*/\n        ctx[2].options.cancelIcon &&\n        /*step*/\n        ctx[2].options.cancelIcon.enabled;\n\n        if (show_if_2) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_2(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(div, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n\n        if (dirty &\n        /*step*/\n        4) show_if_1 = !isUndefined(\n        /*step*/\n        ctx[2].options.text);\n\n        if (show_if_1) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(div, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n\n        if (dirty &\n        /*step*/\n        4) show_if = Array.isArray(\n        /*step*/\n        ctx[2].options.buttons) &&\n        /*step*/\n        ctx[2].options.buttons.length;\n\n        if (show_if) {\n          if (if_block2) {\n            if_block2.p(ctx, dirty);\n\n            if (dirty &\n            /*step*/\n            4) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block$1(ctx);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(div, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, function () {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n      }\n    };\n  }\n\n  function instance$2($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n        labelId = $$props.labelId,\n        step = $$props.step;\n\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(0, descriptionId = $$props.descriptionId);\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n\n    return [descriptionId, labelId, step];\n  }\n\n  var Shepherd_content = /*#__PURE__*/function (_SvelteComponent7) {\n    _inherits(Shepherd_content, _SvelteComponent7);\n\n    var _super7 = _createSuper(Shepherd_content);\n\n    function Shepherd_content(options) {\n      var _this9;\n\n      _classCallCheck(this, Shepherd_content);\n\n      _this9 = _super7.call(this);\n      init(_assertThisInitialized(_this9), options, instance$2, create_fragment$2, safe_not_equal, {\n        descriptionId: 0,\n        labelId: 1,\n        step: 2\n      });\n      return _this9;\n    }\n\n    return _createClass(Shepherd_content);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-element.svelte generated by Svelte v3.49.0 */\n\n\n  function create_if_block(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-arrow\");\n        attr(div, \"data-popper-arrow\", \"\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n      }\n    };\n  }\n\n  function create_fragment$1(ctx) {\n    var div;\n    var t;\n    var shepherdcontent;\n    var div_aria_describedby_value;\n    var div_aria_labelledby_value;\n    var current;\n    var mounted;\n    var dispose;\n    var if_block =\n    /*step*/\n    ctx[4].options.arrow &&\n    /*step*/\n    ctx[4].options.attachTo &&\n    /*step*/\n    ctx[4].options.attachTo.element &&\n    /*step*/\n    ctx[4].options.attachTo.on && create_if_block();\n    shepherdcontent = new Shepherd_content({\n      props: {\n        descriptionId:\n        /*descriptionId*/\n        ctx[2],\n        labelId:\n        /*labelId*/\n        ctx[3],\n        step:\n        /*step*/\n        ctx[4]\n      }\n    });\n    var div_levels = [{\n      \"aria-describedby\": div_aria_describedby_value = !isUndefined(\n      /*step*/\n      ctx[4].options.text) ?\n      /*descriptionId*/\n      ctx[2] : null\n    }, {\n      \"aria-labelledby\": div_aria_labelledby_value =\n      /*step*/\n      ctx[4].options.title ?\n      /*labelId*/\n      ctx[3] : null\n    },\n    /*dataStepId*/\n    ctx[1], {\n      role: \"dialog\"\n    }, {\n      tabindex: \"0\"\n    }];\n    var div_data = {};\n\n    for (var i = 0; i < div_levels.length; i += 1) {\n      div_data = assign(div_data, div_levels[i]);\n    }\n\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(shepherdcontent.$$.fragment);\n        set_attributes(div, div_data);\n        toggle_class(div, \"shepherd-has-cancel-icon\",\n        /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\",\n        /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block) if_block.m(div, null);\n        append(div, t);\n        mount_component(shepherdcontent, div, null);\n        /*div_binding*/\n\n        ctx[13](div);\n        current = true;\n\n        if (!mounted) {\n          dispose = listen(div, \"keydown\",\n          /*handleKeyDown*/\n          ctx[7]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref14 = _slicedToArray(_ref, 1),\n            dirty = _ref14[0];\n\n        if (\n        /*step*/\n        ctx[4].options.arrow &&\n        /*step*/\n        ctx[4].options.attachTo &&\n        /*step*/\n        ctx[4].options.attachTo.element &&\n        /*step*/\n        ctx[4].options.attachTo.on) {\n          if (if_block) ;else {\n            if_block = create_if_block();\n            if_block.c();\n            if_block.m(div, t);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n\n        var shepherdcontent_changes = {};\n        if (dirty &\n        /*descriptionId*/\n        4) shepherdcontent_changes.descriptionId =\n        /*descriptionId*/\n        ctx[2];\n        if (dirty &\n        /*labelId*/\n        8) shepherdcontent_changes.labelId =\n        /*labelId*/\n        ctx[3];\n        if (dirty &\n        /*step*/\n        16) shepherdcontent_changes.step =\n        /*step*/\n        ctx[4];\n        shepherdcontent.$set(shepherdcontent_changes);\n        set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty &\n        /*step, descriptionId*/\n        20 && div_aria_describedby_value !== (div_aria_describedby_value = !isUndefined(\n        /*step*/\n        ctx[4].options.text) ?\n        /*descriptionId*/\n        ctx[2] : null)) && {\n          \"aria-describedby\": div_aria_describedby_value\n        }, (!current || dirty &\n        /*step, labelId*/\n        24 && div_aria_labelledby_value !== (div_aria_labelledby_value =\n        /*step*/\n        ctx[4].options.title ?\n        /*labelId*/\n        ctx[3] : null)) && {\n          \"aria-labelledby\": div_aria_labelledby_value\n        }, dirty &\n        /*dataStepId*/\n        2 &&\n        /*dataStepId*/\n        ctx[1], {\n          role: \"dialog\"\n        }, {\n          tabindex: \"0\"\n        }]));\n        toggle_class(div, \"shepherd-has-cancel-icon\",\n        /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\",\n        /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcontent.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcontent.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block) if_block.d();\n        destroy_component(shepherdcontent);\n        /*div_binding*/\n\n        ctx[13](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  var KEY_TAB = 9;\n  var KEY_ESC = 27;\n  var LEFT_ARROW = 37;\n  var RIGHT_ARROW = 39;\n\n  function getClassesArray(classes) {\n    return classes.split(' ').filter(function (className) {\n      return !!className.length;\n    });\n  }\n\n  function instance$1($$self, $$props, $$invalidate) {\n    var classPrefix = $$props.classPrefix,\n        element = $$props.element,\n        descriptionId = $$props.descriptionId,\n        firstFocusableElement = $$props.firstFocusableElement,\n        focusableElements = $$props.focusableElements,\n        labelId = $$props.labelId,\n        lastFocusableElement = $$props.lastFocusableElement,\n        step = $$props.step,\n        dataStepId = $$props.dataStepId;\n    var hasCancelIcon, hasTitle, classes;\n\n    var getElement = function getElement() {\n      return element;\n    };\n\n    onMount(function () {\n      // Get all elements that are focusable\n      $$invalidate(1, dataStepId = _defineProperty({}, \"data-\".concat(classPrefix, \"shepherd-step-id\"), step.id));\n      $$invalidate(9, focusableElements = element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]'));\n      $$invalidate(8, firstFocusableElement = focusableElements[0]);\n      $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);\n    });\n    afterUpdate(function () {\n      if (classes !== step.options.classes) {\n        updateDynamicClasses();\n      }\n    });\n\n    function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n    }\n\n    function removeClasses(classes) {\n      if (isString(classes)) {\n        var oldClasses = getClassesArray(classes);\n\n        if (oldClasses.length) {\n          var _element$classList;\n\n          (_element$classList = element.classList).remove.apply(_element$classList, _toConsumableArray(oldClasses));\n        }\n      }\n    }\n\n    function addClasses(classes) {\n      if (isString(classes)) {\n        var newClasses = getClassesArray(classes);\n\n        if (newClasses.length) {\n          var _element$classList2;\n\n          (_element$classList2 = element.classList).add.apply(_element$classList2, _toConsumableArray(newClasses));\n        }\n      }\n    }\n    /**\n    * Setup keydown events to allow closing the modal with ESC\n    *\n    * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n    *\n    * @private\n    */\n\n\n    var handleKeyDown = function handleKeyDown(e) {\n      var _step = step,\n          tour = _step.tour;\n\n      switch (e.keyCode) {\n        case KEY_TAB:\n          if (focusableElements.length === 0) {\n            e.preventDefault();\n            break;\n          } // Backward tab\n\n\n          if (e.shiftKey) {\n            if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains('shepherd-element')) {\n              e.preventDefault();\n              lastFocusableElement.focus();\n            }\n          } else {\n            if (document.activeElement === lastFocusableElement) {\n              e.preventDefault();\n              firstFocusableElement.focus();\n            }\n          }\n\n          break;\n\n        case KEY_ESC:\n          if (tour.options.exitOnEsc) {\n            step.cancel();\n          }\n\n          break;\n\n        case LEFT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.back();\n          }\n\n          break;\n\n        case RIGHT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.next();\n          }\n\n          break;\n      }\n    };\n\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if ('classPrefix' in $$props) $$invalidate(11, classPrefix = $$props.classPrefix);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('descriptionId' in $$props) $$invalidate(2, descriptionId = $$props.descriptionId);\n      if ('firstFocusableElement' in $$props) $$invalidate(8, firstFocusableElement = $$props.firstFocusableElement);\n      if ('focusableElements' in $$props) $$invalidate(9, focusableElements = $$props.focusableElements);\n      if ('labelId' in $$props) $$invalidate(3, labelId = $$props.labelId);\n      if ('lastFocusableElement' in $$props) $$invalidate(10, lastFocusableElement = $$props.lastFocusableElement);\n      if ('step' in $$props) $$invalidate(4, step = $$props.step);\n      if ('dataStepId' in $$props) $$invalidate(1, dataStepId = $$props.dataStepId);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*step*/\n      16) {\n        {\n          $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);\n          $$invalidate(6, hasTitle = step.options && step.options.title);\n        }\n      }\n    };\n\n    return [element, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, div_binding];\n  }\n\n  var Shepherd_element = /*#__PURE__*/function (_SvelteComponent8) {\n    _inherits(Shepherd_element, _SvelteComponent8);\n\n    var _super8 = _createSuper(Shepherd_element);\n\n    function Shepherd_element(options) {\n      var _this10;\n\n      _classCallCheck(this, Shepherd_element);\n\n      _this10 = _super8.call(this);\n      init(_assertThisInitialized(_this10), options, instance$1, create_fragment$1, safe_not_equal, {\n        classPrefix: 11,\n        element: 0,\n        descriptionId: 2,\n        firstFocusableElement: 8,\n        focusableElements: 9,\n        labelId: 3,\n        lastFocusableElement: 10,\n        step: 4,\n        dataStepId: 1,\n        getElement: 12\n      });\n      return _this10;\n    }\n\n    _createClass(Shepherd_element, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[12];\n      }\n    }]);\n\n    return Shepherd_element;\n  }(SvelteComponent);\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var smoothscroll = createCommonjsModule(function (module, exports) {\n    /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n    (function () {\n      function polyfill() {\n        // aliases\n        var w = window;\n        var d = document; // return if scroll behavior is supported and polyfill is not forced\n\n        if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n          return;\n        } // globals\n\n\n        var Element = w.HTMLElement || w.Element;\n        var SCROLL_TIME = 468; // object gathering original scroll methods\n\n        var original = {\n          scroll: w.scroll || w.scrollTo,\n          scrollBy: w.scrollBy,\n          elementScroll: Element.prototype.scroll || scrollElement,\n          scrollIntoView: Element.prototype.scrollIntoView\n        }; // define timing method\n\n        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n        /**\n         * indicates if a the current browser is made by Microsoft\n         * @method isMicrosoftBrowser\n         * @param {String} userAgent\n         * @returns {Boolean}\n         */\n\n        function isMicrosoftBrowser(userAgent) {\n          var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n          return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n        }\n        /*\n         * IE has rounding bug rounding down clientHeight and clientWidth and\n         * rounding up scrollHeight and scrollWidth causing false positives\n         * on hasScrollableSpace\n         */\n\n\n        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n        /**\n         * changes scroll position inside an element\n         * @method scrollElement\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function scrollElement(x, y) {\n          this.scrollLeft = x;\n          this.scrollTop = y;\n        }\n        /**\n         * returns result of applying ease math function to a number\n         * @method ease\n         * @param {Number} k\n         * @returns {Number}\n         */\n\n\n        function ease(k) {\n          return 0.5 * (1 - Math.cos(Math.PI * k));\n        }\n        /**\n         * indicates if a smooth behavior should be applied\n         * @method shouldBailOut\n         * @param {Number|Object} firstArg\n         * @returns {Boolean}\n         */\n\n\n        function shouldBailOut(firstArg) {\n          if (firstArg === null || _typeof(firstArg) !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {\n            // first argument is not an object/null\n            // or behavior is auto, instant or undefined\n            return true;\n          }\n\n          if (_typeof(firstArg) === 'object' && firstArg.behavior === 'smooth') {\n            // first argument is an object and behavior is smooth\n            return false;\n          } // throw error when behavior is not supported\n\n\n          throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');\n        }\n        /**\n         * indicates if an element has scrollable space in the provided axis\n         * @method hasScrollableSpace\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function hasScrollableSpace(el, axis) {\n          if (axis === 'Y') {\n            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n          }\n\n          if (axis === 'X') {\n            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n          }\n        }\n        /**\n         * indicates if an element has a scrollable overflow property in the axis\n         * @method canOverflow\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function canOverflow(el, axis) {\n          var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n          return overflowValue === 'auto' || overflowValue === 'scroll';\n        }\n        /**\n         * indicates if an element can be scrolled in either axis\n         * @method isScrollable\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function isScrollable(el) {\n          var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n          var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n          return isScrollableY || isScrollableX;\n        }\n        /**\n         * finds scrollable parent of an element\n         * @method findScrollableParent\n         * @param {Node} el\n         * @returns {Node} el\n         */\n\n\n        function findScrollableParent(el) {\n          while (el !== d.body && isScrollable(el) === false) {\n            el = el.parentNode || el.host;\n          }\n\n          return el;\n        }\n        /**\n         * self invoked function that, given a context, steps through scrolling\n         * @method step\n         * @param {Object} context\n         * @returns {undefined}\n         */\n\n\n        function step(context) {\n          var time = now();\n          var value;\n          var currentX;\n          var currentY;\n          var elapsed = (time - context.startTime) / SCROLL_TIME; // avoid elapsed times higher than one\n\n          elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n          value = ease(elapsed);\n          currentX = context.startX + (context.x - context.startX) * value;\n          currentY = context.startY + (context.y - context.startY) * value;\n          context.method.call(context.scrollable, currentX, currentY); // scroll more if we have not reached our destination\n\n          if (currentX !== context.x || currentY !== context.y) {\n            w.requestAnimationFrame(step.bind(w, context));\n          }\n        }\n        /**\n         * scrolls window or element with a smooth behavior\n         * @method smoothScroll\n         * @param {Object|Node} el\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n\n        function smoothScroll(el, x, y) {\n          var scrollable;\n          var startX;\n          var startY;\n          var method;\n          var startTime = now(); // define scroll context\n\n          if (el === d.body) {\n            scrollable = w;\n            startX = w.scrollX || w.pageXOffset;\n            startY = w.scrollY || w.pageYOffset;\n            method = original.scroll;\n          } else {\n            scrollable = el;\n            startX = el.scrollLeft;\n            startY = el.scrollTop;\n            method = scrollElement;\n          } // scroll looping over a frame\n\n\n          step({\n            scrollable: scrollable,\n            method: method,\n            startTime: startTime,\n            startX: startX,\n            startY: startY,\n            x: x,\n            y: y\n          });\n        } // ORIGINAL METHODS OVERRIDES\n        // w.scroll and w.scrollTo\n\n\n        w.scroll = w.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset, // use top prop, second argument if present or fallback to scrollY\n            arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n        }; // w.scrollBy\n\n\n        w.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0])) {\n            original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n        }; // Element.prototype.scroll and Element.prototype.scrollTo\n\n\n        Element.prototype.scroll = Element.prototype.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            // if one number is passed, throw error to match Firefox implementation\n            if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n              throw new SyntaxError('Value could not be converted');\n            }\n\n            original.elementScroll.call(this, // use left prop, first number argument or fallback to scrollLeft\n            arguments[0].left !== undefined ? ~~arguments[0].left : _typeof(arguments[0]) !== 'object' ? ~~arguments[0] : this.scrollLeft, // use top prop, second argument or fallback to scrollTop\n            arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n            return;\n          }\n\n          var left = arguments[0].left;\n          var top = arguments[0].top; // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);\n        }; // Element.prototype.scrollBy\n\n\n        Element.prototype.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n            return;\n          }\n\n          this.scroll({\n            left: ~~arguments[0].left + this.scrollLeft,\n            top: ~~arguments[0].top + this.scrollTop,\n            behavior: arguments[0].behavior\n          });\n        }; // Element.prototype.scrollIntoView\n\n\n        Element.prototype.scrollIntoView = function () {\n          // avoid smooth behavior if not required\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          var scrollableParent = findScrollableParent(this);\n          var parentRects = scrollableParent.getBoundingClientRect();\n          var clientRects = this.getBoundingClientRect();\n\n          if (scrollableParent !== d.body) {\n            // reveal element inside parent\n            smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top); // reveal parent in viewport unless is fixed\n\n            if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n              w.scrollBy({\n                left: parentRects.left,\n                top: parentRects.top,\n                behavior: 'smooth'\n              });\n            }\n          } else {\n            // reveal element in viewport\n            w.scrollBy({\n              left: clientRects.left,\n              top: clientRects.top,\n              behavior: 'smooth'\n            });\n          }\n        };\n      }\n\n      {\n        // commonjs\n        module.exports = {\n          polyfill: polyfill\n        };\n      }\n    })();\n  });\n  smoothscroll.polyfill;\n  smoothscroll.polyfill();\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n\n  var Step = /*#__PURE__*/function (_Evented) {\n    _inherits(Step, _Evented);\n\n    var _super9 = _createSuper(Step);\n\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {object} options The options for the step\n     * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n     * @param {object} options.attachTo The element the step should be attached to on the page.\n     * An object with properties `element` and `on`.\n     *\n     * ```js\n     * const step = new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * });\n     * ```\n     *\n     * If you dont specify an `attachTo` the element will appear in the middle of the screen. The same will happen if your `attachTo.element` callback returns `null`, `undefined`, or a selector that does not exist in the DOM.\n     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n     * in the middle of the screen, without an arrow pointing to the target.\n     * If the element to highlight does not yet exist while instantiating tour steps, you may use lazy evaluation by supplying a function to `attachTo.element`. The function will be called in the `before-show` phase.\n     * @param {string|HTMLElement|function} options.attachTo.element An element selector string, DOM element, or a function (returning a selector, a DOM element, `null` or `undefined`).\n     * @param {string} options.attachTo.on The optional direction to place the Popper tooltip relative to the element.\n     *   - Possible string values: 'auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It should be an object with a string `selector` and an `event` name\n     * ```js\n     * const step = new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * });\n     * ```\n     * `event` doesnt have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n     * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n     * work inside the action.\n     * You can use action to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * action() {\n     *   return this.show('some_step_name');\n     * }\n     * ```\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n     * @param {string} options.buttons.button.label The aria-label text of the button\n     * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n     * @param {object} options.cancelIcon Options for the cancel icon\n     * @param {boolean} options.cancelIcon.enabled Should a cancel  be shown in the header of the step?\n     * @param {string} options.cancelIcon.label The label to add for `aria-label`\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {string} options.id The string to use as the `id` for the step.\n     * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @param {number} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n     * @param {object} options.popperOptions Extra options to pass to Popper\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of three types:\n     * ```\n     * - HTML string\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one the two options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n     * ```\n     * - HTML string\n     * - `Function` to be executed when the step is built. It must return HTML string.\n     * ```\n     * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @return {Step} The newly created Step instance\n     */\n    function Step(tour, options) {\n      var _this11;\n\n      _classCallCheck(this, Step);\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      _this11 = _super9.call(this, tour, options);\n      _this11.tour = tour;\n      _this11.classPrefix = _this11.tour.options ? normalizePrefix(_this11.tour.options.classPrefix) : '';\n      _this11.styles = tour.styles;\n      /**\n       * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n       * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n       * @type {null|{}|{element, to}}\n       * @private\n       */\n\n      _this11._resolvedAttachTo = null;\n      autoBind(_assertThisInitialized(_this11));\n\n      _this11._setOptions(options);\n\n      return _possibleConstructorReturn(_this11, _assertThisInitialized(_this11));\n    }\n    /**\n     * Cancel the tour\n     * Triggers the `cancel` event\n     */\n\n\n    _createClass(Step, [{\n      key: \"cancel\",\n      value: function cancel() {\n        this.tour.cancel();\n        this.trigger('cancel');\n      }\n      /**\n       * Complete the tour\n       * Triggers the `complete` event\n       */\n\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.tour.complete();\n        this.trigger('complete');\n      }\n      /**\n       * Remove the step, delete the step's element, and destroy the Popper instance for the step.\n       * Triggers `destroy` event\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        if (this.tooltip) {\n          this.tooltip.destroy();\n          this.tooltip = null;\n        }\n\n        if (isHTMLElement$1(this.el) && this.el.parentNode) {\n          this.el.parentNode.removeChild(this.el);\n          this.el = null;\n        }\n\n        this._updateStepTargetOnHide();\n\n        this.trigger('destroy');\n      }\n      /**\n       * Returns the tour for the step\n       * @return {Tour} The tour instance\n       */\n\n    }, {\n      key: \"getTour\",\n      value: function getTour() {\n        return this.tour;\n      }\n      /**\n       * Hide the step\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.tour.modal.hide();\n        this.trigger('before-hide');\n\n        if (this.el) {\n          this.el.hidden = true;\n        }\n\n        this._updateStepTargetOnHide();\n\n        this.trigger('hide');\n      }\n      /**\n       * Resolves attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n\n    }, {\n      key: \"_resolveAttachToOptions\",\n      value: function _resolveAttachToOptions() {\n        this._resolvedAttachTo = parseAttachTo(this);\n        return this._resolvedAttachTo;\n      }\n      /**\n       * A selector for resolved attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n\n    }, {\n      key: \"_getResolvedAttachToOptions\",\n      value: function _getResolvedAttachToOptions() {\n        if (this._resolvedAttachTo === null) {\n          return this._resolveAttachToOptions();\n        }\n\n        return this._resolvedAttachTo;\n      }\n      /**\n       * Check if the step is open and visible\n       * @return {boolean} True if the step is open and visible\n       */\n\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return Boolean(this.el && !this.el.hidden);\n      }\n      /**\n       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n       * @return {*|Promise}\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this12 = this;\n\n        if (isFunction(this.options.beforeShowPromise)) {\n          var beforeShowPromise = this.options.beforeShowPromise();\n\n          if (!isUndefined(beforeShowPromise)) {\n            return beforeShowPromise.then(function () {\n              return _this12._show();\n            });\n          }\n        }\n\n        this._show();\n      }\n      /**\n       * Updates the options of the step.\n       *\n       * @param {Object} options The options for the step\n       */\n\n    }, {\n      key: \"updateStepOptions\",\n      value: function updateStepOptions(options) {\n        Object.assign(this.options, options);\n\n        if (this.shepherdElementComponent) {\n          this.shepherdElementComponent.$set({\n            step: this\n          });\n        }\n      }\n      /**\n       * Returns the element for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n       */\n\n    }, {\n      key: \"getElement\",\n      value: function getElement() {\n        return this.el;\n      }\n      /**\n       * Returns the target for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n       */\n\n    }, {\n      key: \"getTarget\",\n      value: function getTarget() {\n        return this.target;\n      }\n      /**\n       * Creates Shepherd element for step based on options\n       *\n       * @return {Element} The DOM element for the step tooltip\n       * @private\n       */\n\n    }, {\n      key: \"_createTooltipContent\",\n      value: function _createTooltipContent() {\n        var descriptionId = \"\".concat(this.id, \"-description\");\n        var labelId = \"\".concat(this.id, \"-label\");\n        this.shepherdElementComponent = new Shepherd_element({\n          target: this.tour.options.stepsContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            descriptionId: descriptionId,\n            labelId: labelId,\n            step: this,\n            styles: this.styles\n          }\n        });\n        return this.shepherdElementComponent.getElement();\n      }\n      /**\n       * If a custom scrollToHandler is defined, call that, otherwise do the generic\n       * scrollIntoView call.\n       *\n       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n       * @private\n       */\n\n    }, {\n      key: \"_scrollTo\",\n      value: function _scrollTo(scrollToOptions) {\n        var _this$_getResolvedAtt = this._getResolvedAttachToOptions(),\n            element = _this$_getResolvedAtt.element;\n\n        if (isFunction(this.options.scrollToHandler)) {\n          this.options.scrollToHandler(element);\n        } else if (isElement$1(element) && typeof element.scrollIntoView === 'function') {\n          element.scrollIntoView(scrollToOptions);\n        }\n      }\n      /**\n       * _getClassOptions gets all possible classes for the step\n       * @param {Object} stepOptions The step specific options\n       * @returns {String} unique string from array of classes\n       * @private\n       */\n\n    }, {\n      key: \"_getClassOptions\",\n      value: function _getClassOptions(stepOptions) {\n        var defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        var stepClasses = stepOptions.classes ? stepOptions.classes : '';\n        var defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : '';\n        var allClasses = [].concat(_toConsumableArray(stepClasses.split(' ')), _toConsumableArray(defaultStepOptionsClasses.split(' ')));\n        var uniqClasses = new Set(allClasses);\n        return Array.from(uniqClasses).join(' ').trim();\n      }\n      /**\n       * Sets the options for the step, maps `when` to events, sets up buttons\n       * @param {Object} options The options for the step\n       * @private\n       */\n\n    }, {\n      key: \"_setOptions\",\n      value: function _setOptions(options) {\n        var _this13 = this;\n\n        if (options === void 0) {\n          options = {};\n        }\n\n        var tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        tourOptions = cjs({}, tourOptions || {});\n        this.options = Object.assign({\n          arrow: true\n        }, tourOptions, options);\n        var when = this.options.when;\n        this.options.classes = this._getClassOptions(options);\n        this.destroy();\n        this.id = this.options.id || \"step-\".concat(uuid());\n\n        if (when) {\n          Object.keys(when).forEach(function (event) {\n            _this13.on(event, when[event], _this13);\n          });\n        }\n      }\n      /**\n       * Create the element and set up the Popper instance\n       * @private\n       */\n\n    }, {\n      key: \"_setupElements\",\n      value: function _setupElements() {\n        if (!isUndefined(this.el)) {\n          this.destroy();\n        }\n\n        this.el = this._createTooltipContent();\n\n        if (this.options.advanceOn) {\n          bindAdvance(this);\n        }\n\n        setupTooltip(this);\n      }\n      /**\n       * Triggers `before-show`, generates the tooltip DOM content,\n       * sets up a Popper instance for the tooltip, then triggers `show`.\n       * @private\n       */\n\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        var _this14 = this;\n\n        this.trigger('before-show'); // Force resolve to make sure the options are updated on subsequent shows.\n\n        this._resolveAttachToOptions();\n\n        this._setupElements();\n\n        if (!this.tour.modal) {\n          this.tour._setupModal();\n        }\n\n        this.tour.modal.setupForStep(this);\n\n        this._styleTargetElementForStep(this);\n\n        this.el.hidden = false; // start scrolling to target before showing the step\n\n        if (this.options.scrollTo) {\n          setTimeout(function () {\n            _this14._scrollTo(_this14.options.scrollTo);\n          });\n        }\n\n        this.el.hidden = false;\n        var content = this.shepherdElementComponent.getElement();\n        var target = this.target || document.body;\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-enabled\"));\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-target\"));\n        content.classList.add('shepherd-enabled');\n        this.trigger('show');\n      }\n      /**\n       * Modulates the styles of the passed step's target element, based on the step's options and\n       * the tour's `modal` option, to visually emphasize the element\n       *\n       * @param step The step object that attaches to the element\n       * @private\n       */\n\n    }, {\n      key: \"_styleTargetElementForStep\",\n      value: function _styleTargetElementForStep(step) {\n        var targetElement = step.target;\n\n        if (!targetElement) {\n          return;\n        }\n\n        if (step.options.highlightClass) {\n          targetElement.classList.add(step.options.highlightClass);\n        }\n\n        targetElement.classList.remove('shepherd-target-click-disabled');\n\n        if (step.options.canClickTarget === false) {\n          targetElement.classList.add('shepherd-target-click-disabled');\n        }\n      }\n      /**\n       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n       * and 'shepherd-target' classes\n       * @private\n       */\n\n    }, {\n      key: \"_updateStepTargetOnHide\",\n      value: function _updateStepTargetOnHide() {\n        var target = this.target || document.body;\n\n        if (this.options.highlightClass) {\n          target.classList.remove(this.options.highlightClass);\n        }\n\n        target.classList.remove('shepherd-target-click-disabled', \"\".concat(this.classPrefix, \"shepherd-enabled\"), \"\".concat(this.classPrefix, \"shepherd-target\"));\n      }\n    }]);\n\n    return Step;\n  }(Evented);\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n\n\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          if (step.target instanceof HTMLElement) {\n            step.target.classList.remove('shepherd-target-click-disabled');\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Generates the svg path data for a rounded rectangle overlay\n   * @param {Object} dimension - Dimensions of rectangle.\n   * @param {number} width - Width.\n   * @param {number} height - Height.\n   * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n   * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n   * @param {number} [r=0] - Corner Radius. Keep this smaller than  half of width or height.\n   * @returns {string} - Rounded rectangle overlay path data.\n   */\n\n\n  function makeOverlayPath(_ref) {\n    var width = _ref.width,\n        height = _ref.height,\n        _ref$x = _ref.x,\n        x = _ref$x === void 0 ? 0 : _ref$x,\n        _ref$y = _ref.y,\n        y = _ref$y === void 0 ? 0 : _ref$y,\n        _ref$r = _ref.r,\n        r = _ref$r === void 0 ? 0 : _ref$r;\n    var _window = window,\n        w = _window.innerWidth,\n        h = _window.innerHeight;\n    return \"M\".concat(w, \",\").concat(h, \"H0V0H\").concat(w, \"V\").concat(h, \"ZM\").concat(x + r, \",\").concat(y, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \",\").concat(r, \"V\").concat(height + y - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \",\").concat(r, \"H\").concat(width + x - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \"-\").concat(r, \"V\").concat(y + r, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \"-\").concat(r, \"Z\");\n  }\n  /* src/js/components/shepherd-modal.svelte generated by Svelte v3.49.0 */\n\n\n  function create_fragment(ctx) {\n    var svg;\n    var path;\n    var svg_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        svg = svg_element(\"svg\");\n        path = svg_element(\"path\");\n        attr(path, \"d\",\n        /*pathDefinition*/\n        ctx[2]);\n        attr(svg, \"class\", svg_class_value = \"\".concat(\n        /*modalIsVisible*/\n        ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"));\n      },\n      m: function m(target, anchor) {\n        insert(target, svg, anchor);\n        append(svg, path);\n        /*svg_binding*/\n\n        ctx[11](svg);\n\n        if (!mounted) {\n          dispose = listen(svg, \"touchmove\",\n          /*_preventModalOverlayTouch*/\n          ctx[3]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref15 = _slicedToArray(_ref, 1),\n            dirty = _ref15[0];\n\n        if (dirty &\n        /*pathDefinition*/\n        4) {\n          attr(path, \"d\",\n          /*pathDefinition*/\n          ctx[2]);\n        }\n\n        if (dirty &\n        /*modalIsVisible*/\n        2 && svg_class_value !== (svg_class_value = \"\".concat(\n        /*modalIsVisible*/\n        ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"))) {\n          attr(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(svg);\n        /*svg_binding*/\n\n        ctx[11](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n\n    var isHtmlElement = element instanceof HTMLElement;\n    var overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;\n    var isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n\n    return _getScrollParent(element.parentElement);\n  }\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n\n\n  function _getVisibleHeight(element, scrollParent) {\n    var elementRect = element.getBoundingClientRect();\n    var top = elementRect.y || elementRect.top;\n    var bottom = elementRect.bottom || top + elementRect.height;\n\n    if (scrollParent) {\n      var scrollRect = scrollParent.getBoundingClientRect();\n      var scrollTop = scrollRect.y || scrollRect.top;\n      var scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n\n    var height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n\n    return {\n      y: top,\n      height: height\n    };\n  }\n\n  function instance($$self, $$props, $$invalidate) {\n    var element = $$props.element,\n        openingProperties = $$props.openingProperties;\n    uuid();\n    var modalIsVisible = false;\n    var rafId = undefined;\n    var pathDefinition;\n    closeModalOpening();\n\n    var getElement = function getElement() {\n      return element;\n    };\n\n    function closeModalOpening() {\n      $$invalidate(4, openingProperties = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      });\n    }\n\n    function hide() {\n      $$invalidate(1, modalIsVisible = false); // Ensure we cleanup all event listeners when we hide the modal\n\n      _cleanupStepEventListeners();\n    }\n\n    function positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, targetElement) {\n      if (modalOverlayOpeningPadding === void 0) {\n        modalOverlayOpeningPadding = 0;\n      }\n\n      if (modalOverlayOpeningRadius === void 0) {\n        modalOverlayOpeningRadius = 0;\n      }\n\n      if (targetElement) {\n        var _getVisibleHeight2 = _getVisibleHeight(targetElement, scrollParent),\n            y = _getVisibleHeight2.y,\n            height = _getVisibleHeight2.height;\n\n        var _targetElement$getBou = targetElement.getBoundingClientRect(),\n            x = _targetElement$getBou.x,\n            width = _targetElement$getBou.width,\n            _left = _targetElement$getBou.left; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n\n\n        $$invalidate(4, openingProperties = {\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x: (x || _left) - modalOverlayOpeningPadding,\n          y: y - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      } else {\n        closeModalOpening();\n      }\n    }\n\n    function setupForStep(step) {\n      // Ensure we move listeners from the previous step, before we setup new ones\n      _cleanupStepEventListeners();\n\n      if (step.tour.options.useModalOverlay) {\n        _styleForStep(step);\n\n        show();\n      } else {\n        hide();\n      }\n    }\n\n    function show() {\n      $$invalidate(1, modalIsVisible = true);\n    }\n\n    var _preventModalBodyTouch = function _preventModalBodyTouch(e) {\n      e.preventDefault();\n    };\n\n    var _preventModalOverlayTouch = function _preventModalOverlayTouch(e) {\n      e.stopPropagation();\n    };\n    /**\n    * Add touchmove event listener\n    * @private\n    */\n\n\n    function _addStepEventListeners() {\n      // Prevents window from moving on touch.\n      window.addEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n    * @private\n    */\n\n\n    function _cleanupStepEventListeners() {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = undefined;\n      }\n\n      window.removeEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Style the modal for the step\n    * @param {Step} step The step to style the opening for\n    * @private\n    */\n\n\n    function _styleForStep(step) {\n      var _step$options = step.options,\n          modalOverlayOpeningPadding = _step$options.modalOverlayOpeningPadding,\n          modalOverlayOpeningRadius = _step$options.modalOverlayOpeningRadius;\n\n      var scrollParent = _getScrollParent(step.target); // Setup recursive function to call requestAnimationFrame to update the modal opening position\n\n\n      var rafLoop = function rafLoop() {\n        rafId = undefined;\n        positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, step.target);\n        rafId = requestAnimationFrame(rafLoop);\n      };\n\n      rafLoop();\n\n      _addStepEventListeners();\n    }\n\n    function svg_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n\n    $$self.$$set = function ($$props) {\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('openingProperties' in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);\n    };\n\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty &\n      /*openingProperties*/\n      16) {\n        $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));\n      }\n    };\n\n    return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];\n  }\n\n  var Shepherd_modal = /*#__PURE__*/function (_SvelteComponent9) {\n    _inherits(Shepherd_modal, _SvelteComponent9);\n\n    var _super10 = _createSuper(Shepherd_modal);\n\n    function Shepherd_modal(options) {\n      var _this15;\n\n      _classCallCheck(this, Shepherd_modal);\n\n      _this15 = _super10.call(this);\n      init(_assertThisInitialized(_this15), options, instance, create_fragment, safe_not_equal, {\n        element: 0,\n        openingProperties: 4,\n        getElement: 5,\n        closeModalOpening: 6,\n        hide: 7,\n        positionModal: 8,\n        setupForStep: 9,\n        show: 10\n      });\n      return _this15;\n    }\n\n    _createClass(Shepherd_modal, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[5];\n      }\n    }, {\n      key: \"closeModalOpening\",\n      get: function get() {\n        return this.$$.ctx[6];\n      }\n    }, {\n      key: \"hide\",\n      get: function get() {\n        return this.$$.ctx[7];\n      }\n    }, {\n      key: \"positionModal\",\n      get: function get() {\n        return this.$$.ctx[8];\n      }\n    }, {\n      key: \"setupForStep\",\n      get: function get() {\n        return this.$$.ctx[9];\n      }\n    }, {\n      key: \"show\",\n      get: function get() {\n        return this.$$.ctx[10];\n      }\n    }]);\n\n    return Shepherd_modal;\n  }(SvelteComponent);\n\n  var Shepherd = new Evented();\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n\n  var Tour = /*#__PURE__*/function (_Evented2) {\n    _inherits(Tour, _Evented2);\n\n    var _super11 = _createSuper(Tour);\n\n    /**\n     * @param {Object} options The options for the tour\n     * @param {boolean} options.confirmCancel If true, will issue a `window.confirm` before cancelling\n     * @param {string} options.confirmCancelMessage The message to display in the confirm dialog\n     * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n     * set to false.\n     * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n     * unless this is explicitly set to false.\n     * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n     * If not set, the steps will be appended to `document.body`.\n     * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n     * If not set, the modal will be appended to `document.body`.\n     * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property -- which is also set on the `body` element as the `data-shepherd-active-tour` attribute\n     * whenever the tour becomes active.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n    function Tour(options) {\n      var _this16;\n\n      _classCallCheck(this, Tour);\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      _this16 = _super11.call(this, options);\n      autoBind(_assertThisInitialized(_this16));\n      var defaultTourOptions = {\n        exitOnEsc: true,\n        keyboardNavigation: true\n      };\n      _this16.options = Object.assign({}, defaultTourOptions, options);\n      _this16.classPrefix = normalizePrefix(_this16.options.classPrefix);\n      _this16.steps = [];\n\n      _this16.addSteps(_this16.options.steps); // Pass these events onto the global Shepherd object\n\n\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this16.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this16);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n\n      _this16._setTourID();\n\n      return _possibleConstructorReturn(_this16, _assertThisInitialized(_this16));\n    }\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Step} options An object containing step options or a Step instance\n     * @param {number} index The optional index to insert the step at. If undefined, the step\n     * is added to the end of the array.\n     * @return {Step} The newly added step\n     */\n\n\n    _createClass(Tour, [{\n      key: \"addStep\",\n      value: function addStep(options, index) {\n        var step = options;\n\n        if (!(step instanceof Step)) {\n          step = new Step(this, step);\n        } else {\n          step.tour = this;\n        }\n\n        if (!isUndefined(index)) {\n          this.steps.splice(index, 0, step);\n        } else {\n          this.steps.push(step);\n        }\n\n        return step;\n      }\n      /**\n       * Add multiple steps to the tour\n       * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n       */\n\n    }, {\n      key: \"addSteps\",\n      value: function addSteps(steps) {\n        var _this17 = this;\n\n        if (Array.isArray(steps)) {\n          steps.forEach(function (step) {\n            _this17.addStep(step);\n          });\n        }\n\n        return this;\n      }\n      /**\n       * Go to the previous step in the tour\n       */\n\n    }, {\n      key: \"back\",\n      value: function back() {\n        var index = this.steps.indexOf(this.currentStep);\n        this.show(index - 1, false);\n      }\n      /**\n       * Calls _done() triggering the 'cancel' event\n       * If `confirmCancel` is true, will show a window.confirm before cancelling\n       */\n\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        if (this.options.confirmCancel) {\n          var cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n          var stopTour = window.confirm(cancelMessage);\n\n          if (stopTour) {\n            this._done('cancel');\n          }\n        } else {\n          this._done('cancel');\n        }\n      }\n      /**\n       * Calls _done() triggering the `complete` event\n       */\n\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this._done('complete');\n      }\n      /**\n       * Gets the step from a given id\n       * @param {Number|String} id The id of the step to retrieve\n       * @return {Step} The step corresponding to the `id`\n       */\n\n    }, {\n      key: \"getById\",\n      value: function getById(id) {\n        return this.steps.find(function (step) {\n          return step.id === id;\n        });\n      }\n      /**\n       * Gets the current step\n       * @returns {Step|null}\n       */\n\n    }, {\n      key: \"getCurrentStep\",\n      value: function getCurrentStep() {\n        return this.currentStep;\n      }\n      /**\n       * Hide the current step\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var currentStep = this.getCurrentStep();\n\n        if (currentStep) {\n          return currentStep.hide();\n        }\n      }\n      /**\n       * Check if the tour is active\n       * @return {boolean}\n       */\n\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return Shepherd.activeTour === this;\n      }\n      /**\n       * Go to the next step in the tour\n       * If we are at the end, call `complete`\n       */\n\n    }, {\n      key: \"next\",\n      value: function next() {\n        var index = this.steps.indexOf(this.currentStep);\n\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          this.show(index + 1, true);\n        }\n      }\n      /**\n       * Removes the step from the tour\n       * @param {String} name The id for the step to remove\n       */\n\n    }, {\n      key: \"removeStep\",\n      value: function removeStep(name) {\n        var _this18 = this;\n\n        var current = this.getCurrentStep(); // Find the step, destroy it and remove it from this.steps\n\n        this.steps.some(function (step, i) {\n          if (step.id === name) {\n            if (step.isOpen()) {\n              step.hide();\n            }\n\n            step.destroy();\n\n            _this18.steps.splice(i, 1);\n\n            return true;\n          }\n        });\n\n        if (current && current.id === name) {\n          this.currentStep = undefined; // If we have steps left, show the first one, otherwise just cancel the tour\n\n          this.steps.length ? this.show(0) : this.cancel();\n        }\n      }\n      /**\n       * Show a specific step in the tour\n       * @param {Number|String} key The key to look up the step by\n       * @param {Boolean} forward True if we are going forward, false if backward\n       */\n\n    }, {\n      key: \"show\",\n      value: function show(key, forward) {\n        if (key === void 0) {\n          key = 0;\n        }\n\n        if (forward === void 0) {\n          forward = true;\n        }\n\n        var step = isString(key) ? this.getById(key) : this.steps[key];\n\n        if (step) {\n          this._updateStateBeforeShow();\n\n          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn(); // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n\n          if (shouldSkipStep) {\n            this._skipStep(step, forward);\n          } else {\n            this.trigger('show', {\n              step: step,\n              previous: this.currentStep\n            });\n            this.currentStep = step;\n            step.show();\n          }\n        }\n      }\n      /**\n       * Start the tour\n       */\n\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.trigger('start'); // Save the focused element before the tour opens\n\n        this.focusedElBeforeOpen = document.activeElement;\n        this.currentStep = null;\n\n        this._setupModal();\n\n        this._setupActiveTour();\n\n        this.next();\n      }\n      /**\n       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n       * @param {String} event The event name to trigger\n       * @private\n       */\n\n    }, {\n      key: \"_done\",\n      value: function _done(event) {\n        var index = this.steps.indexOf(this.currentStep);\n\n        if (Array.isArray(this.steps)) {\n          this.steps.forEach(function (step) {\n            return step.destroy();\n          });\n        }\n\n        cleanupSteps(this);\n        this.trigger(event, {\n          index: index\n        });\n        Shepherd.activeTour = null;\n        this.trigger('inactive', {\n          tour: this\n        });\n\n        if (this.modal) {\n          this.modal.hide();\n        }\n\n        if (event === 'cancel' || event === 'complete') {\n          if (this.modal) {\n            var modalContainer = document.querySelector('.shepherd-modal-overlay-container');\n\n            if (modalContainer) {\n              modalContainer.remove();\n            }\n          }\n        } // Focus the element that was focused before the tour started\n\n\n        if (isHTMLElement$1(this.focusedElBeforeOpen)) {\n          this.focusedElBeforeOpen.focus();\n        }\n      }\n      /**\n       * Make this tour \"active\"\n       * @private\n       */\n\n    }, {\n      key: \"_setupActiveTour\",\n      value: function _setupActiveTour() {\n        this.trigger('active', {\n          tour: this\n        });\n        Shepherd.activeTour = this;\n      }\n      /**\n       * _setupModal create the modal container and instance\n       * @private\n       */\n\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        this.modal = new Shepherd_modal({\n          target: this.options.modalContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            styles: this.styles\n          }\n        });\n      }\n      /**\n       * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n       * @param {Step} step The step to skip\n       * @param {Boolean} forward True if we are going forward, false if backward\n       * @private\n       */\n\n    }, {\n      key: \"_skipStep\",\n      value: function _skipStep(step, forward) {\n        var index = this.steps.indexOf(step);\n\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          var nextIndex = forward ? index + 1 : index - 1;\n          this.show(nextIndex, forward);\n        }\n      }\n      /**\n       * Before showing, hide the current step and if the tour is not\n       * already active, call `this._setupActiveTour`.\n       * @private\n       */\n\n    }, {\n      key: \"_updateStateBeforeShow\",\n      value: function _updateStateBeforeShow() {\n        if (this.currentStep) {\n          this.currentStep.hide();\n        }\n\n        if (!this.isActive()) {\n          this._setupActiveTour();\n        }\n      }\n      /**\n       * Sets this.id to `${tourName}--${uuid}`\n       * @private\n       */\n\n    }, {\n      key: \"_setTourID\",\n      value: function _setTourID() {\n        var tourName = this.options.tourName || 'tour';\n        this.id = \"\".concat(tourName, \"--\").concat(uuid());\n      }\n    }]);\n\n    return Tour;\n  }(Evented);\n\n  Object.assign(Shepherd, {\n    Tour: Tour,\n    Step: Step\n  });\n  return Shepherd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hlcGhlcmQuanMvZGlzdC9qcy9zaGVwaGVyZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFFQSxJQUFJQSxpQkFBaUIsR0FBRyxTQUFTQSxpQkFBVCxDQUEyQkMsS0FBM0IsRUFBa0M7SUFDekQsT0FBT0MsZUFBZSxDQUFDRCxLQUFELENBQWZDLElBQ0gsQ0FBQ0MsU0FBUyxDQUFDRixLQUFELENBRGQ7RUFERDs7RUFLQSxTQUFTQyxlQUFULENBQXlCRCxLQUF6QixFQUFnQztJQUMvQixPQUFPLENBQUMsQ0FBQ0EsS0FBRixJQUFXLFFBQU9BLEtBQVAsTUFBaUIsUUFBbkM7RUFDQTs7RUFFRCxTQUFTRSxTQUFULENBQW1CRixLQUFuQixFQUEwQjtJQUN6QixJQUFJRyxXQUFXLEdBQUdDLE1BQU0sQ0FBQ0MsU0FBUEQsQ0FBaUJFLFFBQWpCRixDQUEwQkcsSUFBMUJILENBQStCSixLQUEvQkksQ0FBbEI7SUFFQSxPQUFPRCxXQUFXLEtBQUssaUJBQWhCQSxJQUNIQSxXQUFXLEtBQUssZUFEYkEsSUFFSEssY0FBYyxDQUFDUixLQUFELENBRmxCO0VBR0E7OztFQUdELElBQUlTLFlBQVksR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDQSxNQUFNLENBQUNDLEdBQTFEO0VBQ0EsSUFBSUMsa0JBQWtCLEdBQUdILFlBQVksR0FBR0MsTUFBTSxDQUFDQyxHQUFQRCxDQUFXLGVBQVhBLENBQUgsR0FBaUMsTUFBdEU7O0VBRUEsU0FBU0YsY0FBVCxDQUF3QlIsS0FBeEIsRUFBK0I7SUFDOUIsT0FBT0EsS0FBSyxDQUFDYSxRQUFOYixLQUFtQlksa0JBQTFCO0VBQ0E7O0VBRUQsU0FBU0UsV0FBVCxDQUFxQkMsR0FBckIsRUFBMEI7SUFDekIsT0FBT0MsS0FBSyxDQUFDQyxPQUFORCxDQUFjRCxHQUFkQyxJQUFxQixFQUFyQkEsR0FBMEIsRUFB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RUQ7QUFDRjtBQUNBO0FBQ0E7Ozs7YUFDRXJCLHNCQUFhO1FBQ1gsSUFBTXlCLFFBQVEsR0FBRyxLQUFLNTJCLE9BQUwsQ0FBYTQyQixRQUFiLElBQXlCLE1BQTFDO1FBRUEsS0FBS3RLLEVBQUwsYUFBYXNLLFFBQWIsZUFBMEI5VSxJQUFJLEVBQTlCO01BQ0Q7Ozs7SUE5V3VCOWU7O0VDaEIxQi9ELE1BQU0sQ0FBQ3dKLE1BQVB4SixDQUFjNDFCLFFBQWQ1MUIsRUFBd0I7SUFBRTYxQixJQUFGLEVBQUVBLElBQUY7SUFBUW5FO0VBQVIsQ0FBeEIxeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvY2pzLmpzPzVhZDEiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vc3JjL2pzL3V0aWxzL3R5cGUtY2hlY2suanM/MWZkMyIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9zcmMvanMvZXZlbnRlZC5qcz85NzNkIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL3NyYy9qcy91dGlscy9hdXRvLWJpbmQuanM/N2IxNiIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9zcmMvanMvdXRpbHMvYmluZC5qcz9hNTE1Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanM/NDY5NyIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qcz85MDYwIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcz85YTk0Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanM/N2NmOCIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcz8xMmViIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcz8xNTdkIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcz8zYjhjIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcz9kZDE0Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanM/NzgwMyIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcz81ODEwIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanM/MDkwOCIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcz8zN2Q0Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcz8zODQ4Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanM/ZTA4OSIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanM/NTgyYSIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcz81ZDBiIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzP2QwOTMiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanM/ZDA3ZiIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcz84MGY1Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzPzU0MTEiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXJyb3cuanM/ZDEzMCIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcz9jMDFmIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanM/NjM5MSIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcz83OTM1Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanM/YTAwNiIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzP2Y4MWUiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzPzhhNzAiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcz82NmQzIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFZpZXdwb3J0UmVjdC5qcz9kN2ZlIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcz8zMzFlIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzPzc4NjMiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0U2Nyb2xsUGFyZW50LmpzP2EzMmEiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanM/NmY1OSIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanM/OWMzOSIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanM/ZDE2ZCIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzPzRlNzUiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcz9iNTM0Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanM/MmVhMSIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzP2RiNDgiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcz9hYjk3Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL29mZnNldC5qcz9jMzY5Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanM/NTgwMSIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanM/ZDhjNyIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanM/Zjk4ZSIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRIVE1MRWxlbWVudFNjcm9sbC5qcz9iN2U2Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanM/NjZjZiIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzP2RkMmEiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qcz9jZmFiIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanM/YjgwYiIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzP2IwNjkiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanM/YTkwMCIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcz81MTVlIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL3NyYy9qcy91dGlscy9wb3BwZXItb3B0aW9ucy5qcz9jNjliIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL3NyYy9qcy91dGlscy9nZW5lcmFsLmpzP2I0MmQiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9pbnRlcm5hbC9pbmRleC5tanM/MDRmNyIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1idXR0b24uc3ZlbHRlPzc4YzUiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtZm9vdGVyLnN2ZWx0ZT9hZjQ3Iiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWNhbmNlbC1pY29uLnN2ZWx0ZT83OWMxIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLXRpdGxlLnN2ZWx0ZT9jYWMyIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWhlYWRlci5zdmVsdGU/MmYyNyIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC10ZXh0LnN2ZWx0ZT9hY2VmIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWNvbnRlbnQuc3ZlbHRlP2YwN2UiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtZWxlbWVudC5zdmVsdGU/YjU4NiIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9ub2RlX21vZHVsZXMvc21vb3Roc2Nyb2xsLXBvbHlmaWxsL2Rpc3Qvc21vb3Roc2Nyb2xsLmpzP2U2YzgiLCJ3ZWJwYWNrOi8vZnJlc3QvLi4vLi4vc3JjL2pzL3N0ZXAuanM/YWQ4ZCIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9zcmMvanMvdXRpbHMvY2xlYW51cC5qcz82ZGNhIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL3NyYy9qcy91dGlscy9vdmVybGF5LXBhdGguanM/Y2Q1MyIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1tb2RhbC5zdmVsdGU/ZjU0YiIsIndlYnBhY2s6Ly9mcmVzdC8uLi8uLi9zcmMvanMvdG91ci5qcz8zOTUxIiwid2VicGFjazovL2ZyZXN0Ly4uLy4uL3NyYy9qcy9zaGVwaGVyZC5qcz81MTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHQmJiAhaXNTcGVjaWFsKHZhbHVlKVxufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cblx0cmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHR8fCBpc1JlYWN0RWxlbWVudCh2YWx1ZSlcbn1cblxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcblxuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbn1cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdHJldHVybiAob3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkpXG5cdFx0PyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9ucylcblx0XHQ6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9ucylcblx0fSlcbn1cblxuZnVuY3Rpb24gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcblx0aWYgKCFvcHRpb25zLmN1c3RvbU1lcmdlKSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHR9XG5cdHZhciBjdXN0b21NZXJnZSA9IG9wdGlvbnMuY3VzdG9tTWVyZ2Uoa2V5KTtcblx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0PyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5wcm9wZXJ0eUlzRW51bWVyYWJsZShzeW1ib2wpXG5cdFx0fSlcblx0XHQ6IFtdXG59XG5cbmZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLmNvbmNhdChnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpXG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5SXNPbk9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHByb3BlcnR5IGluIG9iamVjdFxuXHR9IGNhdGNoKF8pIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG4vLyBQcm90ZWN0cyBmcm9tIHByb3RvdHlwZSBwb2lzb25pbmcgYW5kIHVuZXhwZWN0ZWQgbWVyZ2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuZnVuY3Rpb24gcHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkge1xuXHRyZXR1cm4gcHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAvLyBQcm9wZXJ0aWVzIGFyZSBzYWZlIHRvIG1lcmdlIGlmIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHRhcmdldCB5ZXQsXG5cdFx0JiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkgLy8gdW5zYWZlIGlmIHRoZXkgZXhpc3QgdXAgdGhlIHByb3RvdHlwZSBjaGFpbixcblx0XHRcdCYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwga2V5KSkgLy8gYW5kIGFsc28gdW5zYWZlIGlmIHRoZXkncmUgbm9uZW51bWVyYWJsZS5cbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcblx0XHRnZXRLZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cblx0Z2V0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRpZiAocHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcblx0b3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCA9IG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgfHwgaXNNZXJnZWFibGVPYmplY3Q7XG5cdC8vIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIGlzIGFkZGVkIHRvIGBvcHRpb25zYCBzbyB0aGF0IGN1c3RvbSBhcnJheU1lcmdlKClcblx0Ly8gaW1wbGVtZW50YXRpb25zIGNhbiB1c2UgaXQuIFRoZSBjYWxsZXIgbWF5IG5vdCByZXBsYWNlIGl0LlxuXHRvcHRpb25zLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQ7XG5cblx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdHZhciB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuXHR2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cblx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9ucykge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXknKVxuXHR9XG5cblx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zKVxuXHR9LCB7fSlcbn07XG5cbnZhciBkZWVwbWVyZ2VfMSA9IGRlZXBtZXJnZTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwbWVyZ2VfMTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgRWxlbWVudGAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhbiBFbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBIVE1MRWxlbWVudGAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhbiBIVE1MRWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBhcmFtIHRvIGNoZWNrIGlmIGl0IGlzIGEgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuL3V0aWxzL3R5cGUtY2hlY2snO1xuXG5leHBvcnQgY2xhc3MgRXZlbnRlZCB7XG4gIG9uKGV2ZW50LCBoYW5kbGVyLCBjdHgsIG9uY2UgPSBmYWxzZSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSkge1xuICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iaW5kaW5nc1tldmVudF0pKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5wdXNoKHsgaGFuZGxlciwgY3R4LCBvbmNlIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvbmNlKGV2ZW50LCBoYW5kbGVyLCBjdHgpIHtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgaGFuZGxlciwgY3R4LCB0cnVlKTtcbiAgfVxuXG4gIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSB8fCBpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzW2V2ZW50XSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSkge1xuICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbZXZlbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5mb3JFYWNoKChiaW5kaW5nLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoYmluZGluZy5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0cmlnZ2VyKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSAmJiB0aGlzLmJpbmRpbmdzW2V2ZW50XSkge1xuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uZm9yRWFjaCgoYmluZGluZywgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIGhhbmRsZXIsIG9uY2UgfSA9IGJpbmRpbmc7XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IGN0eCB8fCB0aGlzO1xuXG4gICAgICAgIGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncyk7XG5cbiAgICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiLyoqXG4gKiBCaW5kcyBhbGwgdGhlIG1ldGhvZHMgb24gYSBKUyBDbGFzcyB0byB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzLlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYXV0by1iaW5kXG4gKiBAcGFyYW0ge29iamVjdH0gc2VsZiBUaGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgY2xhc3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b0JpbmQoc2VsZikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc2VsZi5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbCA9IHNlbGZba2V5XTtcbiAgICBpZiAoa2V5ICE9PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNlbGZba2V5XSA9IHZhbC5iaW5kKHNlbGYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuL3R5cGUtY2hlY2snO1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIGhhbmRsZXIgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBhZHZhbmNlIHRoZSB0b3VyXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfc2V0dXBBZHZhbmNlT25IYW5kbGVyKHNlbGVjdG9yLCBzdGVwKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICBpZiAoc3RlcC5pc09wZW4oKSkge1xuICAgICAgY29uc3QgdGFyZ2V0SXNFbCA9IHN0ZXAuZWwgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gc3RlcC5lbDtcbiAgICAgIGNvbnN0IHRhcmdldElzU2VsZWN0b3IgPVxuICAgICAgICAhaXNVbmRlZmluZWQoc2VsZWN0b3IpICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQubWF0Y2hlcyhzZWxlY3Rvcik7XG5cbiAgICAgIGlmICh0YXJnZXRJc1NlbGVjdG9yIHx8IHRhcmdldElzRWwpIHtcbiAgICAgICAgc3RlcC50b3VyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQmluZCB0aGUgZXZlbnQgaGFuZGxlciBmb3IgYWR2YW5jZU9uXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRBZHZhbmNlKHN0ZXApIHtcbiAgLy8gQW4gZW1wdHkgc2VsZWN0b3IgbWF0Y2hlcyB0aGUgc3RlcCBlbGVtZW50XG4gIGNvbnN0IHsgZXZlbnQsIHNlbGVjdG9yIH0gPSBzdGVwLm9wdGlvbnMuYWR2YW5jZU9uIHx8IHt9O1xuICBpZiAoZXZlbnQpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gX3NldHVwQWR2YW5jZU9uSGFuZGxlcihzZWxlY3Rvciwgc3RlcCk7XG5cbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBhbHNvIGJpbmQvdW5iaW5kIG9uIHNob3cvaGlkZVxuICAgIGxldCBlbDtcbiAgICB0cnkge1xuICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoc2VsZWN0b3IpICYmICFlbCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBObyBlbGVtZW50IHdhcyBmb3VuZCBmb3IgdGhlIHNlbGVjdG9yIHN1cHBsaWVkIHRvIGFkdmFuY2VPbjogJHtzZWxlY3Rvcn1gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgc3RlcC5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICBzdGVwLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcbiAgICAgICdhZHZhbmNlT24gd2FzIGRlZmluZWQsIGJ1dCBubyBldmVudCBuYW1lIHdhcyBwYXNzZWQuJ1xuICAgICk7XG4gIH1cbn1cbiIsImV4cG9ydCB2YXIgdG9wID0gJ3RvcCc7XG5leHBvcnQgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuZXhwb3J0IHZhciByaWdodCA9ICdyaWdodCc7XG5leHBvcnQgdmFyIGxlZnQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIGF1dG8gPSAnYXV0byc7XG5leHBvcnQgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5leHBvcnQgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbmV4cG9ydCB2YXIgZW5kID0gJ2VuZCc7XG5leHBvcnQgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuZXhwb3J0IHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbmV4cG9ydCB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCB2YXIgcmVhZCA9ICdyZWFkJztcbmV4cG9ydCB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbmV4cG9ydCB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCB2YXIgbWFpbiA9ICdtYWluJztcbmV4cG9ydCB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuZXhwb3J0IHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgdmFyIHdyaXRlID0gJ3dyaXRlJztcbmV4cG9ydCB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59IiwiZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDsiLCJpbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpICYmIGluY2x1ZGVTY2FsZSkge1xuICAgIHZhciBvZmZzZXRIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB2YXIgb2Zmc2V0V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoOyAvLyBEbyBub3QgYXR0ZW1wdCB0byBkaXZpZGUgYnkgMCwgb3RoZXJ3aXNlIHdlIGdldCBgSW5maW5pdHlgIGFzIHNjYWxlXG4gICAgLy8gRmFsbGJhY2sgdG8gMSBpbiBjYXNlIGJvdGggdmFsdWVzIGFyZSBgMGBcblxuICAgIGlmIChvZmZzZXRXaWR0aCA+IDApIHtcbiAgICAgIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gb2Zmc2V0V2lkdGggfHwgMTtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0SGVpZ2h0ID4gMCkge1xuICAgICAgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gb2Zmc2V0SGVpZ2h0IHx8IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAvIHNjYWxlWCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0IC8gc2NhbGVZLFxuICAgIHRvcDogcmVjdC50b3AgLyBzY2FsZVksXG4gICAgcmlnaHQ6IHJlY3QucmlnaHQgLyBzY2FsZVgsXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSAvIHNjYWxlWSxcbiAgICBsZWZ0OiByZWN0LmxlZnQgLyBzY2FsZVgsXG4gICAgeDogcmVjdC5sZWZ0IC8gc2NhbGVYLFxuICAgIHk6IHJlY3QudG9wIC8gc2NhbGVZXG4gIH07XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjsgLy8gUmV0dXJucyB0aGUgbGF5b3V0IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LiBMYXlvdXRcbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHZhciBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXG5cbiAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgLSBoZWlnaHQpIDw9IDEpIHtcbiAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufSIsImltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn0iLCJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTE7XG4gIHZhciBpc0lFID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgIT09IC0xO1xuXG4gIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGVsZW1lbnRDc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgaWYgKGlzU2hhZG93Um9vdChjdXJyZW50Tm9kZSkpIHtcbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmhvc3Q7XG4gIH1cblxuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG5cbiAgICBpZiAoY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufSIsImltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuL21hdGguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBtYXRoTWF4KG1pbiwgbWF0aE1pbih2YWx1ZSwgbWF4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gIHZhciB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59IiwiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4gfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1wiO1xuaW1wb3J0IHsgbGVmdCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB0b3AsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNIVE1MRWxlbWVudChhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50IChub3QgYW4gU1ZHRWxlbWVudCkuJywgJ1RvIHVzZSBhbiBTVkcgYXJyb3csIHdyYXAgaXQgaW4gYW4gSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMnLCAndGhlIGFycm93LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgbW9kaWZpZXJcXCdzIGBlbGVtZW50YCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIHBvcHBlcicsICdlbGVtZW50LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXG4gICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcbiAgdmFyIF9vZmZzZXRzJHggPSBvZmZzZXRzLngsXG4gICAgICB4ID0gX29mZnNldHMkeCA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHgsXG4gICAgICBfb2Zmc2V0cyR5ID0gb2Zmc2V0cy55LFxuICAgICAgeSA9IF9vZmZzZXRzJHkgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR5O1xuXG4gIHZhciBfcmVmMyA9IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjMueDtcbiAgeSA9IF9yZWYzLnk7XG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgdmFyIG9mZnNldFkgPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcbiAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCAocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWCA9IHJpZ2h0O1xuICAgICAgdmFyIG9mZnNldFggPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF07XG4gICAgICB4IC09IG9mZnNldFggLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICB2YXIgX3JlZjQgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUih7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmNC54O1xuICB5ID0gX3JlZjQueTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xuICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNS5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XG5cbiAgICBpZiAoYWRhcHRpdmUgJiYgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMDtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcnLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgJ1xcblxcbicsICdEaXNhYmxlIHRoZSBcImNvbXB1dGVTdHlsZXNcIiBtb2RpZmllclxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJywgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsICdvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuJywgJ1xcblxcbicsICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLCAnZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gIH07XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGFkYXB0aXZlOiBmYWxzZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwidmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDsgLy8gTkI6IFRoaXMgaXNuJ3Qgc3VwcG9ydGVkIG9uIGlPUyA8PSAxMi4gSWYgdGhlIGtleWJvYXJkIGlzIG9wZW4sIHRoZSBwb3BwZXJcbiAgLy8gY2FuIGJlIG9ic2N1cmVkIHVuZGVybmVhdGggaXQuXG4gIC8vIEFsc28sIGBodG1sLmNsaWVudEhlaWdodGAgYWRkcyB0aGUgYm90dG9tIGJhciBoZWlnaHQgaW4gU2FmYXJpIGlPUywgZXZlblxuICAvLyBpZiBpdCBpc24ndCBvcGVuLCBzbyBpZiB0aGlzIGlzbid0IGF2YWlsYWJsZSwgdGhlIHBvcHBlciB3aWxsIGJlIGRldGVjdGVkXG4gIC8vIHRvIG92ZXJmbG93IHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiB0b28gZWFybHkuXG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7IC8vIFVzZXMgTGF5b3V0IFZpZXdwb3J0IChsaWtlIENocm9tZTsgU2FmYXJpIGRvZXMgbm90IGN1cnJlbnRseSlcbiAgICAvLyBJbiBDaHJvbWUsIGl0IHJldHVybnMgYSB2YWx1ZSB2ZXJ5IGNsb3NlIHRvIDAgKCsvLSkgYnV0IGNvbnRhaW5zIHJvdW5kaW5nXG4gICAgLy8gZXJyb3JzIGR1ZSB0byBmbG9hdGluZyBwb2ludCBudW1iZXJzLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIHByZWNpc2lvbi5cbiAgICAvLyBTYWZhcmkgcmV0dXJucyBhIG51bWJlciA8PSAwLCB1c3VhbGx5IDwgLTEgd2hlbiBwaW5jaC16b29tZWRcbiAgICAvLyBGZWF0dXJlIGRldGVjdGlvbiBmYWlscyBpbiBtb2JpbGUgZW11bGF0aW9uIG1vZGUgaW4gQ2hyb21lLlxuICAgIC8vIE1hdGguYWJzKHdpbi5pbm5lcldpZHRoIC8gdmlzdWFsVmlld3BvcnQuc2NhbGUgLSB2aXN1YWxWaWV3cG9ydC53aWR0aCkgPFxuICAgIC8vIDAuMDAxXG4gICAgLy8gRmFsbGJhY2sgaGVyZTogXCJOb3QgU2FmYXJpXCIgdXNlckFnZW50XG5cbiAgICBpZiAoIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSxcbiAgICB5OiB5XG4gIH07XG59IiwiaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgeyBtYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIHZhciBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xuICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5IHx8IGh0bWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XG5cbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59IiwiaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn0iLCJpbXBvcnQgZ2V0U2Nyb2xsUGFyZW50IGZyb20gXCIuL2dldFNjcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuLypcbmdpdmVuIGEgRE9NIGVsZW1lbnQsIHJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2Nyb2xsIHBhcmVudHMsIHVwIHRoZSBsaXN0IG9mIGFuY2Vzb3JzXG51bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xudG8sIGJlY2F1c2UgaWYgYW55IG9mIHRoZXNlIHBhcmVudCBlbGVtZW50cyBzY3JvbGwsIHdlJ2xsIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZVxucmVmZXJlbmNlIGVsZW1lbnQncyBwb3NpdGlvbi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG5cbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gKChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSk7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59IiwiaW1wb3J0IHsgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWaWV3cG9ydFJlY3QgZnJvbSBcIi4vZ2V0Vmlld3BvcnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRSZWN0IGZyb20gXCIuL2dldERvY3VtZW50UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4vY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4uL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IG1heCwgbWluIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcbiAgcmVjdC50b3AgPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICByZWN0LmxlZnQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3Qud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnggPSByZWN0LmxlZnQ7XG4gIHJlY3QueSA9IHJlY3QudG9wO1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxuLy8gYGluaXRpYWxgXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xuICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcblxuXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XG4gIH0pO1xufSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBwYXJlbnRzXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSIsImltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iLCJpbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdmFyaWF0aW9uUGxhY2VtZW50cywgYmFzZVBsYWNlbWVudHMsIHBsYWNlbWVudHMgYXMgYWxsUGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IGFsbFBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcbiAgdmFyIHBsYWNlbWVudHMgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XG4gIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xuICB9KTtcblxuICBpZiAoYWxsb3dlZFBsYWNlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogVGhlIGBhbGxvd2VkQXV0b1BsYWNlbWVudHNgIG9wdGlvbiBkaWQgbm90IGFsbG93IGFueScsICdwbGFjZW1lbnRzLiBFbnN1cmUgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbiBtYXRjaGVzIHRoZSB2YXJpYXRpb24nLCAnb2YgdGhlIGFsbG93ZWQgcGxhY2VtZW50cy4nLCAnRm9yIGV4YW1wbGUsIFwiYXV0b1wiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFwiYm90dG9tLXN0YXJ0XCIuJywgJ1VzZSBcImF1dG8tc3RhcnRcIiBpbnN0ZWFkLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG5cblxuICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgYm90dG9tLCB0b3AsIHN0YXJ0LCByaWdodCwgbGVmdCwgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7XG4gICAgX3NraXA6IGZhbHNlXG4gIH1cbn07IiwiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59OyIsImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gXCIuLi91dGlscy9nZXRBbHRBeGlzLmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4sIHdpdGhpbk1heENsYW1wIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4uL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuaW1wb3J0IHsgbWluIGFzIG1hdGhNaW4sIG1heCBhcyBtYXRoTWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcbiAgICBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZVxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkO1xuXG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCA9IG9mZnNldCAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICB2YXIgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW21haW5BeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJCA6IDA7XG4gICAgdmFyIHRldGhlck1pbiA9IG9mZnNldCArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IG9mZnNldCArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG4gICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heCk7XG4gICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDI7XG5cbiAgICB2YXIgX21haW5TaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IHRvcCA6IGxlZnQ7XG5cbiAgICB2YXIgX2FsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICB2YXIgX2xlbiA9IGFsdEF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHZhciBfbWluID0gX29mZnNldCArIG92ZXJmbG93W19tYWluU2lkZV07XG5cbiAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICB2YXIgaXNPcmlnaW5TaWRlID0gW3RvcCwgbGVmdF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICB2YXIgX29mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkMiA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbYWx0QXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIDogMDtcblxuICAgIHZhciBfdGV0aGVyTWluID0gaXNPcmlnaW5TaWRlID8gX21pbiA6IF9vZmZzZXQgLSByZWZlcmVuY2VSZWN0W19sZW5dIC0gcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXM7XG5cbiAgICB2YXIgX3RldGhlck1heCA9IGlzT3JpZ2luU2lkZSA/IF9vZmZzZXQgKyByZWZlcmVuY2VSZWN0W19sZW5dICsgcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXMgOiBfbWF4O1xuXG4gICAgdmFyIF9wcmV2ZW50ZWRPZmZzZXQgPSB0ZXRoZXIgJiYgaXNPcmlnaW5TaWRlID8gd2l0aGluTWF4Q2xhbXAoX3RldGhlck1pbiwgX29mZnNldCwgX3RldGhlck1heCkgOiB3aXRoaW4odGV0aGVyID8gX3RldGhlck1pbiA6IF9taW4sIF9vZmZzZXQsIHRldGhlciA/IF90ZXRoZXJNYXggOiBfbWF4KTtcblxuICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0SFRNTEVsZW1lbnRTY3JvbGwgZnJvbSBcIi4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldE5vZGVTY3JvbGwgZnJvbSBcIi4vZ2V0Tm9kZVNjcm9sbC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSIsImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcIi4vdXRpbHMvZGVib3VuY2UuanNcIjtcbmltcG9ydCB2YWxpZGF0ZU1vZGlmaWVycyBmcm9tIFwiLi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IHVuaXF1ZUJ5IGZyb20gXCIuL3V0aWxzL3VuaXF1ZUJ5LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi9lbnVtcy5qc1wiO1xudmFyIElOVkFMSURfRUxFTUVOVF9FUlJPUiA9ICdQb3BwZXI6IEludmFsaWQgcmVmZXJlbmNlIG9yIHBvcHBlciBhcmd1bWVudCBwcm92aWRlZC4gVGhleSBtdXN0IGJlIGVpdGhlciBhIERPTSBlbGVtZW50IG9yIHZpcnR1YWwgZWxlbWVudC4nO1xudmFyIElORklOSVRFX0xPT1BfRVJST1IgPSAnUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC4nO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pOyAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbW9kaWZpZXJzIHNvIHRoYXQgdGhlIGNvbnN1bWVyIHdpbGwgZ2V0IHdhcm5lZFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSB1bmlxdWVCeShbXS5jb25jYXQob3JkZXJlZE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpO1xuXG4gICAgICAgICAgaWYgKGdldEJhc2VQbGFjZW1lbnQoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICAgICAgICB2YXIgZmxpcE1vZGlmaWVyID0gc3RhdGUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSAnZmxpcCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmbGlwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsICdwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuJ10uam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBvcHBlciksXG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCxcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luTGVmdDsgLy8gV2Ugbm8gbG9uZ2VyIHRha2UgaW50byBhY2NvdW50IGBtYXJnaW5zYCBvbiB0aGUgcG9wcGVyLCBhbmQgaXQgY2FuXG4gICAgICAgICAgLy8gY2F1c2UgYnVncyB3aXRoIHBvc2l0aW9uaW5nLCBzbyB3ZSdsbCB3YXJuIHRoZSBjb25zdW1lclxuXG5cbiAgICAgICAgICBpZiAoW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZShmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXJnaW4pO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgJ2JldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LicsICdUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzJywgJ3RoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgJywgJ21vZGlmaWVycy4nXS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChfX2RlYnVnX2xvb3BzX18gPiAxMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgICAgICBfcmVmMyRvcHRpb25zID0gX3JlZjMub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmMyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuZXhwb3J0IHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgZGV0ZWN0T3ZlcmZsb3cgfTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyIsImZ1bmN0aW9uIF9nZXRDZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIoKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgICAgIGZuKHsgc3RhdGUgfSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgIGlmIChuYW1lICE9PSAncG9wcGVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgbGVmdDogJzUwJScsXG4gICAgICAgICAgICB0b3A6ICc1MCUnLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpJ1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGFkYXB0aXZlOiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtb2RpZmllciBmb3IgcG9wcGVyIHRoYXQgd2lsbCBoZWxwIGZvY3VzIHRoZSBlbGVtZW50IGFmdGVyIGl0IGhhc1xuICogYmVlbiByZW5kZXJlZFxuICpcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZm9jdXMgYWZ0ZXIgcmVuZGVyIG1vZGlmaWVyIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUZvY3VzQWZ0ZXJSZW5kZXJNb2RpZmllcihzdGVwKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2ZvY3VzQWZ0ZXJSZW5kZXInLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgcGhhc2U6ICdhZnRlcldyaXRlJyxcbiAgICBmbigpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoc3RlcC5lbCkge1xuICAgICAgICAgIGNvbnN0IGZvY3VzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc3RlcC5lbC5mb2N1cyhmb2N1c09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIGFycmF5IG9mIG9wdGlvbnMgZm9yIGEgdG9vbHRpcCB0aGF0IGRvZXNuJ3QgaGF2ZSBhXG4gKiB0YXJnZXQgZWxlbWVudCBpbiB0aGUgRE9NIC0tIGFuZCB0aHVzIGlzIHBvc2l0aW9uZWQgaW4gdGhlIGNlbnRlclxuICogb2YgdGhlIHZpZXdcbiAqXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGZpbmFsIFBvcHBlciBvcHRpb25zIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUNlbnRlcmVkUG9wcGVyKHN0ZXApIHtcbiAgY29uc3QgY2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyID0gX2dldENlbnRlcmVkU3R5bGVQb3BwZXJNb2RpZmllcigpO1xuXG4gIGxldCBwb3BwZXJPcHRpb25zID0ge1xuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgc3RyYXRlZ3k6ICdmaXhlZCcsXG4gICAgbW9kaWZpZXJzOiBbZ2VuZXJhdGVGb2N1c0FmdGVyUmVuZGVyTW9kaWZpZXIoc3RlcCldXG4gIH07XG5cbiAgcG9wcGVyT3B0aW9ucyA9IHtcbiAgICAuLi5wb3BwZXJPcHRpb25zLFxuICAgIG1vZGlmaWVyczogQXJyYXkuZnJvbShcbiAgICAgIG5ldyBTZXQoWy4uLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzLCAuLi5jZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXJdKVxuICAgIClcbiAgfTtcblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cbiIsImltcG9ydCB7IGNyZWF0ZVBvcHBlciB9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nIH0gZnJvbSAnLi90eXBlLWNoZWNrJztcbmltcG9ydCB7IG1ha2VDZW50ZXJlZFBvcHBlciwgZ2VuZXJhdGVGb2N1c0FmdGVyUmVuZGVyTW9kaWZpZXIgfSBmcm9tICcuL3BvcHBlci1vcHRpb25zJztcblxuLyoqXG4gKiBFbnN1cmUgY2xhc3MgcHJlZml4IGVuZHMgaW4gYC1gXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gcHJlcGVuZCB0byB0aGUgY2xhc3MgbmFtZXMgZ2VuZXJhdGVkIGJ5IG5hbm8tY3NzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcmVmaXggZW5kaW5nIGluIGAtYFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUHJlZml4KHByZWZpeCkge1xuICBpZiAoIWlzU3RyaW5nKHByZWZpeCkgfHwgcHJlZml4ID09PSAnJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBwcmVmaXguY2hhckF0KHByZWZpeC5sZW5ndGggLSAxKSAhPT0gJy0nID8gYCR7cHJlZml4fS1gIDogcHJlZml4O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIGF0dGFjaFRvIG9wdGlvbnMsIGNvbnZlcnRpbmcgZWxlbWVudCBvcHRpb24gdmFsdWUgdG8gYSBxdWFsaWZpZWQgSFRNTEVsZW1lbnQuXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHt7fXx7ZWxlbWVudCwgb259fVxuICogYGVsZW1lbnRgIGlzIGEgcXVhbGlmaWVkIEhUTUwgRWxlbWVudFxuICogYG9uYCBpcyBhIHN0cmluZyBwb3NpdGlvbiB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBdHRhY2hUbyhzdGVwKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBzdGVwLm9wdGlvbnMuYXR0YWNoVG8gfHwge307XG4gIGNvbnN0IHJldHVybk9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICBpZiAoaXNGdW5jdGlvbihyZXR1cm5PcHRzLmVsZW1lbnQpKSB7XG4gICAgLy8gQmluZCB0aGUgY2FsbGJhY2sgdG8gc3RlcCBzbyB0aGF0IGl0IGhhcyBhY2Nlc3MgdG8gdGhlIG9iamVjdCwgdG8gZW5hYmxlIHJ1bm5pbmcgYWRkaXRpb25hbCBsb2dpY1xuICAgIHJldHVybk9wdHMuZWxlbWVudCA9IHJldHVybk9wdHMuZWxlbWVudC5jYWxsKHN0ZXApO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKHJldHVybk9wdHMuZWxlbWVudCkpIHtcbiAgICAvLyBDYW4ndCBvdmVycmlkZSB0aGUgZWxlbWVudCBpbiB1c2VyIG9wdHMgcmVmZXJlbmNlIGJlY2F1c2Ugd2UgY2FuJ3RcbiAgICAvLyBndWFyYW50ZWUgdGhhdCB0aGUgZWxlbWVudCB3aWxsIGV4aXN0IGluIHRoZSBmdXR1cmUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybk9wdHMuZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocmV0dXJuT3B0cy5lbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIGlmICghcmV0dXJuT3B0cy5lbGVtZW50KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgVGhlIGVsZW1lbnQgZm9yIHRoaXMgU2hlcGhlcmQgc3RlcCB3YXMgbm90IGZvdW5kICR7b3B0aW9ucy5lbGVtZW50fWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVybk9wdHM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzdGVwIHNob3VsZCBiZSBjZW50ZXJlZCBvciBub3QuIERvZXMgbm90IHRyaWdnZXIgYXR0YWNoVG8uZWxlbWVudCBldmFsdWF0aW9uLCBtYWtpbmcgaXQgYSBwdXJlXG4gKiBhbHRlcm5hdGl2ZSBmb3IgdGhlIGRlcHJlY2F0ZWQgc3RlcC5pc0NlbnRlcmVkKCkgbWV0aG9kLlxuICogQHBhcmFtIHJlc29sdmVkQXR0YWNoVG9PcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZENlbnRlclN0ZXAocmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMpIHtcbiAgaWYgKHJlc29sdmVkQXR0YWNoVG9PcHRpb25zID09PSB1bmRlZmluZWQgfHwgcmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIFxuICByZXR1cm4gIXJlc29sdmVkQXR0YWNoVG9PcHRpb25zLmVsZW1lbnQgfHwgIXJlc29sdmVkQXR0YWNoVG9PcHRpb25zLm9uO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgb3B0aW9ucyBmb3IgdGhlIHRvb2x0aXAgYW5kIGluaXRpYWxpemVzXG4gKiBgc3RlcC50b29sdGlwYCBhcyBhIFBvcHBlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBUb29sdGlwKHN0ZXApIHtcbiAgaWYgKHN0ZXAudG9vbHRpcCkge1xuICAgIHN0ZXAudG9vbHRpcC5kZXN0cm95KCk7XG4gIH1cblxuICBjb25zdCBhdHRhY2hUb09wdGlvbnMgPSBzdGVwLl9nZXRSZXNvbHZlZEF0dGFjaFRvT3B0aW9ucygpO1xuXG4gIGxldCB0YXJnZXQgPSBhdHRhY2hUb09wdGlvbnMuZWxlbWVudDtcbiAgY29uc3QgcG9wcGVyT3B0aW9ucyA9IGdldFBvcHBlck9wdGlvbnMoYXR0YWNoVG9PcHRpb25zLCBzdGVwKTtcblxuICBpZiAoc2hvdWxkQ2VudGVyU3RlcChhdHRhY2hUb09wdGlvbnMpKSB7XG4gICAgdGFyZ2V0ID0gZG9jdW1lbnQuYm9keTtcbiAgICBjb25zdCBjb250ZW50ID0gc3RlcC5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuZ2V0RWxlbWVudCgpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnc2hlcGhlcmQtY2VudGVyZWQnKTtcbiAgfVxuXG4gIHN0ZXAudG9vbHRpcCA9IGNyZWF0ZVBvcHBlcih0YXJnZXQsIHN0ZXAuZWwsIHBvcHBlck9wdGlvbnMpO1xuICBzdGVwLnRhcmdldCA9IGF0dGFjaFRvT3B0aW9ucy5lbGVtZW50O1xuXG4gIHJldHVybiBwb3BwZXJPcHRpb25zO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHVuaXF1ZSBpZCBmb3Igc3RlcHMsIHRvdXJzLCBtb2RhbHMsIGV0Y1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgbGV0IGQgPSBEYXRlLm5vdygpO1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgIGNvbnN0IHIgPSAoZCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDA7XG4gICAgZCA9IE1hdGguZmxvb3IoZCAvIDE2KTtcbiAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBgUG9wcGVyYCBvcHRpb25zIGZyb20gYSBzZXQgb2YgYmFzZSBgYXR0YWNoVG9gIG9wdGlvbnNcbiAqIEBwYXJhbSBhdHRhY2hUb09wdGlvbnNcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvcHBlck9wdGlvbnMoYXR0YWNoVG9PcHRpb25zLCBzdGVwKSB7XG4gIGxldCBwb3BwZXJPcHRpb25zID0ge1xuICAgIG1vZGlmaWVyczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGFsdEF4aXM6IHRydWUsXG4gICAgICAgICAgdGV0aGVyOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVGb2N1c0FmdGVyUmVuZGVyTW9kaWZpZXIoc3RlcClcbiAgICBdLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG4gIH07XG5cbiAgaWYgKHNob3VsZENlbnRlclN0ZXAoYXR0YWNoVG9PcHRpb25zKSkge1xuICAgIHBvcHBlck9wdGlvbnMgPSBtYWtlQ2VudGVyZWRQb3BwZXIoc3RlcCk7XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT3B0aW9ucy5wbGFjZW1lbnQgPSBhdHRhY2hUb09wdGlvbnMub247XG4gIH1cblxuICBjb25zdCBkZWZhdWx0U3RlcE9wdGlvbnMgPVxuICAgIHN0ZXAudG91ciAmJiBzdGVwLnRvdXIub3B0aW9ucyAmJiBzdGVwLnRvdXIub3B0aW9ucy5kZWZhdWx0U3RlcE9wdGlvbnM7XG5cbiAgaWYgKGRlZmF1bHRTdGVwT3B0aW9ucykge1xuICAgIHBvcHBlck9wdGlvbnMgPSBfbWVyZ2VNb2RpZmllcnMoZGVmYXVsdFN0ZXBPcHRpb25zLCBwb3BwZXJPcHRpb25zKTtcbiAgfVxuXG4gIHBvcHBlck9wdGlvbnMgPSBfbWVyZ2VNb2RpZmllcnMoc3RlcC5vcHRpb25zLCBwb3BwZXJPcHRpb25zKTtcblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cblxuZnVuY3Rpb24gX21lcmdlTW9kaWZpZXJzKHN0ZXBPcHRpb25zLCBwb3BwZXJPcHRpb25zKSB7XG4gIGlmIChzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zKSB7XG4gICAgbGV0IG1lcmdlZFBvcHBlck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICBwb3BwZXJPcHRpb25zLFxuICAgICAgc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9uc1xuICAgICk7XG5cbiAgICBpZiAoXG4gICAgICBzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zLm1vZGlmaWVycyAmJlxuICAgICAgc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9ucy5tb2RpZmllcnMubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgY29uc3QgbmFtZXMgPSBzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zLm1vZGlmaWVycy5tYXAoKG1vZCkgPT4gbW9kLm5hbWUpO1xuICAgICAgY29uc3QgZmlsdGVyZWRNb2RpZmllcnMgPSBwb3BwZXJPcHRpb25zLm1vZGlmaWVycy5maWx0ZXIoXG4gICAgICAgIChtb2QpID0+ICFuYW1lcy5pbmNsdWRlcyhtb2QubmFtZSlcbiAgICAgICk7XG5cbiAgICAgIG1lcmdlZFBvcHBlck9wdGlvbnMubW9kaWZpZXJzID0gQXJyYXkuZnJvbShcbiAgICAgICAgbmV3IFNldChbLi4uZmlsdGVyZWRNb2RpZmllcnMsIC4uLnN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzXSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZFBvcHBlck9wdGlvbnM7XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cbiIsImZ1bmN0aW9uIG5vb3AoKSB7IH1cbmNvbnN0IGlkZW50aXR5ID0geCA9PiB4O1xuZnVuY3Rpb24gYXNzaWduKHRhciwgc3JjKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGZvciAoY29uc3QgayBpbiBzcmMpXG4gICAgICAgIHRhcltrXSA9IHNyY1trXTtcbiAgICByZXR1cm4gdGFyO1xufVxuZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuICAgIGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcbiAgICAgICAgbG9jOiB7IGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhciB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJ1bihmbikge1xuICAgIHJldHVybiBmbigpO1xufVxuZnVuY3Rpb24gYmxhbmtfb2JqZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcbiAgICBmbnMuZm9yRWFjaChydW4pO1xufVxuZnVuY3Rpb24gaXNfZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8ICgoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKTtcbn1cbmxldCBzcmNfdXJsX2VxdWFsX2FuY2hvcjtcbmZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuICAgIGlmICghc3JjX3VybF9lcXVhbF9hbmNob3IpIHtcbiAgICAgICAgc3JjX3VybF9lcXVhbF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgfVxuICAgIHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIGVsZW1lbnRfc3JjID09PSBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmO1xufVxuZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYjtcbn1cbmZ1bmN0aW9uIGlzX2VtcHR5KG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG4gICAgaWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcbiAgICBpZiAoc3RvcmUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgY29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG5mdW5jdGlvbiBnZXRfc3RvcmVfdmFsdWUoc3RvcmUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgc3Vic2NyaWJlKHN0b3JlLCBfID0+IHZhbHVlID0gXykoKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgcmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm5cbiAgICAgICAgPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSlcbiAgICAgICAgOiAkJHNjb3BlLmN0eDtcbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb25bMl0gJiYgZm4pIHtcbiAgICAgICAgY29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcbiAgICAgICAgaWYgKCQkc2NvcGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxldHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gW107XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFtpXSA9ICQkc2NvcGUuZGlydHlbaV0gfCBsZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJCRzY29wZS5kaXJ0eSB8IGxldHM7XG4gICAgfVxuICAgIHJldHVybiAkJHNjb3BlLmRpcnR5O1xufVxuZnVuY3Rpb24gdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgaWYgKHNsb3RfY2hhbmdlcykge1xuICAgICAgICBjb25zdCBzbG90X2NvbnRleHQgPSBnZXRfc2xvdF9jb250ZXh0KHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbiAgICAgICAgc2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdChzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4sIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBjb25zdCBzbG90X2NoYW5nZXMgPSBnZXRfc2xvdF9jaGFuZ2VzKHNsb3RfZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4pO1xuICAgIHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG59XG5mdW5jdGlvbiBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUoJCRzY29wZSkge1xuICAgIGlmICgkJHNjb3BlLmN0eC5sZW5ndGggPiAzMikge1xuICAgICAgICBjb25zdCBkaXJ0eSA9IFtdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAkJHNjb3BlLmN0eC5sZW5ndGggLyAzMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGlydHlbaV0gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMocHJvcHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmIChrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN1bHRba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9yZXN0X3Byb3BzKHByb3BzLCBrZXlzKSB7XG4gICAgY29uc3QgcmVzdCA9IHt9O1xuICAgIGtleXMgPSBuZXcgU2V0KGtleXMpO1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKCFrZXlzLmhhcyhrKSAmJiBrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGxldCByYW4gPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHJhbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgZm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9zdG9yZV92YWx1ZShzdG9yZSwgcmV0LCB2YWx1ZSkge1xuICAgIHN0b3JlLnNldCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5mdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcbiAgICByZXR1cm4gYWN0aW9uX3Jlc3VsdCAmJiBpc19mdW5jdGlvbihhY3Rpb25fcmVzdWx0LmRlc3Ryb3kpID8gYWN0aW9uX3Jlc3VsdC5kZXN0cm95IDogbm9vcDtcbn1cblxuY29uc3QgaXNfY2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgbm93ID0gaXNfY2xpZW50XG4gICAgPyAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5sZXQgcmFmID0gaXNfY2xpZW50ID8gY2IgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSA6IG5vb3A7XG4vLyB1c2VkIGludGVybmFsbHkgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHNldF9ub3coZm4pIHtcbiAgICBub3cgPSBmbjtcbn1cbmZ1bmN0aW9uIHNldF9yYWYoZm4pIHtcbiAgICByYWYgPSBmbjtcbn1cblxuY29uc3QgdGFza3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBydW5fdGFza3Mobm93KSB7XG4gICAgdGFza3MuZm9yRWFjaCh0YXNrID0+IHtcbiAgICAgICAgaWYgKCF0YXNrLmMobm93KSkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICAgICAgdGFzay5mKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGFza3Muc2l6ZSAhPT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG59XG4vKipcbiAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkhXG4gKi9cbmZ1bmN0aW9uIGNsZWFyX2xvb3BzKCkge1xuICAgIHRhc2tzLmNsZWFyKCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGFzayB0aGF0IHJ1bnMgb24gZWFjaCByYWYgZnJhbWVcbiAqIHVudGlsIGl0IHJldHVybnMgYSBmYWxzeSB2YWx1ZSBvciBpcyBhYm9ydGVkXG4gKi9cbmZ1bmN0aW9uIGxvb3AoY2FsbGJhY2spIHtcbiAgICBsZXQgdGFzaztcbiAgICBpZiAodGFza3Muc2l6ZSA9PT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZTogbmV3IFByb21pc2UoZnVsZmlsbCA9PiB7XG4gICAgICAgICAgICB0YXNrcy5hZGQodGFzayA9IHsgYzogY2FsbGJhY2ssIGY6IGZ1bGZpbGwgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICBhYm9ydCgpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIFRyYWNrIHdoaWNoIG5vZGVzIGFyZSBjbGFpbWVkIGR1cmluZyBoeWRyYXRpb24uIFVuY2xhaW1lZCBub2RlcyBjYW4gdGhlbiBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuLy8gYXQgdGhlIGVuZCBvZiBoeWRyYXRpb24gd2l0aG91dCB0b3VjaGluZyB0aGUgcmVtYWluaW5nIG5vZGVzLlxubGV0IGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc3RhcnRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IHRydWU7XG59XG5mdW5jdGlvbiBlbmRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gdXBwZXJfYm91bmQobG93LCBoaWdoLCBrZXksIHZhbHVlKSB7XG4gICAgLy8gUmV0dXJuIGZpcnN0IGluZGV4IG9mIHZhbHVlIGxhcmdlciB0aGFuIGlucHV0IHZhbHVlIGluIHRoZSByYW5nZSBbbG93LCBoaWdoKVxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIGNvbnN0IG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG4gICAgICAgIGlmIChrZXkobWlkKSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbn1cbmZ1bmN0aW9uIGluaXRfaHlkcmF0ZSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmh5ZHJhdGVfaW5pdClcbiAgICAgICAgcmV0dXJuO1xuICAgIHRhcmdldC5oeWRyYXRlX2luaXQgPSB0cnVlO1xuICAgIC8vIFdlIGtub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBjbGFpbV9vcmRlciB2YWx1ZXMgc2luY2UgdGhlIHVuY2xhaW1lZCBoYXZlIGJlZW4gZGV0YWNoZWQgaWYgdGFyZ2V0IGlzIG5vdCA8aGVhZD5cbiAgICBsZXQgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGROb2RlcztcbiAgICAvLyBJZiB0YXJnZXQgaXMgPGhlYWQ+LCB0aGVyZSBtYXkgYmUgY2hpbGRyZW4gd2l0aG91dCBjbGFpbV9vcmRlclxuICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdIRUFEJykge1xuICAgICAgICBjb25zdCBteUNoaWxkcmVuID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBteUNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4gPSBteUNoaWxkcmVuO1xuICAgIH1cbiAgICAvKlxuICAgICogUmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseS5cbiAgICAqIFdlIGNhbiByZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5IGJ5IGZpbmRpbmcgdGhlIGxvbmdlc3Qgc3Vic2VxdWVuY2Ugb2ZcbiAgICAqIG5vZGVzIHRoYXQgYXJlIGFscmVhZHkgY2xhaW1lZCBpbiBvcmRlciBhbmQgb25seSBtb3ZpbmcgdGhlIHJlc3QuIFRoZSBsb25nZXN0XG4gICAgKiBzdWJzZXF1ZW5jZSBzdWJzZXF1ZW5jZSBvZiBub2RlcyB0aGF0IGFyZSBjbGFpbWVkIGluIG9yZGVyIGNhbiBiZSBmb3VuZCBieVxuICAgICogY29tcHV0aW5nIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgLmNsYWltX29yZGVyIHZhbHVlcy5cbiAgICAqXG4gICAgKiBUaGlzIGFsZ29yaXRobSBpcyBvcHRpbWFsIGluIGdlbmVyYXRpbmcgdGhlIGxlYXN0IGFtb3VudCBvZiByZW9yZGVyIG9wZXJhdGlvbnNcbiAgICAqIHBvc3NpYmxlLlxuICAgICpcbiAgICAqIFByb29mOlxuICAgICogV2Uga25vdyB0aGF0LCBnaXZlbiBhIHNldCBvZiByZW9yZGVyaW5nIG9wZXJhdGlvbnMsIHRoZSBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlXG4gICAgKiBhbHdheXMgZm9ybSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLCBzaW5jZSB0aGV5IGRvIG5vdCBtb3ZlIGFtb25nIGVhY2ggb3RoZXJcbiAgICAqIG1lYW5pbmcgdGhhdCB0aGV5IG11c3QgYmUgYWxyZWFkeSBvcmRlcmVkIGFtb25nIGVhY2ggb3RoZXIuIFRodXMsIHRoZSBtYXhpbWFsXG4gICAgKiBzZXQgb2Ygbm9kZXMgdGhhdCBkbyBub3QgbW92ZSBmb3JtIGEgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLlxuICAgICovXG4gICAgLy8gQ29tcHV0ZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2VcbiAgICAvLyBtOiBzdWJzZXF1ZW5jZSBsZW5ndGggaiA9PiBpbmRleCBrIG9mIHNtYWxsZXN0IHZhbHVlIHRoYXQgZW5kcyBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGxlbmd0aCBqXG4gICAgY29uc3QgbSA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCArIDEpO1xuICAgIC8vIFByZWRlY2Vzc29yIGluZGljZXMgKyAxXG4gICAgY29uc3QgcCA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgbVswXSA9IC0xO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBjaGlsZHJlbltpXS5jbGFpbV9vcmRlcjtcbiAgICAgICAgLy8gRmluZCB0aGUgbGFyZ2VzdCBzdWJzZXF1ZW5jZSBsZW5ndGggc3VjaCB0aGF0IGl0IGVuZHMgaW4gYSB2YWx1ZSBsZXNzIHRoYW4gb3VyIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgLy8gdXBwZXJfYm91bmQgcmV0dXJucyBmaXJzdCBncmVhdGVyIHZhbHVlLCBzbyB3ZSBzdWJ0cmFjdCBvbmVcbiAgICAgICAgLy8gd2l0aCBmYXN0IHBhdGggZm9yIHdoZW4gd2UgYXJlIG9uIHRoZSBjdXJyZW50IGxvbmdlc3Qgc3Vic2VxdWVuY2VcbiAgICAgICAgY29uc3Qgc2VxTGVuID0gKChsb25nZXN0ID4gMCAmJiBjaGlsZHJlblttW2xvbmdlc3RdXS5jbGFpbV9vcmRlciA8PSBjdXJyZW50KSA/IGxvbmdlc3QgKyAxIDogdXBwZXJfYm91bmQoMSwgbG9uZ2VzdCwgaWR4ID0+IGNoaWxkcmVuW21baWR4XV0uY2xhaW1fb3JkZXIsIGN1cnJlbnQpKSAtIDE7XG4gICAgICAgIHBbaV0gPSBtW3NlcUxlbl0gKyAxO1xuICAgICAgICBjb25zdCBuZXdMZW4gPSBzZXFMZW4gKyAxO1xuICAgICAgICAvLyBXZSBjYW4gZ3VhcmFudGVlIHRoYXQgY3VycmVudCBpcyB0aGUgc21hbGxlc3QgdmFsdWUuIE90aGVyd2lzZSwgd2Ugd291bGQgaGF2ZSBnZW5lcmF0ZWQgYSBsb25nZXIgc2VxdWVuY2UuXG4gICAgICAgIG1bbmV3TGVuXSA9IGk7XG4gICAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuZXdMZW4sIGxvbmdlc3QpO1xuICAgIH1cbiAgICAvLyBUaGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIG5vZGVzIChpbml0aWFsbHkgcmV2ZXJzZWQpXG4gICAgY29uc3QgbGlzID0gW107XG4gICAgLy8gVGhlIHJlc3Qgb2YgdGhlIG5vZGVzLCBub2RlcyB0aGF0IHdpbGwgYmUgbW92ZWRcbiAgICBjb25zdCB0b01vdmUgPSBbXTtcbiAgICBsZXQgbGFzdCA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgY3VyID0gbVtsb25nZXN0XSArIDE7IGN1ciAhPSAwOyBjdXIgPSBwW2N1ciAtIDFdKSB7XG4gICAgICAgIGxpcy5wdXNoKGNoaWxkcmVuW2N1ciAtIDFdKTtcbiAgICAgICAgZm9yICg7IGxhc3QgPj0gY3VyOyBsYXN0LS0pIHtcbiAgICAgICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0LS07XG4gICAgfVxuICAgIGZvciAoOyBsYXN0ID49IDA7IGxhc3QtLSkge1xuICAgICAgICB0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG4gICAgfVxuICAgIGxpcy5yZXZlcnNlKCk7XG4gICAgLy8gV2Ugc29ydCB0aGUgbm9kZXMgYmVpbmcgbW92ZWQgdG8gZ3VhcmFudGVlIHRoYXQgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyIG1hdGNoZXMgdGhlIGNsYWltIG9yZGVyXG4gICAgdG9Nb3ZlLnNvcnQoKGEsIGIpID0+IGEuY2xhaW1fb3JkZXIgLSBiLmNsYWltX29yZGVyKTtcbiAgICAvLyBGaW5hbGx5LCB3ZSBtb3ZlIHRoZSBub2Rlc1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvTW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3aGlsZSAoaiA8IGxpcy5sZW5ndGggJiYgdG9Nb3ZlW2ldLmNsYWltX29yZGVyID49IGxpc1tqXS5jbGFpbV9vcmRlcikge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGogPCBsaXMubGVuZ3RoID8gbGlzW2pdIDogbnVsbDtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZSh0b01vdmVbaV0sIGFuY2hvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kKHRhcmdldCwgbm9kZSkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXModGFyZ2V0LCBzdHlsZV9zaGVldF9pZCwgc3R5bGVzKSB7XG4gICAgY29uc3QgYXBwZW5kX3N0eWxlc190byA9IGdldF9yb290X2Zvcl9zdHlsZSh0YXJnZXQpO1xuICAgIGlmICghYXBwZW5kX3N0eWxlc190by5nZXRFbGVtZW50QnlJZChzdHlsZV9zaGVldF9pZCkpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS5pZCA9IHN0eWxlX3NoZWV0X2lkO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHN0eWxlcztcbiAgICAgICAgYXBwZW5kX3N0eWxlc2hlZXQoYXBwZW5kX3N0eWxlc190bywgc3R5bGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldF9yb290X2Zvcl9zdHlsZShub2RlKSB7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgY29uc3Qgcm9vdCA9IG5vZGUuZ2V0Um9vdE5vZGUgPyBub2RlLmdldFJvb3ROb2RlKCkgOiBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5ob3N0KSB7XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSkge1xuICAgIGNvbnN0IHN0eWxlX2VsZW1lbnQgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgIGFwcGVuZF9zdHlsZXNoZWV0KGdldF9yb290X2Zvcl9zdHlsZShub2RlKSwgc3R5bGVfZWxlbWVudCk7XG4gICAgcmV0dXJuIHN0eWxlX2VsZW1lbnQuc2hlZXQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzaGVldChub2RlLCBzdHlsZSkge1xuICAgIGFwcGVuZChub2RlLmhlYWQgfHwgbm9kZSwgc3R5bGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nKSB7XG4gICAgICAgIGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuICAgICAgICBpZiAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQpIHx8ICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwpICYmICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnRFbGVtZW50ICE9PSB0YXJnZXQpKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuICAgICAgICB3aGlsZSAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQuY2xhaW1fb3JkZXIgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgIT09IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGluc2VydCBpZiB0aGUgb3JkZXJpbmcgb2YgdGhpcyBub2RlIHNob3VsZCBiZSBtb2RpZmllZCBvciB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRhcmdldFxuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCB8fCBub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGlmIChpc19oeWRyYXRpbmcgJiYgIWFuY2hvcikge1xuICAgICAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG4gICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gZGVzdHJveV9lYWNoKGl0ZXJhdGlvbnMsIGRldGFjaGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXRlcmF0aW9uc1tpXSlcbiAgICAgICAgICAgIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuZnVuY3Rpb24gZWxlbWVudF9pcyhuYW1lLCBpcykge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc19wcm9wKG9iaiwgaylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICYmIGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRhcmdldFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5mdW5jdGlvbiB0ZXh0KGRhdGEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5mdW5jdGlvbiBzcGFjZSgpIHtcbiAgICByZXR1cm4gdGV4dCgnICcpO1xufVxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRleHQoJycpO1xufVxuZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRfZGVmYXVsdChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0b3BfcHJvcGFnYXRpb24oZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VsZihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRydXN0ZWQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LmlzVHJ1c3RlZClcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSlcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZS5fX3Byb3RvX18pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5jc3NUZXh0ID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ19fdmFsdWUnKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0b3JzW2tleV0gJiYgZGVzY3JpcHRvcnNba2V5XS5zZXQpIHtcbiAgICAgICAgICAgIG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHByb3AgaW4gbm9kZSkge1xuICAgICAgICBub2RlW3Byb3BdID0gdHlwZW9mIG5vZGVbcHJvcF0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRyKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB4bGlua19hdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGdyb3VwW2ldLmNoZWNrZWQpXG4gICAgICAgICAgICB2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG4gICAgfVxuICAgIGlmICghY2hlY2tlZCkge1xuICAgICAgICB2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuZnVuY3Rpb24gdGltZV9yYW5nZXNfdG9fYXJyYXkocmFuZ2VzKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cbmZ1bmN0aW9uIGluaXRfY2xhaW1faW5mbyhub2Rlcykge1xuICAgIGlmIChub2Rlcy5jbGFpbV9pbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mbyA9IHsgbGFzdF9pbmRleDogMCwgdG90YWxfY2xhaW1lZDogMCB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsYWltX25vZGUobm9kZXMsIHByZWRpY2F0ZSwgcHJvY2Vzc05vZGUsIGNyZWF0ZU5vZGUsIGRvbnRVcGRhdGVMYXN0SW5kZXggPSBmYWxzZSkge1xuICAgIC8vIFRyeSB0byBmaW5kIG5vZGVzIGluIGFuIG9yZGVyIHN1Y2ggdGhhdCB3ZSBsZW5ndGhlbiB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG4gICAgaW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcbiAgICBjb25zdCByZXN1bHROb2RlID0gKCgpID0+IHtcbiAgICAgICAgLy8gV2UgZmlyc3QgdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCBhZnRlciB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgdHJ5IHRvIGZpbmQgb25lIGJlZm9yZVxuICAgICAgICAvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugc28gdGhhdCB3ZSBkb24ndCBnbyB0b28gZmFyIGJhY2tcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBzcGxpY2VkIGJlZm9yZSB0aGUgbGFzdF9pbmRleCwgd2UgZGVjcmVhc2UgaXRcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGNhbid0IGZpbmQgYW55IG1hdGNoaW5nIG5vZGUsIHdlIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUoKTtcbiAgICB9KSgpO1xuICAgIHJlc3VsdE5vZGUuY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG4gICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgcmV0dXJuIHJlc3VsdE5vZGU7XG59XG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZV9lbGVtZW50KSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVOYW1lID09PSBuYW1lLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqXTtcbiAgICAgICAgICAgIGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZW1vdmUucHVzaChhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlLmZvckVhY2godiA9PiBub2RlLnJlbW92ZUF0dHJpYnV0ZSh2KSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgKCkgPT4gY3JlYXRlX2VsZW1lbnQobmFtZSkpO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fc3ZnX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBzdmdfZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGFpbV90ZXh0KG5vZGVzLCBkYXRhKSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAzLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhU3RyID0gJycgKyBkYXRhO1xuICAgICAgICBpZiAobm9kZS5kYXRhLnN0YXJ0c1dpdGgoZGF0YVN0cikpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEubGVuZ3RoICE9PSBkYXRhU3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnNwbGl0VGV4dChkYXRhU3RyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSBkYXRhU3RyO1xuICAgICAgICB9XG4gICAgfSwgKCkgPT4gdGV4dChkYXRhKSwgdHJ1ZSAvLyBUZXh0IG5vZGVzIHNob3VsZCBub3QgdXBkYXRlIGxhc3QgaW5kZXggc2luY2UgaXQgaXMgbGlrZWx5IG5vdCB3b3J0aCBpdCB0byBlbGltaW5hdGUgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBhY3R1YWwgZWxlbWVudHNcbiAgICApO1xufVxuZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fdGV4dChub2RlcywgJyAnKTtcbn1cbmZ1bmN0aW9uIGZpbmRfY29tbWVudChub2RlcywgdGV4dCwgc3RhcnQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLyAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNsYWltX2h0bWxfdGFnKG5vZGVzLCBpc19zdmcpIHtcbiAgICAvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcbiAgICBjb25zdCBzdGFydF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX1NUQVJUJywgMCk7XG4gICAgY29uc3QgZW5kX2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfRU5EJywgc3RhcnRfaW5kZXgpO1xuICAgIGlmIChzdGFydF9pbmRleCA9PT0gZW5kX2luZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbih1bmRlZmluZWQsIGlzX3N2Zyk7XG4gICAgfVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgaHRtbF90YWdfbm9kZXMgPSBub2Rlcy5zcGxpY2Uoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzWzBdKTtcbiAgICBkZXRhY2goaHRtbF90YWdfbm9kZXNbaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMV0pO1xuICAgIGNvbnN0IGNsYWltZWRfbm9kZXMgPSBodG1sX3RhZ19ub2Rlcy5zbGljZSgxLCBodG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxKTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgY2xhaW1lZF9ub2Rlcykge1xuICAgICAgICBuLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGNsYWltZWRfbm9kZXMsIGlzX3N2Zyk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgIT09IGRhdGEpXG4gICAgICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF90eXBlKGlucHV0LCB0eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaW5wdXQudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3R5bGUobm9kZSwga2V5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgaWYgKG9wdGlvbi5fX3ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2Yob3B0aW9uLl9fdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF92YWx1ZShzZWxlY3QpIHtcbiAgICBjb25zdCBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKSB8fCBzZWxlY3Qub3B0aW9uc1swXTtcbiAgICByZXR1cm4gc2VsZWN0ZWRfb3B0aW9uICYmIHNlbGVjdGVkX29wdGlvbi5fX3ZhbHVlO1xufVxuZnVuY3Rpb24gc2VsZWN0X211bHRpcGxlX3ZhbHVlKHNlbGVjdCkge1xuICAgIHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgb3B0aW9uID0+IG9wdGlvbi5fX3ZhbHVlKTtcbn1cbi8vIHVuZm9ydHVuYXRlbHkgdGhpcyBjYW4ndCBiZSBhIGNvbnN0YW50IGFzIHRoYXQgd291bGRuJ3QgYmUgdHJlZS1zaGFrZWFibGVcbi8vIHNvIHdlIGNhY2hlIHRoZSByZXN1bHQgaW5zdGVhZFxubGV0IGNyb3Nzb3JpZ2luO1xuZnVuY3Rpb24gaXNfY3Jvc3NvcmlnaW4oKSB7XG4gICAgaWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3Jvc3NvcmlnaW4gPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdm9pZCB3aW5kb3cucGFyZW50LmRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY3Jvc3NvcmlnaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcm9zc29yaWdpbjtcbn1cbmZ1bmN0aW9uIGFkZF9yZXNpemVfbGlzdGVuZXIobm9kZSwgZm4pIHtcbiAgICBjb25zdCBjb21wdXRlZF9zdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKGNvbXB1dGVkX3N0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgY29uc3QgaWZyYW1lID0gZWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyAnICtcbiAgICAgICAgJ292ZXJmbG93OiBoaWRkZW47IGJvcmRlcjogMDsgb3BhY2l0eTogMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHotaW5kZXg6IC0xOycpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICBpZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICBjb25zdCBjcm9zc29yaWdpbiA9IGlzX2Nyb3Nzb3JpZ2luKCk7XG4gICAgbGV0IHVuc3Vic2NyaWJlO1xuICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICBpZnJhbWUuc3JjID0gXCJkYXRhOnRleHQvaHRtbCw8c2NyaXB0Pm9ucmVzaXplPWZ1bmN0aW9uKCl7cGFyZW50LnBvc3RNZXNzYWdlKDAsJyonKX08L3NjcmlwdD5cIjtcbiAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4od2luZG93LCAnbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKGlmcmFtZS5jb250ZW50V2luZG93LCAncmVzaXplJywgZm4pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBlbmQobm9kZSwgaWZyYW1lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5zdWJzY3JpYmUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoKGlmcmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhlbGVtZW50LCBuYW1lLCB0b2dnbGUpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdFt0b2dnbGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbn1cbmZ1bmN0aW9uIGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCk7XG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxdWVyeV9zZWxlY3Rvcl9hbGwoc2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuY2xhc3MgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoaXNfc3ZnID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5pc19zdmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc19zdmcgPSBpc19zdmc7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgfVxuICAgIG0oaHRtbCwgdGFyZ2V0LCBhbmNob3IgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19zdmcpXG4gICAgICAgICAgICAgICAgdGhpcy5lID0gc3ZnX2VsZW1lbnQodGFyZ2V0Lm5vZGVOYW1lKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmUgPSBlbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLnQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pKGFuY2hvcik7XG4gICAgfVxuICAgIGgoaHRtbCkge1xuICAgICAgICB0aGlzLmUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgdGhpcy5uID0gQXJyYXkuZnJvbSh0aGlzLmUuY2hpbGROb2Rlcyk7XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnQodGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcChodG1sKSB7XG4gICAgICAgIHRoaXMuZCgpO1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgICAgIHRoaXMuaSh0aGlzLmEpO1xuICAgIH1cbiAgICBkKCkge1xuICAgICAgICB0aGlzLm4uZm9yRWFjaChkZXRhY2gpO1xuICAgIH1cbn1cbmNsYXNzIEh0bWxUYWdIeWRyYXRpb24gZXh0ZW5kcyBIdG1sVGFnIHtcbiAgICBjb25zdHJ1Y3RvcihjbGFpbWVkX25vZGVzLCBpc19zdmcgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihpc19zdmcpO1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgICAgICB0aGlzLmwgPSBjbGFpbWVkX25vZGVzO1xuICAgIH1cbiAgICBjKGh0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMubCkge1xuICAgICAgICAgICAgdGhpcy5uID0gdGhpcy5sO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuYyhodG1sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpKGFuY2hvcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5zZXJ0X2h5ZHJhdGlvbih0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGF0dHJpYnV0ZV90b19vYmplY3QoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMoZWxlbWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIHJlc3VsdFtub2RlLnNsb3QgfHwgJ2RlZmF1bHQnXSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gZm9yIG11bHRpcGxlIGRvY3VtZW50cyBiZWNhdXNlIGEgU3ZlbHRlIGFwcGxpY2F0aW9uIGNvdWxkIGFsc28gY29udGFpbiBpZnJhbWVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8zNjI0XG5jb25zdCBtYW5hZ2VkX3N0eWxlcyA9IG5ldyBNYXAoKTtcbmxldCBhY3RpdmUgPSAwO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2gvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgbGV0IGhhc2ggPSA1MzgxO1xuICAgIGxldCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpIHtcbiAgICBjb25zdCBpbmZvID0geyBzdHlsZXNoZWV0OiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSwgcnVsZXM6IHt9IH07XG4gICAgbWFuYWdlZF9zdHlsZXMuc2V0KGRvYywgaW5mbyk7XG4gICAgcmV0dXJuIGluZm87XG59XG5mdW5jdGlvbiBjcmVhdGVfcnVsZShub2RlLCBhLCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2UsIGZuLCB1aWQgPSAwKSB7XG4gICAgY29uc3Qgc3RlcCA9IDE2LjY2NiAvIGR1cmF0aW9uO1xuICAgIGxldCBrZXlmcmFtZXMgPSAne1xcbic7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPD0gMTsgcCArPSBzdGVwKSB7XG4gICAgICAgIGNvbnN0IHQgPSBhICsgKGIgLSBhKSAqIGVhc2UocCk7XG4gICAgICAgIGtleWZyYW1lcyArPSBwICogMTAwICsgYCV7JHtmbih0LCAxIC0gdCl9fVxcbmA7XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBrZXlmcmFtZXMgKyBgMTAwJSB7JHtmbihiLCAxIC0gYil9fVxcbn1gO1xuICAgIGNvbnN0IG5hbWUgPSBgX19zdmVsdGVfJHtoYXNoKHJ1bGUpfV8ke3VpZH1gO1xuICAgIGNvbnN0IGRvYyA9IGdldF9yb290X2Zvcl9zdHlsZShub2RlKTtcbiAgICBjb25zdCB7IHN0eWxlc2hlZXQsIHJ1bGVzIH0gPSBtYW5hZ2VkX3N0eWxlcy5nZXQoZG9jKSB8fCBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKTtcbiAgICBpZiAoIXJ1bGVzW25hbWVdKSB7XG4gICAgICAgIHJ1bGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgc3R5bGVzaGVldC5pbnNlcnRSdWxlKGBAa2V5ZnJhbWVzICR7bmFtZX0gJHtydWxlfWAsIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG4gICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBgJHthbmltYXRpb24gPyBgJHthbmltYXRpb259LCBgIDogJyd9JHtuYW1lfSAke2R1cmF0aW9ufW1zIGxpbmVhciAke2RlbGF5fW1zIDEgYm90aGA7XG4gICAgYWN0aXZlICs9IDE7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBkZWxldGVfcnVsZShub2RlLCBuYW1lKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IG5leHQgPSBwcmV2aW91cy5maWx0ZXIobmFtZVxuICAgICAgICA/IGFuaW0gPT4gYW5pbS5pbmRleE9mKG5hbWUpIDwgMCAvLyByZW1vdmUgc3BlY2lmaWMgYW5pbWF0aW9uXG4gICAgICAgIDogYW5pbSA9PiBhbmltLmluZGV4T2YoJ19fc3ZlbHRlJykgPT09IC0xIC8vIHJlbW92ZSBhbGwgU3ZlbHRlIGFuaW1hdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IGRlbGV0ZWQgPSBwcmV2aW91cy5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcbiAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IG5leHQuam9pbignLCAnKTtcbiAgICAgICAgYWN0aXZlIC09IGRlbGV0ZWQ7XG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY2xlYXJfcnVsZXMoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhcl9ydWxlcygpIHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYW5hZ2VkX3N0eWxlcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzdHlsZXNoZWV0IH0gPSBpbmZvO1xuICAgICAgICAgICAgbGV0IGkgPSBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldC5kZWxldGVSdWxlKGkpO1xuICAgICAgICAgICAgaW5mby5ydWxlcyA9IHt9O1xuICAgICAgICB9KTtcbiAgICAgICAgbWFuYWdlZF9zdHlsZXMuY2xlYXIoKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2FuaW1hdGlvbihub2RlLCBmcm9tLCBmbiwgcGFyYW1zKSB7XG4gICAgaWYgKCFmcm9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGZyb20ubGVmdCA9PT0gdG8ubGVmdCAmJiBmcm9tLnJpZ2h0ID09PSB0by5yaWdodCAmJiBmcm9tLnRvcCA9PT0gdG8udG9wICYmIGZyb20uYm90dG9tID09PSB0by5ib3R0b20pXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIFxuICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogc2hvdWxkIHRoaXMgYmUgc2VwYXJhdGVkIGZyb20gZGVzdHJ1Y3R1cmluZz8gT3Igc3RhcnQvZW5kIGFkZGVkIHRvIHB1YmxpYyBhcGkgYW5kIGRvY3VtZW50YXRpb24/XG4gICAgc3RhcnQ6IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86XG4gICAgZW5kID0gc3RhcnRfdGltZSArIGR1cmF0aW9uLCB0aWNrID0gbm9vcCwgY3NzIH0gPSBmbihub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IG5hbWU7XG4gICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbGF5KSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgbmFtZSk7XG4gICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgbG9vcChub3cgPT4ge1xuICAgICAgICBpZiAoIXN0YXJ0ZWQgJiYgbm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkICYmIG5vdyA+PSBlbmQpIHtcbiAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBzdGFydF90aW1lO1xuICAgICAgICAgICAgY29uc3QgdCA9IDAgKyAxICogZWFzaW5nKHAgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBzdGFydCgpO1xuICAgIHRpY2soMCwgMSk7XG4gICAgcmV0dXJuIHN0b3A7XG59XG5mdW5jdGlvbiBmaXhfcG9zaXRpb24obm9kZSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoc3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgc3R5bGUucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzdHlsZTtcbiAgICAgICAgY29uc3QgYSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBub2RlLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZF90cmFuc2Zvcm0obm9kZSwgYSkge1xuICAgIGNvbnN0IGIgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChhLmxlZnQgIT09IGIubGVmdCB8fCBhLnRvcCAhPT0gYi50b3ApIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IGAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7YS5sZWZ0IC0gYi5sZWZ0fXB4LCAke2EudG9wIC0gYi50b3B9cHgpYDtcbiAgICB9XG59XG5cbmxldCBjdXJyZW50X2NvbXBvbmVudDtcbmZ1bmN0aW9uIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBjdXJyZW50X2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGdldF9jdXJyZW50X2NvbXBvbmVudCgpIHtcbiAgICBpZiAoIWN1cnJlbnRfY29tcG9uZW50KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbicpO1xuICAgIHJldHVybiBjdXJyZW50X2NvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmJlZm9yZV91cGRhdGUucHVzaChmbik7XG59XG5mdW5jdGlvbiBvbk1vdW50KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fbW91bnQucHVzaChmbik7XG59XG5mdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX2Rlc3Ryb3kucHVzaChmbik7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgcmV0dXJuICh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG4gICAgICAgICAgICAvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSB9KTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4ge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY29tcG9uZW50LCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LnNldChrZXksIGNvbnRleHQpO1xuICAgIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cbmZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0O1xufVxuZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnRcbi8vIHNob3J0aGFuZCBldmVudHMsIG9yIGlmIHdlIHdhbnQgdG8gaW1wbGVtZW50XG4vLyBhIHJlYWwgYnViYmxpbmcgbWVjaGFuaXNtXG5mdW5jdGlvbiBidWJibGUoY29tcG9uZW50LCBldmVudCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4gZm4uY2FsbCh0aGlzLCBldmVudCkpO1xuICAgIH1cbn1cblxuY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgcmVzb2x2ZWRfcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xubGV0IHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNjaGVkdWxlX3VwZGF0ZSgpIHtcbiAgICBpZiAoIXVwZGF0ZV9zY2hlZHVsZWQpIHtcbiAgICAgICAgdXBkYXRlX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGljaygpIHtcbiAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRfcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcbiAgICByZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWRkX2ZsdXNoX2NhbGxiYWNrKGZuKSB7XG4gICAgZmx1c2hfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuLy8gZmx1c2goKSBjYWxscyBjYWxsYmFja3MgaW4gdGhpcyBvcmRlcjpcbi8vIDEuIEFsbCBiZWZvcmVVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW5cbi8vIDIuIEFsbCBiaW5kOnRoaXMgY2FsbGJhY2tzLCBpbiByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIDMuIEFsbCBhZnRlclVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlbi4gRVhDRVBUXG4vLyAgICBmb3IgYWZ0ZXJVcGRhdGVzIGNhbGxlZCBkdXJpbmcgdGhlIGluaXRpYWwgb25Nb3VudCwgd2hpY2ggYXJlIGNhbGxlZCBpblxuLy8gICAgcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyBTaW5jZSBjYWxsYmFja3MgbWlnaHQgdXBkYXRlIGNvbXBvbmVudCB2YWx1ZXMsIHdoaWNoIGNvdWxkIHRyaWdnZXIgYW5vdGhlclxuLy8gY2FsbCB0byBmbHVzaCgpLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGd1YXJkIGFnYWluc3QgdGhpczpcbi8vIDEuIER1cmluZyBiZWZvcmVVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vICAgIGRpcnR5X2NvbXBvbmVudHMgYXJyYXkgYW5kIHdpbGwgY2F1c2UgYSByZWVudHJhbnQgY2FsbCB0byBmbHVzaCgpLiBCZWNhdXNlXG4vLyAgICB0aGUgZmx1c2ggaW5kZXggaXMga2VwdCBvdXRzaWRlIHRoZSBmdW5jdGlvbiwgdGhlIHJlZW50cmFudCBjYWxsIHdpbGwgcGlja1xuLy8gICAgdXAgd2hlcmUgdGhlIGVhcmxpZXIgY2FsbCBsZWZ0IG9mZiBhbmQgZ28gdGhyb3VnaCBhbGwgZGlydHkgY29tcG9uZW50cy4gVGhlXG4vLyAgICBjdXJyZW50X2NvbXBvbmVudCB2YWx1ZSBpcyBzYXZlZCBhbmQgcmVzdG9yZWQgc28gdGhhdCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbFxuLy8gICAgbm90IGludGVyZmVyZSB3aXRoIHRoZSBcInBhcmVudFwiIGZsdXNoKCkgY2FsbC5cbi8vIDIuIGJpbmQ6dGhpcyBjYWxsYmFja3MgY2Fubm90IHRyaWdnZXIgbmV3IGZsdXNoKCkgY2FsbHMuXG4vLyAzLiBEdXJpbmcgYWZ0ZXJVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBOT1QgaGF2ZSB0aGVpciBhZnRlclVwZGF0ZVxuLy8gICAgY2FsbGJhY2sgY2FsbGVkIGEgc2Vjb25kIHRpbWU7IHRoZSBzZWVuX2NhbGxiYWNrcyBzZXQsIG91dHNpZGUgdGhlIGZsdXNoKClcbi8vICAgIGZ1bmN0aW9uLCBndWFyYW50ZWVzIHRoaXMgYmVoYXZpb3IuXG5jb25zdCBzZWVuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbmxldCBmbHVzaGlkeCA9IDA7IC8vIERvICpub3QqIG1vdmUgdGhpcyBpbnNpZGUgdGhlIGZsdXNoKCkgZnVuY3Rpb25cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIGNvbnN0IHNhdmVkX2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIGRvIHtcbiAgICAgICAgLy8gZmlyc3QsIGNhbGwgYmVmb3JlVXBkYXRlIGZ1bmN0aW9uc1xuICAgICAgICAvLyBhbmQgdXBkYXRlIGNvbXBvbmVudHNcbiAgICAgICAgd2hpbGUgKGZsdXNoaWR4IDwgZGlydHlfY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbZmx1c2hpZHhdO1xuICAgICAgICAgICAgZmx1c2hpZHgrKztcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGNvbXBvbmVudC4kJCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIGZsdXNoaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgIGJpbmRpbmdfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgICAgIC8vIHRoZW4sIG9uY2UgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgY2FsbFxuICAgICAgICAvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcmVuZGVyX2NhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgIGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIC8vIC4uLnNvIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgbG9vcHNcbiAgICAgICAgICAgICAgICBzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIH0gd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKTtcbiAgICB3aGlsZSAoZmx1c2hfY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICBmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcbiAgICB9XG4gICAgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHNhdmVkX2NvbXBvbmVudCk7XG59XG5mdW5jdGlvbiB1cGRhdGUoJCQpIHtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgJCQudXBkYXRlKCk7XG4gICAgICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gJCQuZGlydHk7XG4gICAgICAgICQkLmRpcnR5ID0gWy0xXTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQucCgkJC5jdHgsIGRpcnR5KTtcbiAgICAgICAgJCQuYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG4gICAgfVxufVxuXG5sZXQgcHJvbWlzZTtcbmZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBkaXJlY3Rpb24sIGtpbmQpIHtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KGAke2RpcmVjdGlvbiA/ICdpbnRybycgOiAnb3V0cm8nfSR7a2luZH1gKSk7XG59XG5jb25zdCBvdXRyb2luZyA9IG5ldyBTZXQoKTtcbmxldCBvdXRyb3M7XG5mdW5jdGlvbiBncm91cF9vdXRyb3MoKSB7XG4gICAgb3V0cm9zID0ge1xuICAgICAgICByOiAwLFxuICAgICAgICBjOiBbXSxcbiAgICAgICAgcDogb3V0cm9zIC8vIHBhcmVudCBncm91cFxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja19vdXRyb3MoKSB7XG4gICAgaWYgKCFvdXRyb3Mucikge1xuICAgICAgICBydW5fYWxsKG91dHJvcy5jKTtcbiAgICB9XG4gICAgb3V0cm9zID0gb3V0cm9zLnA7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX2luKGJsb2NrLCBsb2NhbCkge1xuICAgIGlmIChibG9jayAmJiBibG9jay5pKSB7XG4gICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgIGJsb2NrLmkobG9jYWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25fb3V0KGJsb2NrLCBsb2NhbCwgZGV0YWNoLCBjYWxsYmFjaykge1xuICAgIGlmIChibG9jayAmJiBibG9jay5vKSB7XG4gICAgICAgIGlmIChvdXRyb2luZy5oYXMoYmxvY2spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdXRyb2luZy5hZGQoYmxvY2spO1xuICAgICAgICBvdXRyb3MuYy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgICAgICAgICBibG9jay5kKDEpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBibG9jay5vKGxvY2FsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG59XG5jb25zdCBudWxsX3RyYW5zaXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG5mdW5jdGlvbiBjcmVhdGVfaW5fdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgbGV0IHRhc2s7XG4gICAgbGV0IHVpZCA9IDA7XG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcywgdWlkKyspO1xuICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGlmICh0YXNrKVxuICAgICAgICAgICAgdGFzay5hYm9ydCgpO1xuICAgICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCB0cnVlLCAnc3RhcnQnKSk7XG4gICAgICAgIHRhc2sgPSBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oZ28pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBjb25zdCBncm91cCA9IG91dHJvcztcbiAgICBncm91cC5yICs9IDE7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDEsIDAsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcbiAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1ncm91cC5yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKGdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEgLSB0LCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbygpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmQocmVzZXQpIHtcbiAgICAgICAgICAgIGlmIChyZXNldCAmJiBjb25maWcudGljaykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy50aWNrKDEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zLCBpbnRybykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCB0ID0gaW50cm8gPyAwIDogMTtcbiAgICBsZXQgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGQgPSAocHJvZ3JhbS5iIC0gdCk7XG4gICAgICAgIGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYTogdCxcbiAgICAgICAgICAgIGI6IHByb2dyYW0uYixcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG4gICAgICAgICAgICBncm91cDogcHJvZ3JhbS5ncm91cFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbyhiKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB7XG4gICAgICAgICAgICBzdGFydDogbm93KCkgKyBkZWxheSxcbiAgICAgICAgICAgIGJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgcHJvZ3JhbS5ncm91cCA9IG91dHJvcztcbiAgICAgICAgICAgIG91dHJvcy5yICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG4gICAgICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgcnVubmluZ19wcm9ncmFtLmIsIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbiwgMCwgZWFzaW5nLCBjb25maWcuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0ID0gcnVubmluZ19wcm9ncmFtLmIsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50cm8g4oCUIHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cm8g4oCUIG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcnVuKGIpIHtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVfcHJvbWlzZShwcm9taXNlLCBpbmZvKSB7XG4gICAgY29uc3QgdG9rZW4gPSBpbmZvLnRva2VuID0ge307XG4gICAgZnVuY3Rpb24gdXBkYXRlKHR5cGUsIGluZGV4LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmZvLnRva2VuICE9PSB0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHZhbHVlO1xuICAgICAgICBsZXQgY2hpbGRfY3R4ID0gaW5mby5jdHg7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hpbGRfY3R4ID0gY2hpbGRfY3R4LnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZF9jdHhba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdHlwZSAmJiAoaW5mby5jdXJyZW50ID0gdHlwZSkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IG5lZWRzX2ZsdXNoID0gZmFsc2U7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5ibG9ja3MpIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXggJiYgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5ibG9ja3NbaV0gPT09IGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2NrLmQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgICAgIGJsb2NrLm0oaW5mby5tb3VudCgpLCBpbmZvLmFuY2hvcik7XG4gICAgICAgICAgICBuZWVkc19mbHVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5ibG9jayA9IGJsb2NrO1xuICAgICAgICBpZiAoaW5mby5ibG9ja3MpXG4gICAgICAgICAgICBpbmZvLmJsb2Nrc1tpbmRleF0gPSBibG9jaztcbiAgICAgICAgaWYgKG5lZWRzX2ZsdXNoKSB7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc19wcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRfY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgICAgIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8uY2F0Y2gsIDIsIGluZm8uZXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgICAgIGlmICghaW5mby5oYXNDYXRjaCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgd2UgcHJldmlvdXNseSBoYWQgYSB0aGVuL2NhdGNoIGJsb2NrLCBkZXN0cm95IGl0XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8ucGVuZGluZykge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8ucGVuZGluZywgMCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby50aGVuKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSBwcm9taXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2goaW5mbywgY3R4LCBkaXJ0eSkge1xuICAgIGNvbnN0IGNoaWxkX2N0eCA9IGN0eC5zbGljZSgpO1xuICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IGluZm87XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby50aGVuKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLnZhbHVlXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLmNhdGNoKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLmVycm9yXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpbmZvLmJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG59XG5cbmNvbnN0IGdsb2JhbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICA6IGdsb2JhbCk7XG5cbmZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmQoMSk7XG4gICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xufVxuZnVuY3Rpb24gb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiB1cGRhdGVfa2V5ZWRfZWFjaChvbGRfYmxvY2tzLCBkaXJ0eSwgZ2V0X2tleSwgZHluYW1pYywgY3R4LCBsaXN0LCBsb29rdXAsIG5vZGUsIGRlc3Ryb3ksIGNyZWF0ZV9lYWNoX2Jsb2NrLCBuZXh0LCBnZXRfY29udGV4dCkge1xuICAgIGxldCBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG4gICAgbGV0IG4gPSBsaXN0Lmxlbmd0aDtcbiAgICBsZXQgaSA9IG87XG4gICAgY29uc3Qgb2xkX2luZGV4ZXMgPSB7fTtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBvbGRfaW5kZXhlc1tvbGRfYmxvY2tzW2ldLmtleV0gPSBpO1xuICAgIGNvbnN0IG5ld19ibG9ja3MgPSBbXTtcbiAgICBjb25zdCBuZXdfbG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRlbHRhcyA9IG5ldyBNYXAoKTtcbiAgICBpID0gbjtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkX2N0eCA9IGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgICBibG9jayA9IGNyZWF0ZV9lYWNoX2Jsb2NrKGtleSwgY2hpbGRfY3R4KTtcbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xuICAgICAgICB9XG4gICAgICAgIG5ld19sb29rdXAuc2V0KGtleSwgbmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKTtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRfaW5kZXhlcylcbiAgICAgICAgICAgIGRlbHRhcy5zZXQoa2V5LCBNYXRoLmFicyhpIC0gb2xkX2luZGV4ZXNba2V5XSkpO1xuICAgIH1cbiAgICBjb25zdCB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZGlkX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gaW5zZXJ0KGJsb2NrKSB7XG4gICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICBibG9jay5tKG5vZGUsIG5leHQpO1xuICAgICAgICBsb29rdXAuc2V0KGJsb2NrLmtleSwgYmxvY2spO1xuICAgICAgICBuZXh0ID0gYmxvY2suZmlyc3Q7XG4gICAgICAgIG4tLTtcbiAgICB9XG4gICAgd2hpbGUgKG8gJiYgbikge1xuICAgICAgICBjb25zdCBuZXdfYmxvY2sgPSBuZXdfYmxvY2tzW24gLSAxXTtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvIC0gMV07XG4gICAgICAgIGNvbnN0IG5ld19rZXkgPSBuZXdfYmxvY2sua2V5O1xuICAgICAgICBjb25zdCBvbGRfa2V5ID0gb2xkX2Jsb2NrLmtleTtcbiAgICAgICAgaWYgKG5ld19ibG9jayA9PT0gb2xkX2Jsb2NrKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgICBuZXh0ID0gbmV3X2Jsb2NrLmZpcnN0O1xuICAgICAgICAgICAgby0tO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBibG9ja1xuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlkX21vdmUuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGFzLmdldChuZXdfa2V5KSA+IGRlbHRhcy5nZXQob2xkX2tleSkpIHtcbiAgICAgICAgICAgIGRpZF9tb3ZlLmFkZChuZXdfa2V5KTtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoby0tKSB7XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3Nbb107XG4gICAgICAgIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2Jsb2NrLmtleSkpXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICB9XG4gICAgd2hpbGUgKG4pXG4gICAgICAgIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG4gICAgcmV0dXJuIG5ld19ibG9ja3M7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY3R4LCBsaXN0LCBnZXRfY29udGV4dCwgZ2V0X2tleSkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKSk7XG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzIGluIGEga2V5ZWQgZWFjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRfc3ByZWFkX3VwZGF0ZShsZXZlbHMsIHVwZGF0ZXMpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB7fTtcbiAgICBjb25zdCB0b19udWxsX291dCA9IHt9O1xuICAgIGNvbnN0IGFjY291bnRlZF9mb3IgPSB7ICQkc2NvcGU6IDEgfTtcbiAgICBsZXQgaSA9IGxldmVscy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBvID0gbGV2ZWxzW2ldO1xuICAgICAgICBjb25zdCBuID0gdXBkYXRlc1tpXTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbikpXG4gICAgICAgICAgICAgICAgICAgIHRvX251bGxfb3V0W2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbikge1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudGVkX2ZvcltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gbltrZXldO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsc1tpXSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b19udWxsX291dCkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdXBkYXRlKSlcbiAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZ2V0X3NwcmVhZF9vYmplY3Qoc3ByZWFkX3Byb3BzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcHJlYWRfcHJvcHMgPT09ICdvYmplY3QnICYmIHNwcmVhZF9wcm9wcyAhPT0gbnVsbCA/IHNwcmVhZF9wcm9wcyA6IHt9O1xufVxuXG4vLyBzb3VyY2U6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbFxuY29uc3QgYm9vbGVhbl9hdHRyaWJ1dGVzID0gbmV3IFNldChbXG4gICAgJ2FsbG93ZnVsbHNjcmVlbicsXG4gICAgJ2FsbG93cGF5bWVudHJlcXVlc3QnLFxuICAgICdhc3luYycsXG4gICAgJ2F1dG9mb2N1cycsXG4gICAgJ2F1dG9wbGF5JyxcbiAgICAnY2hlY2tlZCcsXG4gICAgJ2NvbnRyb2xzJyxcbiAgICAnZGVmYXVsdCcsXG4gICAgJ2RlZmVyJyxcbiAgICAnZGlzYWJsZWQnLFxuICAgICdmb3Jtbm92YWxpZGF0ZScsXG4gICAgJ2hpZGRlbicsXG4gICAgJ2lzbWFwJyxcbiAgICAnbG9vcCcsXG4gICAgJ211bHRpcGxlJyxcbiAgICAnbXV0ZWQnLFxuICAgICdub21vZHVsZScsXG4gICAgJ25vdmFsaWRhdGUnLFxuICAgICdvcGVuJyxcbiAgICAncGxheXNpbmxpbmUnLFxuICAgICdyZWFkb25seScsXG4gICAgJ3JlcXVpcmVkJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdzZWxlY3RlZCdcbl0pO1xuXG5jb25zdCB2b2lkX2VsZW1lbnRfbmFtZXMgPSAvXig/OmFyZWF8YmFzZXxicnxjb2x8Y29tbWFuZHxlbWJlZHxocnxpbWd8aW5wdXR8a2V5Z2VufGxpbmt8bWV0YXxwYXJhbXxzb3VyY2V8dHJhY2t8d2JyKSQvO1xuZnVuY3Rpb24gaXNfdm9pZChuYW1lKSB7XG4gICAgcmV0dXJuIHZvaWRfZWxlbWVudF9uYW1lcy50ZXN0KG5hbWUpIHx8IG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJyFkb2N0eXBlJztcbn1cblxuY29uc3QgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIgPSAvW1xccydcIj4vPVxcdXtGREQwfS1cXHV7RkRFRn1cXHV7RkZGRX1cXHV7RkZGRn1cXHV7MUZGRkV9XFx1ezFGRkZGfVxcdXsyRkZGRX1cXHV7MkZGRkZ9XFx1ezNGRkZFfVxcdXszRkZGRn1cXHV7NEZGRkV9XFx1ezRGRkZGfVxcdXs1RkZGRX1cXHV7NUZGRkZ9XFx1ezZGRkZFfVxcdXs2RkZGRn1cXHV7N0ZGRkV9XFx1ezdGRkZGfVxcdXs4RkZGRX1cXHV7OEZGRkZ9XFx1ezlGRkZFfVxcdXs5RkZGRn1cXHV7QUZGRkV9XFx1e0FGRkZGfVxcdXtCRkZGRX1cXHV7QkZGRkZ9XFx1e0NGRkZFfVxcdXtDRkZGRn1cXHV7REZGRkV9XFx1e0RGRkZGfVxcdXtFRkZGRX1cXHV7RUZGRkZ9XFx1e0ZGRkZFfVxcdXtGRkZGRn1cXHV7MTBGRkZFfVxcdXsxMEZGRkZ9XS91O1xuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jbm9uY2hhcmFjdGVyXG5mdW5jdGlvbiBzcHJlYWQoYXJncywgYXR0cnNfdG9fYWRkKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmFyZ3MpO1xuICAgIGlmIChhdHRyc190b19hZGQpIHtcbiAgICAgICAgY29uc3QgY2xhc3Nlc190b19hZGQgPSBhdHRyc190b19hZGQuY2xhc3NlcztcbiAgICAgICAgY29uc3Qgc3R5bGVzX3RvX2FkZCA9IGF0dHJzX3RvX2FkZC5zdHlsZXM7XG4gICAgICAgIGlmIChjbGFzc2VzX3RvX2FkZCkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuY2xhc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgKz0gJyAnICsgY2xhc3Nlc190b19hZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlc190b19hZGQpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnN0eWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZXNfdG9fYWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKG1lcmdlX3Nzcl9zdHlsZXMoYXR0cmlidXRlcy5zdHlsZSwgc3R5bGVzX3RvX2FkZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBpZiAoaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpXG4gICAgICAgICAgICBzdHIgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgZWxzZSBpZiAoYm9vbGVhbl9hdHRyaWJ1dGVzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9IGAgJHtuYW1lfT1cIiR7dmFsdWV9XCJgO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIG1lcmdlX3Nzcl9zdHlsZXMoc3R5bGVfYXR0cmlidXRlLCBzdHlsZV9kaXJlY3RpdmUpIHtcbiAgICBjb25zdCBzdHlsZV9vYmplY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGluZGl2aWR1YWxfc3R5bGUgb2Ygc3R5bGVfYXR0cmlidXRlLnNwbGl0KCc7JykpIHtcbiAgICAgICAgY29uc3QgY29sb25faW5kZXggPSBpbmRpdmlkdWFsX3N0eWxlLmluZGV4T2YoJzonKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGluZGl2aWR1YWxfc3R5bGUuc2xpY2UoMCwgY29sb25faW5kZXgpLnRyaW0oKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbmRpdmlkdWFsX3N0eWxlLnNsaWNlKGNvbG9uX2luZGV4ICsgMSkudHJpbSgpO1xuICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc3R5bGVfb2JqZWN0W25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdHlsZV9kaXJlY3RpdmUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZV9kaXJlY3RpdmVbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgc3R5bGVfb2JqZWN0W25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVfb2JqZWN0W25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZV9vYmplY3Q7XG59XG5jb25zdCBBVFRSX1JFR0VYID0gL1smXCJdL2c7XG5jb25zdCBDT05URU5UX1JFR0VYID0gL1smPF0vZztcbi8qKlxuICogTm90ZTogdGhpcyBtZXRob2QgaXMgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlIGFuZCBoYXMgYmVlbiBvcHRpbWl6ZWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC81NzAxXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZSh2YWx1ZSwgaXNfYXR0ciA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc3RyID0gU3RyaW5nKHZhbHVlKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gaXNfYXR0ciA/IEFUVFJfUkVHRVggOiBDT05URU5UX1JFR0VYO1xuICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICBsZXQgZXNjYXBlZCA9ICcnO1xuICAgIGxldCBsYXN0ID0gMDtcbiAgICB3aGlsZSAocGF0dGVybi50ZXN0KHN0cikpIHtcbiAgICAgICAgY29uc3QgaSA9IHBhdHRlcm4ubGFzdEluZGV4IC0gMTtcbiAgICAgICAgY29uc3QgY2ggPSBzdHJbaV07XG4gICAgICAgIGVzY2FwZWQgKz0gc3RyLnN1YnN0cmluZyhsYXN0LCBpKSArIChjaCA9PT0gJyYnID8gJyZhbXA7JyA6IChjaCA9PT0gJ1wiJyA/ICcmcXVvdDsnIDogJyZsdDsnKSk7XG4gICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGVzY2FwZWQgKyBzdHIuc3Vic3RyaW5nKGxhc3QpO1xufVxuZnVuY3Rpb24gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZSh2YWx1ZSkge1xuICAgIC8vIGtlZXAgYm9vbGVhbnMsIG51bGwsIGFuZCB1bmRlZmluZWQgZm9yIHRoZSBzYWtlIG9mIGBzcHJlYWRgXG4gICAgY29uc3Qgc2hvdWxkX2VzY2FwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpO1xuICAgIHJldHVybiBzaG91bGRfZXNjYXBlID8gZXNjYXBlKHZhbHVlLCB0cnVlKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZXNjYXBlX29iamVjdChvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGVhY2goaXRlbXMsIGZuKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGZuKGl0ZW1zW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmNvbnN0IG1pc3NpbmdfY29tcG9uZW50ID0ge1xuICAgICQkcmVuZGVyOiAoKSA9PiAnJ1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlX2NvbXBvbmVudChjb21wb25lbnQsIG5hbWUpIHtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhY29tcG9uZW50LiQkcmVuZGVyKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnc3ZlbHRlOmNvbXBvbmVudCcpXG4gICAgICAgICAgICBuYW1lICs9ICcgdGhpcz17Li4ufSc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgPCR7bmFtZX0+IGlzIG5vdCBhIHZhbGlkIFNTUiBjb21wb25lbnQuIFlvdSBtYXkgbmVlZCB0byByZXZpZXcgeW91ciBidWlsZCBjb25maWcgdG8gZW5zdXJlIHRoYXQgZGVwZW5kZW5jaWVzIGFyZSBjb21waWxlZCwgcmF0aGVyIHRoYW4gaW1wb3J0ZWQgYXMgcHJlLWNvbXBpbGVkIG1vZHVsZXNgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGRlYnVnKGZpbGUsIGxpbmUsIGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgY29uc29sZS5sb2coYHtAZGVidWd9ICR7ZmlsZSA/IGZpbGUgKyAnICcgOiAnJ30oJHtsaW5lfToke2NvbHVtbn0pYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKHZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiAnJztcbn1cbmxldCBvbl9kZXN0cm95O1xuZnVuY3Rpb24gY3JlYXRlX3Nzcl9jb21wb25lbnQoZm4pIHtcbiAgICBmdW5jdGlvbiAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgICAgICBjb25zdCAkJCA9IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3ksXG4gICAgICAgICAgICBjb250ZXh0OiBuZXcgTWFwKGNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAgICAgLy8gdGhlc2Ugd2lsbCBiZSBpbW1lZGlhdGVseSBkaXNjYXJkZWRcbiAgICAgICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KClcbiAgICAgICAgfTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHsgJCQgfSk7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBmbihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMpO1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXI6IChwcm9wcyA9IHt9LCB7ICQkc2xvdHMgPSB7fSwgY29udGV4dCA9IG5ldyBNYXAoKSB9ID0ge30pID0+IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3kgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdGl0bGU6ICcnLCBoZWFkOiAnJywgY3NzOiBuZXcgU2V0KCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCB7fSwgJCRzbG90cywgY29udGV4dCk7XG4gICAgICAgICAgICBydW5fYWxsKG9uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBodG1sLFxuICAgICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBBcnJheS5mcm9tKHJlc3VsdC5jc3MpLm1hcChjc3MgPT4gY3NzLmNvZGUpLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgICAgICBtYXA6IG51bGwgLy8gVE9ET1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGVhZDogcmVzdWx0LnRpdGxlICsgcmVzdWx0LmhlYWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgICQkcmVuZGVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZF9hdHRyaWJ1dGUobmFtZSwgdmFsdWUsIGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoYm9vbGVhbiAmJiAhdmFsdWUpKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgYXNzaWdubWVudCA9IChib29sZWFuICYmIHZhbHVlID09PSB0cnVlKSA/ICcnIDogYD1cIiR7ZXNjYXBlKHZhbHVlLCB0cnVlKX1cImA7XG4gICAgcmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuZnVuY3Rpb24gYWRkX2NsYXNzZXMoY2xhc3Nlcykge1xuICAgIHJldHVybiBjbGFzc2VzID8gYCBjbGFzcz1cIiR7Y2xhc3Nlc31cImAgOiAnJztcbn1cbmZ1bmN0aW9uIHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlX29iamVjdClcbiAgICAgICAgLmZpbHRlcihrZXkgPT4gc3R5bGVfb2JqZWN0W2tleV0pXG4gICAgICAgIC5tYXAoa2V5ID0+IGAke2tleX06ICR7c3R5bGVfb2JqZWN0W2tleV19O2ApXG4gICAgICAgIC5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBhZGRfc3R5bGVzKHN0eWxlX29iamVjdCkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KTtcbiAgICByZXR1cm4gc3R5bGVzID8gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYCA6ICcnO1xufVxuXG5mdW5jdGlvbiBiaW5kKGNvbXBvbmVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC4kJC5wcm9wc1tuYW1lXTtcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnQuJCQuYm91bmRbaW5kZXhdID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrKGNvbXBvbmVudC4kJC5jdHhbaW5kZXhdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVfY29tcG9uZW50KGJsb2NrKSB7XG4gICAgYmxvY2sgJiYgYmxvY2suYygpO1xufVxuZnVuY3Rpb24gY2xhaW1fY29tcG9uZW50KGJsb2NrLCBwYXJlbnRfbm9kZXMpIHtcbiAgICBibG9jayAmJiBibG9jay5sKHBhcmVudF9ub2Rlcyk7XG59XG5mdW5jdGlvbiBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCB0YXJnZXQsIGFuY2hvciwgY3VzdG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIG9uX21vdW50LCBvbl9kZXN0cm95LCBhZnRlcl91cGRhdGUgfSA9IGNvbXBvbmVudC4kJDtcbiAgICBmcmFnbWVudCAmJiBmcmFnbWVudC5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICBpZiAoIWN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgLy8gb25Nb3VudCBoYXBwZW5zIGJlZm9yZSB0aGUgaW5pdGlhbCBhZnRlclVwZGF0ZVxuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld19vbl9kZXN0cm95ID0gb25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIGlmIChvbl9kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgb25fZGVzdHJveS5wdXNoKC4uLm5ld19vbl9kZXN0cm95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVkZ2UgY2FzZSAtIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5LFxuICAgICAgICAgICAgICAgIC8vIG1vc3QgbGlrZWx5IGFzIGEgcmVzdWx0IG9mIGEgYmluZGluZyBpbml0aWFsaXNpbmdcbiAgICAgICAgICAgICAgICBydW5fYWxsKG5ld19vbl9kZXN0cm95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudC4kJC5vbl9tb3VudCA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG59XG5mdW5jdGlvbiBkZXN0cm95X2NvbXBvbmVudChjb21wb25lbnQsIGRldGFjaGluZykge1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkO1xuICAgIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBydW5fYWxsKCQkLm9uX2Rlc3Ryb3kpO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG4gICAgICAgIC8vIFRPRE8gbnVsbCBvdXQgb3RoZXIgcmVmcywgaW5jbHVkaW5nIGNvbXBvbmVudC4kJCAoYnV0IG5lZWQgdG9cbiAgICAgICAgLy8gcHJlc2VydmUgZmluYWwgc3RhdGU/KVxuICAgICAgICAkJC5vbl9kZXN0cm95ID0gJCQuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAkJC5jdHggPSBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSkge1xuICAgIGlmIChjb21wb25lbnQuJCQuZGlydHlbMF0gPT09IC0xKSB7XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICAgICAgY29tcG9uZW50LiQkLmRpcnR5LmZpbGwoMCk7XG4gICAgfVxuICAgIGNvbXBvbmVudC4kJC5kaXJ0eVsoaSAvIDMxKSB8IDBdIHw9ICgxIDw8IChpICUgMzEpKTtcbn1cbmZ1bmN0aW9uIGluaXQoY29tcG9uZW50LCBvcHRpb25zLCBpbnN0YW5jZSwgY3JlYXRlX2ZyYWdtZW50LCBub3RfZXF1YWwsIHByb3BzLCBhcHBlbmRfc3R5bGVzLCBkaXJ0eSA9IFstMV0pIHtcbiAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQgPSB7XG4gICAgICAgIGZyYWdtZW50OiBudWxsLFxuICAgICAgICBjdHg6IG51bGwsXG4gICAgICAgIC8vIHN0YXRlXG4gICAgICAgIHByb3BzLFxuICAgICAgICB1cGRhdGU6IG5vb3AsXG4gICAgICAgIG5vdF9lcXVhbCxcbiAgICAgICAgYm91bmQ6IGJsYW5rX29iamVjdCgpLFxuICAgICAgICAvLyBsaWZlY3ljbGVcbiAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICBvbl9kZXN0cm95OiBbXSxcbiAgICAgICAgb25fZGlzY29ubmVjdDogW10sXG4gICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICBjb250ZXh0OiBuZXcgTWFwKG9wdGlvbnMuY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG4gICAgICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpLFxuICAgICAgICBkaXJ0eSxcbiAgICAgICAgc2tpcF9ib3VuZDogZmFsc2UsXG4gICAgICAgIHJvb3Q6IG9wdGlvbnMudGFyZ2V0IHx8IHBhcmVudF9jb21wb25lbnQuJCQucm9vdFxuICAgIH07XG4gICAgYXBwZW5kX3N0eWxlcyAmJiBhcHBlbmRfc3R5bGVzKCQkLnJvb3QpO1xuICAgIGxldCByZWFkeSA9IGZhbHNlO1xuICAgICQkLmN0eCA9IGluc3RhbmNlXG4gICAgICAgID8gaW5zdGFuY2UoY29tcG9uZW50LCBvcHRpb25zLnByb3BzIHx8IHt9LCAoaSwgcmV0LCAuLi5yZXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3QubGVuZ3RoID8gcmVzdFswXSA6IHJldDtcbiAgICAgICAgICAgIGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgJCQuY3R4W2ldID0gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkJC5za2lwX2JvdW5kICYmICQkLmJvdW5kW2ldKVxuICAgICAgICAgICAgICAgICAgICAkJC5ib3VuZFtpXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWR5KVxuICAgICAgICAgICAgICAgICAgICBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KVxuICAgICAgICA6IFtdO1xuICAgICQkLnVwZGF0ZSgpO1xuICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgIC8vIGBmYWxzZWAgYXMgYSBzcGVjaWFsIGNhc2Ugb2Ygbm8gRE9NIGNvbXBvbmVudFxuICAgICQkLmZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50ID8gY3JlYXRlX2ZyYWdtZW50KCQkLmN0eCkgOiBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICAgICAgc3RhcnRfaHlkcmF0aW5nKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IGNoaWxkcmVuKG9wdGlvbnMudGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5sKG5vZGVzKTtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZGV0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW50cm8pXG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGNvbXBvbmVudC4kJC5mcmFnbWVudCk7XG4gICAgICAgIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMudGFyZ2V0LCBvcHRpb25zLmFuY2hvciwgb3B0aW9ucy5jdXN0b21FbGVtZW50KTtcbiAgICAgICAgZW5kX2h5ZHJhdGluZygpO1xuICAgICAgICBmbHVzaCgpO1xuICAgIH1cbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG59XG5sZXQgU3ZlbHRlRWxlbWVudDtcbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBTdmVsdGVFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgY29uc3QgeyBvbl9tb3VudCB9ID0gdGhpcy4kJDtcbiAgICAgICAgICAgIHRoaXMuJCQub25fZGlzY29ubmVjdCA9IG9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJC5zbG90dGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuJCQuc2xvdHRlZFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpc1thdHRyXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgcnVuX2FsbCh0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgICRkZXN0cm95KCkge1xuICAgICAgICAgICAgZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG4gICAgICAgICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICAkb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIFRPRE8gc2hvdWxkIHRoaXMgZGVsZWdhdGUgdG8gYWRkRXZlbnRMaXN0ZW5lcj9cbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSkpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgJHNldCgkJHByb3BzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkoJCRwcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuJCRzZXQoJCRwcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cy4gVXNlZCB3aGVuIGRldj1mYWxzZS5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50IHtcbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgIH1cbiAgICAkb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJHNldCgkJHByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJCRzZXQoJCRwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hfZGV2KHR5cGUsIGRldGFpbCkge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KHR5cGUsIE9iamVjdC5hc3NpZ24oeyB2ZXJzaW9uOiAnMy40OS4wJyB9LCBkZXRhaWwpLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuICAgIGFwcGVuZCh0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG59XG5mdW5jdGlvbiBpbnNlcnRfZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuICAgIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9kZXYobm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlJywgeyBub2RlIH0pO1xuICAgIGRldGFjaChub2RlKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9iZXR3ZWVuX2RldihiZWZvcmUsIGFmdGVyKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZyAmJiBiZWZvcmUubmV4dFNpYmxpbmcgIT09IGFmdGVyKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYmVmb3JlX2RldihhZnRlcikge1xuICAgIHdoaWxlIChhZnRlci5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihhZnRlci5wcmV2aW91c1NpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9hZnRlcl9kZXYoYmVmb3JlKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGlzdGVuX2Rldihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucywgaGFzX3ByZXZlbnRfZGVmYXVsdCwgaGFzX3N0b3BfcHJvcGFnYXRpb24pIHtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBvcHRpb25zID09PSB0cnVlID8gWydjYXB0dXJlJ10gOiBvcHRpb25zID8gQXJyYXkuZnJvbShPYmplY3Qua2V5cyhvcHRpb25zKSkgOiBbXTtcbiAgICBpZiAoaGFzX3ByZXZlbnRfZGVmYXVsdClcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3ByZXZlbnREZWZhdWx0Jyk7XG4gICAgaWYgKGhhc19zdG9wX3Byb3BhZ2F0aW9uKVxuICAgICAgICBtb2RpZmllcnMucHVzaCgnc3RvcFByb3BhZ2F0aW9uJyk7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01BZGRFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyX2Rldihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSB9KTtcbiAgICBlbHNlXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0QXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUsIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gcHJvcF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldFByb3BlcnR5JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBkYXRhc2V0X2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlLmRhdGFzZXRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhc2V0JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhJywgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50KGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnc3RyaW5nJyAmJiAhKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBhcmcpKSB7XG4gICAgICAgIGxldCBtc2cgPSAneyNlYWNofSBvbmx5IGl0ZXJhdGVzIG92ZXIgYXJyYXktbGlrZSBvYmplY3RzLic7XG4gICAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIGFyZyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gYXJnKSB7XG4gICAgICAgICAgICBtc2cgKz0gJyBZb3UgY2FuIHVzZSBhIHNwcmVhZCB0byBjb252ZXJ0IHRoaXMgaXRlcmFibGUgaW50byBhbiBhcnJheS4nO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3Nsb3RzKG5hbWUsIHNsb3QsIGtleXMpIHtcbiAgICBmb3IgKGNvbnN0IHNsb3Rfa2V5IG9mIE9iamVjdC5rZXlzKHNsb3QpKSB7XG4gICAgICAgIGlmICghfmtleXMuaW5kZXhPZihzbG90X2tleSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgPCR7bmFtZX0+IHJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgc2xvdCBcIiR7c2xvdF9rZXl9XCIuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9keW5hbWljX2VsZW1lbnQodGFnKSB7XG4gICAgY29uc3QgaXNfc3RyaW5nID0gdHlwZW9mIHRhZyA9PT0gJ3N0cmluZyc7XG4gICAgaWYgKHRhZyAmJiAhaXNfc3RyaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignPHN2ZWx0ZTplbGVtZW50PiBleHBlY3RzIFwidGhpc1wiIGF0dHJpYnV0ZSB0byBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCh0YWcpIHtcbiAgICBpZiAodGFnICYmIGlzX3ZvaWQodGFnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJHt0YWd9XCI+IGlzIHNlbGYtY2xvc2luZyBhbmQgY2Fubm90IGhhdmUgY29udGVudC5gKTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzIHdpdGggc29tZSBtaW5vciBkZXYtZW5oYW5jZW1lbnRzLiBVc2VkIHdoZW4gZGV2PXRydWUuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudERldiBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgKCFvcHRpb25zLnRhcmdldCAmJiAhb3B0aW9ucy4kJGlubGluZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIid0YXJnZXQnIGlzIGEgcmVxdWlyZWQgb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgICRkZXN0cm95KCkge1xuICAgICAgICBzdXBlci4kZGVzdHJveSgpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb21wb25lbnQgd2FzIGFscmVhZHkgZGVzdHJveWVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAkY2FwdHVyZV9zdGF0ZSgpIHsgfVxuICAgICRpbmplY3Rfc3RhdGUoKSB7IH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyB0byBjcmVhdGUgc3Ryb25nbHkgdHlwZWQgU3ZlbHRlIGNvbXBvbmVudHMuXG4gKiBUaGlzIG9ubHkgZXhpc3RzIGZvciB0eXBpbmcgcHVycG9zZXMgYW5kIHNob3VsZCBiZSB1c2VkIGluIGAuZC50c2AgZmlsZXMuXG4gKlxuICogIyMjIEV4YW1wbGU6XG4gKlxuICogWW91IGhhdmUgY29tcG9uZW50IGxpYnJhcnkgb24gbnBtIGNhbGxlZCBgY29tcG9uZW50LWxpYnJhcnlgLCBmcm9tIHdoaWNoXG4gKiB5b3UgZXhwb3J0IGEgY29tcG9uZW50IGNhbGxlZCBgTXlDb21wb25lbnRgLiBGb3IgU3ZlbHRlK1R5cGVTY3JpcHQgdXNlcnMsXG4gKiB5b3Ugd2FudCB0byBwcm92aWRlIHR5cGluZ3MuIFRoZXJlZm9yZSB5b3UgY3JlYXRlIGEgYGluZGV4LmQudHNgOlxuICogYGBgdHNcbiAqIGltcG9ydCB7IFN2ZWx0ZUNvbXBvbmVudFR5cGVkIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50VHlwZWQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGBgYFxuICogVHlwaW5nIHRoaXMgbWFrZXMgaXQgcG9zc2libGUgZm9yIElERXMgbGlrZSBWUyBDb2RlIHdpdGggdGhlIFN2ZWx0ZSBleHRlbnNpb25cbiAqIHRvIHByb3ZpZGUgaW50ZWxsaXNlbnNlIGFuZCB0byB1c2UgdGhlIGNvbXBvbmVudCBsaWtlIHRoaXMgaW4gYSBTdmVsdGUgZmlsZVxuICogd2l0aCBUeXBlU2NyaXB0OlxuICogYGBgc3ZlbHRlXG4gKiA8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICogXHRpbXBvcnQgeyBNeUNvbXBvbmVudCB9IGZyb20gXCJjb21wb25lbnQtbGlicmFyeVwiO1xuICogPC9zY3JpcHQ+XG4gKiA8TXlDb21wb25lbnQgZm9vPXsnYmFyJ30gLz5cbiAqIGBgYFxuICpcbiAqICMjIyMgV2h5IG5vdCBtYWtlIHRoaXMgcGFydCBvZiBgU3ZlbHRlQ29tcG9uZW50KERldilgP1xuICogQmVjYXVzZVxuICogYGBgdHNcbiAqIGNsYXNzIEFTdWJjbGFzc09mU3ZlbHRlQ29tcG9uZW50IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50PHtmb286IHN0cmluZ30+IHt9XG4gKiBjb25zdCBjb21wb25lbnQ6IHR5cGVvZiBTdmVsdGVDb21wb25lbnQgPSBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudDtcbiAqIGBgYFxuICogd2lsbCB0aHJvdyBhIHR5cGUgZXJyb3IsIHNvIHdlIG5lZWQgdG8gc2VwYXJhdGUgdGhlIG1vcmUgc3RyaWN0bHkgdHlwZWQgY2xhc3MuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkIGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50RGV2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvb3BfZ3VhcmQodGltZW91dCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIGRldGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgeyBIdG1sVGFnLCBIdG1sVGFnSHlkcmF0aW9uLCBTdmVsdGVDb21wb25lbnQsIFN2ZWx0ZUNvbXBvbmVudERldiwgU3ZlbHRlQ29tcG9uZW50VHlwZWQsIFN2ZWx0ZUVsZW1lbnQsIGFjdGlvbl9kZXN0cm95ZXIsIGFkZF9hdHRyaWJ1dGUsIGFkZF9jbGFzc2VzLCBhZGRfZmx1c2hfY2FsbGJhY2ssIGFkZF9sb2NhdGlvbiwgYWRkX3JlbmRlcl9jYWxsYmFjaywgYWRkX3Jlc2l6ZV9saXN0ZW5lciwgYWRkX3N0eWxlcywgYWRkX3RyYW5zZm9ybSwgYWZ0ZXJVcGRhdGUsIGFwcGVuZCwgYXBwZW5kX2RldiwgYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQsIGFwcGVuZF9oeWRyYXRpb24sIGFwcGVuZF9oeWRyYXRpb25fZGV2LCBhcHBlbmRfc3R5bGVzLCBhc3NpZ24sIGF0dHIsIGF0dHJfZGV2LCBhdHRyaWJ1dGVfdG9fb2JqZWN0LCBiZWZvcmVVcGRhdGUsIGJpbmQsIGJpbmRpbmdfY2FsbGJhY2tzLCBibGFua19vYmplY3QsIGJ1YmJsZSwgY2hlY2tfb3V0cm9zLCBjaGlsZHJlbiwgY2xhaW1fY29tcG9uZW50LCBjbGFpbV9lbGVtZW50LCBjbGFpbV9odG1sX3RhZywgY2xhaW1fc3BhY2UsIGNsYWltX3N2Z19lbGVtZW50LCBjbGFpbV90ZXh0LCBjbGVhcl9sb29wcywgY29tcG9uZW50X3N1YnNjcmliZSwgY29tcHV0ZV9yZXN0X3Byb3BzLCBjb21wdXRlX3Nsb3RzLCBjcmVhdGVFdmVudERpc3BhdGNoZXIsIGNyZWF0ZV9hbmltYXRpb24sIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24sIGNyZWF0ZV9jb21wb25lbnQsIGNyZWF0ZV9pbl90cmFuc2l0aW9uLCBjcmVhdGVfb3V0X3RyYW5zaXRpb24sIGNyZWF0ZV9zbG90LCBjcmVhdGVfc3NyX2NvbXBvbmVudCwgY3VycmVudF9jb21wb25lbnQsIGN1c3RvbV9ldmVudCwgZGF0YXNldF9kZXYsIGRlYnVnLCBkZXN0cm95X2Jsb2NrLCBkZXN0cm95X2NvbXBvbmVudCwgZGVzdHJveV9lYWNoLCBkZXRhY2gsIGRldGFjaF9hZnRlcl9kZXYsIGRldGFjaF9iZWZvcmVfZGV2LCBkZXRhY2hfYmV0d2Vlbl9kZXYsIGRldGFjaF9kZXYsIGRpcnR5X2NvbXBvbmVudHMsIGRpc3BhdGNoX2RldiwgZWFjaCwgZWxlbWVudCwgZWxlbWVudF9pcywgZW1wdHksIGVuZF9oeWRyYXRpbmcsIGVzY2FwZSwgZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZSwgZXNjYXBlX29iamVjdCwgZXhjbHVkZV9pbnRlcm5hbF9wcm9wcywgZml4X2FuZF9kZXN0cm95X2Jsb2NrLCBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBmaXhfcG9zaXRpb24sIGZsdXNoLCBnZXRBbGxDb250ZXh0cywgZ2V0Q29udGV4dCwgZ2V0X2FsbF9kaXJ0eV9mcm9tX3Njb3BlLCBnZXRfYmluZGluZ19ncm91cF92YWx1ZSwgZ2V0X2N1cnJlbnRfY29tcG9uZW50LCBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzLCBnZXRfcm9vdF9mb3Jfc3R5bGUsIGdldF9zbG90X2NoYW5nZXMsIGdldF9zcHJlYWRfb2JqZWN0LCBnZXRfc3ByZWFkX3VwZGF0ZSwgZ2V0X3N0b3JlX3ZhbHVlLCBnbG9iYWxzLCBncm91cF9vdXRyb3MsIGhhbmRsZV9wcm9taXNlLCBoYXNDb250ZXh0LCBoYXNfcHJvcCwgaWRlbnRpdHksIGluaXQsIGluc2VydCwgaW5zZXJ0X2RldiwgaW5zZXJ0X2h5ZHJhdGlvbiwgaW5zZXJ0X2h5ZHJhdGlvbl9kZXYsIGludHJvcywgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIsIGlzX2NsaWVudCwgaXNfY3Jvc3NvcmlnaW4sIGlzX2VtcHR5LCBpc19mdW5jdGlvbiwgaXNfcHJvbWlzZSwgaXNfdm9pZCwgbGlzdGVuLCBsaXN0ZW5fZGV2LCBsb29wLCBsb29wX2d1YXJkLCBtZXJnZV9zc3Jfc3R5bGVzLCBtaXNzaW5nX2NvbXBvbmVudCwgbW91bnRfY29tcG9uZW50LCBub29wLCBub3RfZXF1YWwsIG5vdywgbnVsbF90b19lbXB0eSwgb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcywgb25EZXN0cm95LCBvbk1vdW50LCBvbmNlLCBvdXRyb19hbmRfZGVzdHJveV9ibG9jaywgcHJldmVudF9kZWZhdWx0LCBwcm9wX2RldiwgcXVlcnlfc2VsZWN0b3JfYWxsLCByYWYsIHJ1biwgcnVuX2FsbCwgc2FmZV9ub3RfZXF1YWwsIHNjaGVkdWxlX3VwZGF0ZSwgc2VsZWN0X211bHRpcGxlX3ZhbHVlLCBzZWxlY3Rfb3B0aW9uLCBzZWxlY3Rfb3B0aW9ucywgc2VsZWN0X3ZhbHVlLCBzZWxmLCBzZXRDb250ZXh0LCBzZXRfYXR0cmlidXRlcywgc2V0X2N1cnJlbnRfY29tcG9uZW50LCBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YSwgc2V0X2RhdGEsIHNldF9kYXRhX2Rldiwgc2V0X2lucHV0X3R5cGUsIHNldF9pbnB1dF92YWx1ZSwgc2V0X25vdywgc2V0X3JhZiwgc2V0X3N0b3JlX3ZhbHVlLCBzZXRfc3R5bGUsIHNldF9zdmdfYXR0cmlidXRlcywgc3BhY2UsIHNwcmVhZCwgc3JjX3VybF9lcXVhbCwgc3RhcnRfaHlkcmF0aW5nLCBzdG9wX3Byb3BhZ2F0aW9uLCBzdWJzY3JpYmUsIHN2Z19lbGVtZW50LCB0ZXh0LCB0aWNrLCB0aW1lX3Jhbmdlc190b19hcnJheSwgdG9fbnVtYmVyLCB0b2dnbGVfY2xhc3MsIHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0LCB0cnVzdGVkLCB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoLCB1cGRhdGVfa2V5ZWRfZWFjaCwgdXBkYXRlX3Nsb3QsIHVwZGF0ZV9zbG90X2Jhc2UsIHZhbGlkYXRlX2NvbXBvbmVudCwgdmFsaWRhdGVfZHluYW1pY19lbGVtZW50LCB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50LCB2YWxpZGF0ZV9lYWNoX2tleXMsIHZhbGlkYXRlX3Nsb3RzLCB2YWxpZGF0ZV9zdG9yZSwgdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQsIHhsaW5rX2F0dHIgfTtcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrJztcblxuICBleHBvcnQgbGV0IGNvbmZpZywgc3RlcDtcbiAgbGV0IGFjdGlvbiwgY2xhc3NlcywgZGlzYWJsZWQsIGxhYmVsLCBzZWNvbmRhcnksIHRleHQ7XG5cbiAgJDoge1xuICAgIGFjdGlvbiA9IGNvbmZpZy5hY3Rpb24gPyBjb25maWcuYWN0aW9uLmJpbmQoc3RlcC50b3VyKSA6IG51bGw7XG4gICAgY2xhc3NlcyA9IGNvbmZpZy5jbGFzc2VzO1xuICAgIGRpc2FibGVkID0gY29uZmlnLmRpc2FibGVkID8gZ2V0Q29uZmlnT3B0aW9uKGNvbmZpZy5kaXNhYmxlZCkgOiBmYWxzZTtcbiAgICBsYWJlbCA9IGNvbmZpZy5sYWJlbCA/IGdldENvbmZpZ09wdGlvbihjb25maWcubGFiZWwpIDogbnVsbDtcbiAgICBzZWNvbmRhcnkgPSBjb25maWcuc2Vjb25kYXJ5O1xuICAgIHRleHQgPSBjb25maWcudGV4dCA/IGdldENvbmZpZ09wdGlvbihjb25maWcudGV4dCkgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29uZmlnT3B0aW9uKG9wdGlvbikge1xuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbikpIHtcbiAgICAgIHJldHVybiBvcHRpb24gPSBvcHRpb24uY2FsbChzdGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbjtcbiAgfVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWJ1dHRvbiB7XG4gICAgYmFja2dyb3VuZDogcmdiKDUwLCAxMzYsIDIzMCk7XG4gICAgYm9yZGVyOiAwO1xuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XG4gICAgcGFkZGluZzogMC41cmVtIDEuNXJlbTtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC41cyBlYXNlO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbjpub3QoOmRpc2FibGVkKTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiKDI1LCAxMTEsIDIwNCk7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uLnNoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnkge1xuICAgIGJhY2tncm91bmQ6IHJnYigyNDEsIDI0MiwgMjQzKTtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b24uc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeTpub3QoOmRpc2FibGVkKTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiKDIxNCwgMjE3LCAyMTkpO1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbjpkaXNhYmxlZCB7XG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgfVxuPC9zdHlsZT5cblxuPGJ1dHRvblxuICBhcmlhLWxhYmVsPVwie2xhYmVsID8gbGFiZWwgOiBudWxsfVwiXG4gIGNsYXNzPVwie2AkeyhjbGFzc2VzIHx8ICcnKX0gc2hlcGhlcmQtYnV0dG9uICR7KHNlY29uZGFyeSA/ICdzaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5JyA6ICcnKX1gfVwiXG4gIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgb246Y2xpY2s9e2FjdGlvbn1cbiAgdGFiaW5kZXg9XCIwXCJcbj5cbiAgICB7QGh0bWwgdGV4dH1cbjwvYnV0dG9uPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IFNoZXBoZXJkQnV0dG9uIGZyb20gJy4vc2hlcGhlcmQtYnV0dG9uLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBzdGVwO1xuXG4gICQ6IGJ1dHRvbnMgPSBzdGVwLm9wdGlvbnMuYnV0dG9ucztcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtZm9vdGVyIHtcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA1cHg7XG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDVweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgcGFkZGluZzogMCAwLjc1cmVtIDAuNzVyZW07XG4gIH1cblxuICAuc2hlcGhlcmQtZm9vdGVyIC5zaGVwaGVyZC1idXR0b246bGFzdC1jaGlsZCB7XG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xuICB9XG48L3N0eWxlPlxuXG48Zm9vdGVyIGNsYXNzPVwic2hlcGhlcmQtZm9vdGVyXCI+XG4gICAgeyNpZiBidXR0b25zfVxuICAgICAgICB7I2VhY2ggYnV0dG9ucyBhcyBjb25maWd9XG4gICAgICAgICAgPFNoZXBoZXJkQnV0dG9uXG4gICAgICAgICAgICB7Y29uZmlnfVxuICAgICAgICAgICAge3N0ZXB9XG4gICAgICAgICAgLz5cbiAgICAgICAgey9lYWNofVxuICAgIHsvaWZ9XG48L2Zvb3Rlcj5cbiIsIjxzY3JpcHQ+XG4gIGV4cG9ydCBsZXQgY2FuY2VsSWNvbiwgc3RlcDtcblxuICAvKipcbiAgICogQWRkIGEgY2xpY2sgbGlzdGVuZXIgdG8gdGhlIGNhbmNlbCBsaW5rIHRoYXQgY2FuY2VscyB0aGUgdG91clxuICAgKi9cbiAgY29uc3QgaGFuZGxlQ2FuY2VsQ2xpY2sgPSAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBzdGVwLmNhbmNlbCgpO1xuICB9O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1jYW5jZWwtaWNvbiB7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGNvbG9yOiByZ2JhKDEyOCwgMTI4LCAxMjgsIDAuNzUpO1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuICAgIHRyYW5zaXRpb246IGNvbG9yIDAuNXMgZWFzZTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1jYW5jZWwtaWNvbjpob3ZlciB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtaGFzLXRpdGxlIC5zaGVwaGVyZC1jb250ZW50IC5zaGVwaGVyZC1jYW5jZWwtaWNvbiB7XG4gICAgY29sb3I6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtaGFzLXRpdGxlIC5zaGVwaGVyZC1jb250ZW50IC5zaGVwaGVyZC1jYW5jZWwtaWNvbjpob3ZlciB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cbjwvc3R5bGU+XG5cbjxidXR0b25cbiAgYXJpYS1sYWJlbD1cIntjYW5jZWxJY29uLmxhYmVsID8gY2FuY2VsSWNvbi5sYWJlbCA6ICdDbG9zZSBUb3VyJ31cIlxuICBjbGFzcz1cInNoZXBoZXJkLWNhbmNlbC1pY29uXCJcbiAgb246Y2xpY2s9e2hhbmRsZUNhbmNlbENsaWNrfVxuICB0eXBlPVwiYnV0dG9uXCJcbj5cbiAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cbjwvYnV0dG9uPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjayc7XG4gIFxuICBleHBvcnQgbGV0IGxhYmVsSWQsIGVsZW1lbnQsIHRpdGxlO1xuICBcbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGlmIChpc0Z1bmN0aW9uKHRpdGxlKSkge1xuICAgICAgdGl0bGUgPSB0aXRsZSgpO1xuICAgIH1cbiAgICBcbiAgICBlbGVtZW50LmlubmVySFRNTCA9IHRpdGxlO1xuICB9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtdGl0bGUge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZm9udC1zaXplOiAxcmVtO1xuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gICAgZmxleDogMSAwIGF1dG87XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxoM1xuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGlkPVwie2xhYmVsSWR9XCJcbiAgY2xhc3M9XCJzaGVwaGVyZC10aXRsZVwiXG4+XG48L2gzPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IFNoZXBoZXJkQ2FuY2VsSWNvbiBmcm9tICcuL3NoZXBoZXJkLWNhbmNlbC1pY29uLnN2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZFRpdGxlIGZyb20gJy4vc2hlcGhlcmQtdGl0bGUuc3ZlbHRlJztcblxuICBleHBvcnQgbGV0IGxhYmVsSWQsIHN0ZXA7XG4gIGxldCB0aXRsZSwgY2FuY2VsSWNvbjtcblxuICAkOiB7XG4gICAgICB0aXRsZSA9IHN0ZXAub3B0aW9ucy50aXRsZTtcbiAgICAgIGNhbmNlbEljb24gPSBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbjtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1oZWFkZXIge1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNXB4O1xuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA1cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgIGxpbmUtaGVpZ2h0OiAyZW07XG4gICAgcGFkZGluZzogMC43NXJlbSAwLjc1cmVtIDA7XG4gIH1cblxuICAuc2hlcGhlcmQtaGFzLXRpdGxlIC5zaGVwaGVyZC1jb250ZW50IC5zaGVwaGVyZC1oZWFkZXIge1xuICAgIGJhY2tncm91bmQ6ICNlNmU2ZTY7XG4gICAgcGFkZGluZzogMWVtO1xuICB9XG48L3N0eWxlPlxuXG48aGVhZGVyIGNsYXNzPVwic2hlcGhlcmQtaGVhZGVyXCI+XG4gICAgeyNpZiB0aXRsZX1cbiAgICAgIDxTaGVwaGVyZFRpdGxlXG4gICAgICAgIHtsYWJlbElkfVxuICAgICAgICB7dGl0bGV9XG4gICAgICAvPlxuICAgIHsvaWZ9XG5cbiAgICB7I2lmIGNhbmNlbEljb24gJiYgY2FuY2VsSWNvbi5lbmFibGVkfVxuICAgICAgPFNoZXBoZXJkQ2FuY2VsSWNvblxuICAgICAgICB7Y2FuY2VsSWNvbn1cbiAgICAgICAge3N0ZXB9XG4gICAgICAvPlxuICAgIHsvaWZ9XG48L2hlYWRlcj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2snO1xuXG4gIGV4cG9ydCBsZXQgZGVzY3JpcHRpb25JZCwgZWxlbWVudCwgc3RlcDtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgbGV0IHsgdGV4dCB9ID0gc3RlcC5vcHRpb25zO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24odGV4dCkpIHtcbiAgICAgIHRleHQgPSB0ZXh0LmNhbGwoc3RlcCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGV4dCkpIHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdGV4dDtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC10ZXh0IHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgICBmb250LXNpemU6IDFyZW07XG4gICAgbGluZS1oZWlnaHQ6IDEuM2VtO1xuICAgIHBhZGRpbmc6IDAuNzVlbTtcbiAgfVxuXG4gIC5zaGVwaGVyZC10ZXh0IHAge1xuICAgIG1hcmdpbi10b3A6IDA7XG4gIH1cblxuICAuc2hlcGhlcmQtdGV4dCBwOmxhc3QtY2hpbGQge1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBjbGFzcz1cInNoZXBoZXJkLXRleHRcIlxuICBpZD1cIntkZXNjcmlwdGlvbklkfVwiXG4+XG48L2Rpdj5cblxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IFNoZXBoZXJkRm9vdGVyIGZyb20gJy4vc2hlcGhlcmQtZm9vdGVyLnN2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZEhlYWRlciBmcm9tICcuL3NoZXBoZXJkLWhlYWRlci5zdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRUZXh0IGZyb20gJy4vc2hlcGhlcmQtdGV4dC5zdmVsdGUnO1xuICBpbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuXG4gIGV4cG9ydCBsZXQgZGVzY3JpcHRpb25JZCwgbGFiZWxJZCwgc3RlcDtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtY29udGVudCB7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgcGFkZGluZzogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdlxuICBjbGFzcz1cInNoZXBoZXJkLWNvbnRlbnRcIlxuPlxuICB7I2lmICFpc1VuZGVmaW5lZChzdGVwLm9wdGlvbnMudGl0bGUpIHx8IChzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbiAmJiBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbi5lbmFibGVkKX1cbiAgICA8U2hlcGhlcmRIZWFkZXJcbiAgICAgIHtsYWJlbElkfVxuICAgICAge3N0ZXB9XG4gICAgLz5cbiAgey9pZn1cblxuICB7I2lmICFpc1VuZGVmaW5lZChzdGVwLm9wdGlvbnMudGV4dCl9XG4gICAgPFNoZXBoZXJkVGV4dFxuICAgICAge2Rlc2NyaXB0aW9uSWR9XG4gICAgICB7c3RlcH1cbiAgICAvPlxuICB7L2lmfVxuXG4gIHsjaWYgQXJyYXkuaXNBcnJheShzdGVwLm9wdGlvbnMuYnV0dG9ucykgJiYgc3RlcC5vcHRpb25zLmJ1dHRvbnMubGVuZ3RofVxuICAgIDxTaGVwaGVyZEZvb3RlclxuICAgICAge3N0ZXB9XG4gICAgLz5cbiAgey9pZn1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgb25Nb3VudCwgYWZ0ZXJVcGRhdGUgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRDb250ZW50IGZyb20gJy4vc2hlcGhlcmQtY29udGVudC5zdmVsdGUnO1xuICBpbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNTdHJpbmcgfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrLmpzJztcblxuICBjb25zdCBLRVlfVEFCID0gOTtcbiAgY29uc3QgS0VZX0VTQyA9IDI3O1xuICBjb25zdCBMRUZUX0FSUk9XID0gMzc7XG4gIGNvbnN0IFJJR0hUX0FSUk9XID0gMzk7XG5cbiAgZXhwb3J0IGxldCBjbGFzc1ByZWZpeCwgZWxlbWVudCwgZGVzY3JpcHRpb25JZCwgZmlyc3RGb2N1c2FibGVFbGVtZW50LFxuICAgIGZvY3VzYWJsZUVsZW1lbnRzLCBsYWJlbElkLCBsYXN0Rm9jdXNhYmxlRWxlbWVudCwgc3RlcCwgZGF0YVN0ZXBJZDtcblxuICBsZXQgaGFzQ2FuY2VsSWNvbiwgaGFzVGl0bGUsIGNsYXNzZXM7XG5cbiAgJDoge1xuICAgIGhhc0NhbmNlbEljb24gPSBzdGVwLm9wdGlvbnMgJiYgc3RlcC5vcHRpb25zLmNhbmNlbEljb24gJiYgc3RlcC5vcHRpb25zLmNhbmNlbEljb24uZW5hYmxlZDtcbiAgICBoYXNUaXRsZSA9IHN0ZXAub3B0aW9ucyAmJiBzdGVwLm9wdGlvbnMudGl0bGU7XG4gIH1cblxuICBleHBvcnQgY29uc3QgZ2V0RWxlbWVudCA9ICgpID0+IGVsZW1lbnQ7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgLy8gR2V0IGFsbCBlbGVtZW50cyB0aGF0IGFyZSBmb2N1c2FibGVcbiAgICBkYXRhU3RlcElkID0geyBbYGRhdGEtJHtjbGFzc1ByZWZpeH1zaGVwaGVyZC1zdGVwLWlkYF06IHN0ZXAuaWQgfTtcbiAgICBmb2N1c2FibGVFbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIFt0YWJpbmRleD1cIjBcIl0nKTtcbiAgICBmaXJzdEZvY3VzYWJsZUVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1swXTtcbiAgICBsYXN0Rm9jdXNhYmxlRWxlbWVudCA9IGZvY3VzYWJsZUVsZW1lbnRzW2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICB9KTtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYoY2xhc3NlcyAhPT0gc3RlcC5vcHRpb25zLmNsYXNzZXMpIHtcbiAgICAgIHVwZGF0ZUR5bmFtaWNDbGFzc2VzKCk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiB1cGRhdGVEeW5hbWljQ2xhc3NlcygpIHtcbiAgICAgIHJlbW92ZUNsYXNzZXMoY2xhc3Nlcyk7XG4gICAgICBjbGFzc2VzID0gc3RlcC5vcHRpb25zLmNsYXNzZXM7XG4gICAgICBhZGRDbGFzc2VzKGNsYXNzZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgaWYgKGlzU3RyaW5nKGNsYXNzZXMpKSB7XG4gICAgICBjb25zdCBvbGRDbGFzc2VzID0gZ2V0Q2xhc3Nlc0FycmF5KGNsYXNzZXMpO1xuICAgICAgaWYgKG9sZENsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5vbGRDbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDbGFzc2VzKGNsYXNzZXMpIHtcbiAgICBpZihpc1N0cmluZyhjbGFzc2VzKSkge1xuICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IGdldENsYXNzZXNBcnJheShjbGFzc2VzKTtcbiAgICAgIGlmIChuZXdDbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4ubmV3Q2xhc3Nlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3Nlc0FycmF5KGNsYXNzZXMpIHtcbiAgICAgcmV0dXJuIGNsYXNzZXMuc3BsaXQoJyAnKS5maWx0ZXIoY2xhc3NOYW1lID0+ICEhY2xhc3NOYW1lLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAga2V5ZG93biBldmVudHMgdG8gYWxsb3cgY2xvc2luZyB0aGUgbW9kYWwgd2l0aCBFU0NcbiAgICpcbiAgICogQm9ycm93ZWQgZnJvbSB0aGlzIGdyZWF0IHBvc3QhIGh0dHBzOi8vYml0c29mY28uZGUvYWNjZXNzaWJsZS1tb2RhbC1kaWFsb2cvXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGUpID0+IHtcbiAgICBjb25zdCB7IHRvdXIgfSA9IHN0ZXA7XG4gICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgIGNhc2UgS0VZX1RBQjpcbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWNrd2FyZCB0YWJcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZmlyc3RGb2N1c2FibGVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaGVwaGVyZC1lbGVtZW50JykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGxhc3RGb2N1c2FibGVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBsYXN0Rm9jdXNhYmxlRWxlbWVudCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZmlyc3RGb2N1c2FibGVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLRVlfRVNDOlxuICAgICAgICBpZiAodG91ci5vcHRpb25zLmV4aXRPbkVzYykge1xuICAgICAgICAgIHN0ZXAuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgIGlmICh0b3VyLm9wdGlvbnMua2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgdG91ci5iYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICBpZiAodG91ci5vcHRpb25zLmtleWJvYXJkTmF2aWdhdGlvbikge1xuICAgICAgICAgIHRvdXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1lbGVtZW50IHtcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBib3gtc2hhZG93OiAwIDFweCA0cHggcmdiYSgwLCAwLCAwLCAwLjIpO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgb3BhY2l0eTogMDtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcywgdmlzaWJpbGl0eSAwLjNzO1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB3aWR0aDogMTAwJTtcbiAgICB6LWluZGV4OiA5OTk5O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVuYWJsZWQuc2hlcGhlcmQtZWxlbWVudCB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbl06bm90KC5zaGVwaGVyZC1jZW50ZXJlZCkge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnQsIC5zaGVwaGVyZC1lbGVtZW50ICosXG4gIC5zaGVwaGVyZC1lbGVtZW50ICo6YWZ0ZXIsXG4gIC5zaGVwaGVyZC1lbGVtZW50ICo6YmVmb3JlIHtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICB9XG5cbiAgLnNoZXBoZXJkLWFycm93LFxuICAuc2hlcGhlcmQtYXJyb3c6OmJlZm9yZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHdpZHRoOiAxNnB4O1xuICAgIGhlaWdodDogMTZweDtcbiAgICB6LWluZGV4OiAtMTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1hcnJvdzpiZWZvcmUge1xuICAgIGNvbnRlbnQ6ICcnO1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcbiAgICBiYWNrZ3JvdW5kOiAjZmZmICA7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSd0b3AnXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgYm90dG9tOiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0nYm90dG9tJ10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIHRvcDogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J2xlZnQnXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgcmlnaHQ6IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdyaWdodCddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICBsZWZ0OiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnQuc2hlcGhlcmQtY2VudGVyZWQgPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cblxuXG4gIC8qKlxuICAqIEFycm93IG9uIHRvcCBvZiB0b29sdGlwIGNlbnRlcmVkIGhvcml6b250YWxseSwgd2l0aCB0aXRsZSBjb2xvclxuICAqL1xuICAuc2hlcGhlcmQtZWxlbWVudC5zaGVwaGVyZC1oYXMtdGl0bGVbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0nYm90dG9tJ10gPiAuc2hlcGhlcmQtYXJyb3c6OmJlZm9yZSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U2ZTZlNjtcbiAgfVxuXG4gIC5zaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQuc2hlcGhlcmQtZW5hYmxlZC5zaGVwaGVyZC10YXJnZXQsXG4gIC5zaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQuc2hlcGhlcmQtZW5hYmxlZC5zaGVwaGVyZC10YXJnZXQgKiB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgYXJpYS1kZXNjcmliZWRieT17IWlzVW5kZWZpbmVkKHN0ZXAub3B0aW9ucy50ZXh0KSA/IGRlc2NyaXB0aW9uSWQgOiBudWxsfVxuICBhcmlhLWxhYmVsbGVkYnk9e3N0ZXAub3B0aW9ucy50aXRsZSA/IGxhYmVsSWQgOiBudWxsfVxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGNsYXNzOnNoZXBoZXJkLWhhcy1jYW5jZWwtaWNvbj1cIntoYXNDYW5jZWxJY29ufVwiXG4gIGNsYXNzOnNoZXBoZXJkLWhhcy10aXRsZT1cIntoYXNUaXRsZX1cIlxuICBjbGFzczpzaGVwaGVyZC1lbGVtZW50PVwie3RydWV9XCJcbiAgey4uLmRhdGFTdGVwSWR9XG4gIG9uOmtleWRvd249e2hhbmRsZUtleURvd259XG4gIHJvbGU9XCJkaWFsb2dcIlxuICB0YWJpbmRleD1cIjBcIlxuPlxuICAgIHsjaWYgc3RlcC5vcHRpb25zLmFycm93ICYmIHN0ZXAub3B0aW9ucy5hdHRhY2hUbyAmJiBzdGVwLm9wdGlvbnMuYXR0YWNoVG8uZWxlbWVudCAmJiBzdGVwLm9wdGlvbnMuYXR0YWNoVG8ub259XG4gICAgICA8ZGl2IGNsYXNzPVwic2hlcGhlcmQtYXJyb3dcIiBkYXRhLXBvcHBlci1hcnJvdz48L2Rpdj5cbiAgICB7L2lmfVxuICA8U2hlcGhlcmRDb250ZW50XG4gICAge2Rlc2NyaXB0aW9uSWR9XG4gICAge2xhYmVsSWR9XG4gICAge3N0ZXB9XG4gIC8+XG48L2Rpdj5cbiIsIi8qIHNtb290aHNjcm9sbCB2MC40LjQgLSAyMDE5IC0gRHVzdGFuIEthc3RlbiwgSmVyZW1pYXMgTWVuaWNoZWxsaSAtIE1JVCBMaWNlbnNlICovXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gcG9seWZpbGxcbiAgZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgLy8gYWxpYXNlc1xuICAgIHZhciB3ID0gd2luZG93O1xuICAgIHZhciBkID0gZG9jdW1lbnQ7XG5cbiAgICAvLyByZXR1cm4gaWYgc2Nyb2xsIGJlaGF2aW9yIGlzIHN1cHBvcnRlZCBhbmQgcG9seWZpbGwgaXMgbm90IGZvcmNlZFxuICAgIGlmIChcbiAgICAgICdzY3JvbGxCZWhhdmlvcicgaW4gZC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiZcbiAgICAgIHcuX19mb3JjZVNtb290aFNjcm9sbFBvbHlmaWxsX18gIT09IHRydWVcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBnbG9iYWxzXG4gICAgdmFyIEVsZW1lbnQgPSB3LkhUTUxFbGVtZW50IHx8IHcuRWxlbWVudDtcbiAgICB2YXIgU0NST0xMX1RJTUUgPSA0Njg7XG5cbiAgICAvLyBvYmplY3QgZ2F0aGVyaW5nIG9yaWdpbmFsIHNjcm9sbCBtZXRob2RzXG4gICAgdmFyIG9yaWdpbmFsID0ge1xuICAgICAgc2Nyb2xsOiB3LnNjcm9sbCB8fCB3LnNjcm9sbFRvLFxuICAgICAgc2Nyb2xsQnk6IHcuc2Nyb2xsQnksXG4gICAgICBlbGVtZW50U2Nyb2xsOiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgfHwgc2Nyb2xsRWxlbWVudCxcbiAgICAgIHNjcm9sbEludG9WaWV3OiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIH07XG5cbiAgICAvLyBkZWZpbmUgdGltaW5nIG1ldGhvZFxuICAgIHZhciBub3cgPVxuICAgICAgdy5wZXJmb3JtYW5jZSAmJiB3LnBlcmZvcm1hbmNlLm5vd1xuICAgICAgICA/IHcucGVyZm9ybWFuY2Uubm93LmJpbmQody5wZXJmb3JtYW5jZSlcbiAgICAgICAgOiBEYXRlLm5vdztcblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgbWFkZSBieSBNaWNyb3NvZnRcbiAgICAgKiBAbWV0aG9kIGlzTWljcm9zb2Z0QnJvd3NlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyQWdlbnRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01pY3Jvc29mdEJyb3dzZXIodXNlckFnZW50KSB7XG4gICAgICB2YXIgdXNlckFnZW50UGF0dGVybnMgPSBbJ01TSUUgJywgJ1RyaWRlbnQvJywgJ0VkZ2UvJ107XG5cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVzZXJBZ2VudFBhdHRlcm5zLmpvaW4oJ3wnKSkudGVzdCh1c2VyQWdlbnQpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogSUUgaGFzIHJvdW5kaW5nIGJ1ZyByb3VuZGluZyBkb3duIGNsaWVudEhlaWdodCBhbmQgY2xpZW50V2lkdGggYW5kXG4gICAgICogcm91bmRpbmcgdXAgc2Nyb2xsSGVpZ2h0IGFuZCBzY3JvbGxXaWR0aCBjYXVzaW5nIGZhbHNlIHBvc2l0aXZlc1xuICAgICAqIG9uIGhhc1Njcm9sbGFibGVTcGFjZVxuICAgICAqL1xuICAgIHZhciBST1VORElOR19UT0xFUkFOQ0UgPSBpc01pY3Jvc29mdEJyb3dzZXIody5uYXZpZ2F0b3IudXNlckFnZW50KSA/IDEgOiAwO1xuXG4gICAgLyoqXG4gICAgICogY2hhbmdlcyBzY3JvbGwgcG9zaXRpb24gaW5zaWRlIGFuIGVsZW1lbnRcbiAgICAgKiBAbWV0aG9kIHNjcm9sbEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY3JvbGxFbGVtZW50KHgsIHkpIHtcbiAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHg7XG4gICAgICB0aGlzLnNjcm9sbFRvcCA9IHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyByZXN1bHQgb2YgYXBwbHlpbmcgZWFzZSBtYXRoIGZ1bmN0aW9uIHRvIGEgbnVtYmVyXG4gICAgICogQG1ldGhvZCBlYXNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVhc2Uoaykge1xuICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYSBzbW9vdGggYmVoYXZpb3Igc2hvdWxkIGJlIGFwcGxpZWRcbiAgICAgKiBAbWV0aG9kIHNob3VsZEJhaWxPdXRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IGZpcnN0QXJnXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvdWxkQmFpbE91dChmaXJzdEFyZykge1xuICAgICAgaWYgKFxuICAgICAgICBmaXJzdEFyZyA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgZmlyc3RBcmcgIT09ICdvYmplY3QnIHx8XG4gICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdhdXRvJyB8fFxuICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciA9PT0gJ2luc3RhbnQnXG4gICAgICApIHtcbiAgICAgICAgLy8gZmlyc3QgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdC9udWxsXG4gICAgICAgIC8vIG9yIGJlaGF2aW9yIGlzIGF1dG8sIGluc3RhbnQgb3IgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnb2JqZWN0JyAmJiBmaXJzdEFyZy5iZWhhdmlvciA9PT0gJ3Ntb290aCcpIHtcbiAgICAgICAgLy8gZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0IGFuZCBiZWhhdmlvciBpcyBzbW9vdGhcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyB0aHJvdyBlcnJvciB3aGVuIGJlaGF2aW9yIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdiZWhhdmlvciBtZW1iZXIgb2YgU2Nyb2xsT3B0aW9ucyAnICtcbiAgICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciArXG4gICAgICAgICAgJyBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgZW51bWVyYXRpb24gU2Nyb2xsQmVoYXZpb3IuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYW4gZWxlbWVudCBoYXMgc2Nyb2xsYWJsZSBzcGFjZSBpbiB0aGUgcHJvdmlkZWQgYXhpc1xuICAgICAqIEBtZXRob2QgaGFzU2Nyb2xsYWJsZVNwYWNlXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzU2Nyb2xsYWJsZVNwYWNlKGVsLCBheGlzKSB7XG4gICAgICBpZiAoYXhpcyA9PT0gJ1knKSB7XG4gICAgICAgIHJldHVybiBlbC5jbGllbnRIZWlnaHQgKyBST1VORElOR19UT0xFUkFOQ0UgPCBlbC5zY3JvbGxIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChheGlzID09PSAnWCcpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsaWVudFdpZHRoICsgUk9VTkRJTkdfVE9MRVJBTkNFIDwgZWwuc2Nyb2xsV2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgaGFzIGEgc2Nyb2xsYWJsZSBvdmVyZmxvdyBwcm9wZXJ0eSBpbiB0aGUgYXhpc1xuICAgICAqIEBtZXRob2QgY2FuT3ZlcmZsb3dcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYW5PdmVyZmxvdyhlbCwgYXhpcykge1xuICAgICAgdmFyIG92ZXJmbG93VmFsdWUgPSB3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpWydvdmVyZmxvdycgKyBheGlzXTtcblxuICAgICAgcmV0dXJuIG92ZXJmbG93VmFsdWUgPT09ICdhdXRvJyB8fCBvdmVyZmxvd1ZhbHVlID09PSAnc2Nyb2xsJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYW4gZWxlbWVudCBjYW4gYmUgc2Nyb2xsZWQgaW4gZWl0aGVyIGF4aXNcbiAgICAgKiBAbWV0aG9kIGlzU2Nyb2xsYWJsZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXhpc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2Nyb2xsYWJsZShlbCkge1xuICAgICAgdmFyIGlzU2Nyb2xsYWJsZVkgPSBoYXNTY3JvbGxhYmxlU3BhY2UoZWwsICdZJykgJiYgY2FuT3ZlcmZsb3coZWwsICdZJyk7XG4gICAgICB2YXIgaXNTY3JvbGxhYmxlWCA9IGhhc1Njcm9sbGFibGVTcGFjZShlbCwgJ1gnKSAmJiBjYW5PdmVyZmxvdyhlbCwgJ1gnKTtcblxuICAgICAgcmV0dXJuIGlzU2Nyb2xsYWJsZVkgfHwgaXNTY3JvbGxhYmxlWDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaW5kcyBzY3JvbGxhYmxlIHBhcmVudCBvZiBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBmaW5kU2Nyb2xsYWJsZVBhcmVudFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX0gZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kU2Nyb2xsYWJsZVBhcmVudChlbCkge1xuICAgICAgd2hpbGUgKGVsICE9PSBkLmJvZHkgJiYgaXNTY3JvbGxhYmxlKGVsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlIHx8IGVsLmhvc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxmIGludm9rZWQgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xuICAgICAqIEBtZXRob2Qgc3RlcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGVwKGNvbnRleHQpIHtcbiAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YXIgY3VycmVudFg7XG4gICAgICB2YXIgY3VycmVudFk7XG4gICAgICB2YXIgZWxhcHNlZCA9ICh0aW1lIC0gY29udGV4dC5zdGFydFRpbWUpIC8gU0NST0xMX1RJTUU7XG5cbiAgICAgIC8vIGF2b2lkIGVsYXBzZWQgdGltZXMgaGlnaGVyIHRoYW4gb25lXG4gICAgICBlbGFwc2VkID0gZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcblxuICAgICAgLy8gYXBwbHkgZWFzaW5nIHRvIGVsYXBzZWQgdGltZVxuICAgICAgdmFsdWUgPSBlYXNlKGVsYXBzZWQpO1xuXG4gICAgICBjdXJyZW50WCA9IGNvbnRleHQuc3RhcnRYICsgKGNvbnRleHQueCAtIGNvbnRleHQuc3RhcnRYKSAqIHZhbHVlO1xuICAgICAgY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcblxuICAgICAgY29udGV4dC5tZXRob2QuY2FsbChjb250ZXh0LnNjcm9sbGFibGUsIGN1cnJlbnRYLCBjdXJyZW50WSk7XG5cbiAgICAgIC8vIHNjcm9sbCBtb3JlIGlmIHdlIGhhdmUgbm90IHJlYWNoZWQgb3VyIGRlc3RpbmF0aW9uXG4gICAgICBpZiAoY3VycmVudFggIT09IGNvbnRleHQueCB8fCBjdXJyZW50WSAhPT0gY29udGV4dC55KSB7XG4gICAgICAgIHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXAuYmluZCh3LCBjb250ZXh0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2Nyb2xscyB3aW5kb3cgb3IgZWxlbWVudCB3aXRoIGEgc21vb3RoIGJlaGF2aW9yXG4gICAgICogQG1ldGhvZCBzbW9vdGhTY3JvbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNtb290aFNjcm9sbChlbCwgeCwgeSkge1xuICAgICAgdmFyIHNjcm9sbGFibGU7XG4gICAgICB2YXIgc3RhcnRYO1xuICAgICAgdmFyIHN0YXJ0WTtcbiAgICAgIHZhciBtZXRob2Q7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gbm93KCk7XG5cbiAgICAgIC8vIGRlZmluZSBzY3JvbGwgY29udGV4dFxuICAgICAgaWYgKGVsID09PSBkLmJvZHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IHc7XG4gICAgICAgIHN0YXJ0WCA9IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0O1xuICAgICAgICBzdGFydFkgPSB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldDtcbiAgICAgICAgbWV0aG9kID0gb3JpZ2luYWwuc2Nyb2xsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IGVsO1xuICAgICAgICBzdGFydFggPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBzdGFydFkgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIG1ldGhvZCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNjcm9sbCBsb29waW5nIG92ZXIgYSBmcmFtZVxuICAgICAgc3RlcCh7XG4gICAgICAgIHNjcm9sbGFibGU6IHNjcm9sbGFibGUsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgIHN0YXJ0WTogc3RhcnRZLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPUklHSU5BTCBNRVRIT0RTIE9WRVJSSURFU1xuICAgIC8vIHcuc2Nyb2xsIGFuZCB3LnNjcm9sbFRvXG4gICAgdy5zY3JvbGwgPSB3LnNjcm9sbFRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBhY3Rpb24gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGwuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMF1cbiAgICAgICAgICAgICAgOiB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAvLyB1c2UgdG9wIHByb3AsIHNlY29uZCBhcmd1bWVudCBpZiBwcmVzZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbFlcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IGFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgICA6IHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgOiB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCxcbiAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICA6IHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyB3LnNjcm9sbEJ5XG4gICAgdy5zY3JvbGxCeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsQnkuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCcgPyBhcmd1bWVudHNbMF0gOiAwLFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgICA6IGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgIHcsXG4gICAgICAgIGQuYm9keSxcbiAgICAgICAgfn5hcmd1bWVudHNbMF0ubGVmdCArICh3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLnRvcCArICh3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCBhbmQgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgPSBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gaWYgb25lIG51bWJlciBpcyBwYXNzZWQsIHRocm93IGVycm9yIHRvIG1hdGNoIEZpcmVmb3ggaW1wbGVtZW50YXRpb25cbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmIGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdWYWx1ZSBjb3VsZCBub3QgYmUgY29udmVydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnaW5hbC5lbGVtZW50U2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAvLyB1c2UgbGVmdCBwcm9wLCBmaXJzdCBudW1iZXIgYXJndW1lbnQgb3IgZmFsbGJhY2sgdG8gc2Nyb2xsTGVmdFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgICAgOiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0JyA/IH5+YXJndW1lbnRzWzBdIDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIC8vIHVzZSB0b3AgcHJvcCwgc2Vjb25kIGFyZ3VtZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbFRvcFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICAgIDogYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyB+fmFyZ3VtZW50c1sxXSA6IHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdCA9IGFyZ3VtZW50c1swXS5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IGFyZ3VtZW50c1swXS50b3A7XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLFxuICAgICAgICB0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNjcm9sbExlZnQgOiB+fmxlZnQsXG4gICAgICAgIHR5cGVvZiB0b3AgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zY3JvbGxUb3AgOiB+fnRvcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnlcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgb3JpZ2luYWwuZWxlbWVudFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgdGhpcy5zY3JvbGxMZWZ0XG4gICAgICAgICAgICA6IH5+YXJndW1lbnRzWzBdICsgdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3AgKyB0aGlzLnNjcm9sbFRvcFxuICAgICAgICAgICAgOiB+fmFyZ3VtZW50c1sxXSArIHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbCh7XG4gICAgICAgIGxlZnQ6IH5+YXJndW1lbnRzWzBdLmxlZnQgKyB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgIHRvcDogfn5hcmd1bWVudHNbMF0udG9wICsgdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgIGJlaGF2aW9yOiBhcmd1bWVudHNbMF0uYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEludG9WaWV3LmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMF1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHZhciBzY3JvbGxhYmxlUGFyZW50ID0gZmluZFNjcm9sbGFibGVQYXJlbnQodGhpcyk7XG4gICAgICB2YXIgcGFyZW50UmVjdHMgPSBzY3JvbGxhYmxlUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGNsaWVudFJlY3RzID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHNjcm9sbGFibGVQYXJlbnQgIT09IGQuYm9keSkge1xuICAgICAgICAvLyByZXZlYWwgZWxlbWVudCBpbnNpZGUgcGFyZW50XG4gICAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbExlZnQgKyBjbGllbnRSZWN0cy5sZWZ0IC0gcGFyZW50UmVjdHMubGVmdCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbFRvcCArIGNsaWVudFJlY3RzLnRvcCAtIHBhcmVudFJlY3RzLnRvcFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJldmVhbCBwYXJlbnQgaW4gdmlld3BvcnQgdW5sZXNzIGlzIGZpeGVkXG4gICAgICAgIGlmICh3LmdldENvbXB1dGVkU3R5bGUoc2Nyb2xsYWJsZVBhcmVudCkucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICAgIGxlZnQ6IHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgICB0b3A6IHBhcmVudFJlY3RzLnRvcCxcbiAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXZlYWwgZWxlbWVudCBpbiB2aWV3cG9ydFxuICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICBsZWZ0OiBjbGllbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgIHRvcDogY2xpZW50UmVjdHMudG9wLFxuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNvbW1vbmpzXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7IHBvbHlmaWxsOiBwb2x5ZmlsbCB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGdsb2JhbFxuICAgIHBvbHlmaWxsKCk7XG4gIH1cblxufSgpKTtcbiIsImltcG9ydCBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IHsgRXZlbnRlZCB9IGZyb20gJy4vZXZlbnRlZC5qcyc7XG5pbXBvcnQgYXV0b0JpbmQgZnJvbSAnLi91dGlscy9hdXRvLWJpbmQuanMnO1xuaW1wb3J0IHtcbiAgaXNFbGVtZW50LFxuICBpc0hUTUxFbGVtZW50LFxuICBpc0Z1bmN0aW9uLFxuICBpc1VuZGVmaW5lZFxufSBmcm9tICcuL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuaW1wb3J0IHsgYmluZEFkdmFuY2UgfSBmcm9tICcuL3V0aWxzL2JpbmQuanMnO1xuaW1wb3J0IHtcbiAgc2V0dXBUb29sdGlwLFxuICBwYXJzZUF0dGFjaFRvLFxuICBub3JtYWxpemVQcmVmaXgsXG4gIHV1aWRcbn0gZnJvbSAnLi91dGlscy9nZW5lcmFsLmpzJztcbmltcG9ydCBTaGVwaGVyZEVsZW1lbnQgZnJvbSAnLi9jb21wb25lbnRzL3NoZXBoZXJkLWVsZW1lbnQuc3ZlbHRlJztcblxuLy8gUG9seWZpbGxzXG5pbXBvcnQgc21vb3Roc2Nyb2xsIGZyb20gJ3Ntb290aHNjcm9sbC1wb2x5ZmlsbCc7XG5zbW9vdGhzY3JvbGwucG9seWZpbGwoKTtcblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBzdGVwcyB0byBiZSBhZGRlZCB0byBhIHRvdXIuXG4gKiBAZXh0ZW5kcyB7RXZlbnRlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIFN0ZXAgZXh0ZW5kcyBFdmVudGVkIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN0ZXBcbiAgICogQHBhcmFtIHtUb3VyfSB0b3VyIFRoZSB0b3VyIGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmFycm93IFdoZXRoZXIgdG8gZGlzcGxheSB0aGUgYXJyb3cgZm9yIHRoZSB0b29sdGlwIG9yIG5vdC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5hdHRhY2hUbyBUaGUgZWxlbWVudCB0aGUgc3RlcCBzaG91bGQgYmUgYXR0YWNoZWQgdG8gb24gdGhlIHBhZ2UuXG4gICAqIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgYGVsZW1lbnRgIGFuZCBgb25gLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBzdGVwID0gbmV3IFN0ZXAodG91ciwge1xuICAgKiAgIGF0dGFjaFRvOiB7IGVsZW1lbnQ6ICcuc29tZSAuc2VsZWN0b3ItcGF0aCcsIG9uOiAnbGVmdCcgfSxcbiAgICogICAuLi5tb3JlT3B0aW9uc1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIElmIHlvdSBkb27igJl0IHNwZWNpZnkgYW4gYGF0dGFjaFRvYCB0aGUgZWxlbWVudCB3aWxsIGFwcGVhciBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4uIFRoZSBzYW1lIHdpbGwgaGFwcGVuIGlmIHlvdXIgYGF0dGFjaFRvLmVsZW1lbnRgIGNhbGxiYWNrIHJldHVybnMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3IgYSBzZWxlY3RvciB0aGF0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBET00uXG4gICAqIElmIHlvdSBvbWl0IHRoZSBgb25gIHBvcnRpb24gb2YgYGF0dGFjaFRvYCwgdGhlIGVsZW1lbnQgd2lsbCBzdGlsbCBiZSBoaWdobGlnaHRlZCwgYnV0IHRoZSB0b29sdGlwIHdpbGwgYXBwZWFyXG4gICAqIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbiwgd2l0aG91dCBhbiBhcnJvdyBwb2ludGluZyB0byB0aGUgdGFyZ2V0LlxuICAgKiBJZiB0aGUgZWxlbWVudCB0byBoaWdobGlnaHQgZG9lcyBub3QgeWV0IGV4aXN0IHdoaWxlIGluc3RhbnRpYXRpbmcgdG91ciBzdGVwcywgeW91IG1heSB1c2UgbGF6eSBldmFsdWF0aW9uIGJ5IHN1cHBseWluZyBhIGZ1bmN0aW9uIHRvIGBhdHRhY2hUby5lbGVtZW50YC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBgYmVmb3JlLXNob3dgIHBoYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MRWxlbWVudHxmdW5jdGlvbn0gb3B0aW9ucy5hdHRhY2hUby5lbGVtZW50IEFuIGVsZW1lbnQgc2VsZWN0b3Igc3RyaW5nLCBET00gZWxlbWVudCwgb3IgYSBmdW5jdGlvbiAocmV0dXJuaW5nIGEgc2VsZWN0b3IsIGEgRE9NIGVsZW1lbnQsIGBudWxsYCBvciBgdW5kZWZpbmVkYCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmF0dGFjaFRvLm9uIFRoZSBvcHRpb25hbCBkaXJlY3Rpb24gdG8gcGxhY2UgdGhlIFBvcHBlciB0b29sdGlwIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50LlxuICAgKiAgIC0gUG9zc2libGUgc3RyaW5nIHZhbHVlczogJ2F1dG8nLCAnYXV0by1zdGFydCcsICdhdXRvLWVuZCcsICd0b3AnLCAndG9wLXN0YXJ0JywgJ3RvcC1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdib3R0b20tZW5kJywgJ3JpZ2h0JywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnLCAnbGVmdC1lbmQnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmFkdmFuY2VPbiBBbiBhY3Rpb24gb24gdGhlIHBhZ2Ugd2hpY2ggc2hvdWxkIGFkdmFuY2Ugc2hlcGhlcmQgdG8gdGhlIG5leHQgc3RlcC5cbiAgICogSXQgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGEgc3RyaW5nIGBzZWxlY3RvcmAgYW5kIGFuIGBldmVudGAgbmFtZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBzdGVwID0gbmV3IFN0ZXAodG91ciwge1xuICAgKiAgIGFkdmFuY2VPbjogeyBzZWxlY3RvcjogJy5zb21lIC5zZWxlY3Rvci1wYXRoJywgZXZlbnQ6ICdjbGljaycgfSxcbiAgICogICAuLi5tb3JlT3B0aW9uc1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIGBldmVudGAgZG9lc27igJl0IGhhdmUgdG8gYmUgYW4gZXZlbnQgaW5zaWRlIHRoZSB0b3VyLCBpdCBjYW4gYmUgYW55IGV2ZW50IGZpcmVkIG9uIGFueSBlbGVtZW50IG9uIHRoZSBwYWdlLlxuICAgKiBZb3UgY2FuIGFsc28gYWx3YXlzIG1hbnVhbGx5IGFkdmFuY2UgdGhlIFRvdXIgYnkgY2FsbGluZyBgbXlUb3VyLm5leHQoKWAuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuYmVmb3JlU2hvd1Byb21pc2UgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICAgKiBXaGVuIHRoZSBwcm9taXNlIHJlc29sdmVzLCB0aGUgcmVzdCBvZiB0aGUgYHNob3dgIGNvZGUgZm9yIHRoZSBzdGVwIHdpbGwgZXhlY3V0ZS5cbiAgICogQHBhcmFtIHtPYmplY3RbXX0gb3B0aW9ucy5idXR0b25zIEFuIGFycmF5IG9mIGJ1dHRvbnMgdG8gYWRkIHRvIHRoZSBzdGVwLiBUaGVzZSB3aWxsIGJlIHJlbmRlcmVkIGluIGFcbiAgICogZm9vdGVyIGJlbG93IHRoZSBtYWluIGJvZHkgdGV4dC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5hY3Rpb24gQSBmdW5jdGlvbiBleGVjdXRlZCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZCBvbi5cbiAgICogSXQgaXMgYXV0b21hdGljYWxseSBib3VuZCB0byB0aGUgYHRvdXJgIHRoZSBzdGVwIGlzIGFzc29jaWF0ZWQgd2l0aCwgc28gdGhpbmdzIGxpa2UgYHRoaXMubmV4dGAgd2lsbFxuICAgKiB3b3JrIGluc2lkZSB0aGUgYWN0aW9uLlxuICAgKiBZb3UgY2FuIHVzZSBhY3Rpb24gdG8gc2tpcCBzdGVwcyBvciBuYXZpZ2F0ZSB0byBzcGVjaWZpYyBzdGVwcywgd2l0aCBzb21ldGhpbmcgbGlrZTpcbiAgICogYGBganNcbiAgICogYWN0aW9uKCkge1xuICAgKiAgIHJldHVybiB0aGlzLnNob3coJ3NvbWVfc3RlcF9uYW1lJyk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmNsYXNzZXMgRXh0cmEgY2xhc3NlcyB0byBhcHBseSB0byB0aGUgYDxhPmBcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmRpc2FibGVkIFNob3VsZCB0aGUgYnV0dG9uIGJlIGRpc2FibGVkP1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5sYWJlbCBUaGUgYXJpYS1sYWJlbCB0ZXh0IG9mIHRoZSBidXR0b25cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLnNlY29uZGFyeSBJZiB0cnVlLCBhIHNoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnkgY2xhc3MgaXMgYXBwbGllZCB0byB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLnRleHQgVGhlIEhUTUwgdGV4dCBvZiB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jYW5DbGlja1RhcmdldCBBIGJvb2xlYW4sIHRoYXQgd2hlbiBzZXQgdG8gZmFsc2UsIHdpbGwgc2V0IGBwb2ludGVyLWV2ZW50czogbm9uZWAgb24gdGhlIHRhcmdldFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jYW5jZWxJY29uIE9wdGlvbnMgZm9yIHRoZSBjYW5jZWwgaWNvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY2FuY2VsSWNvbi5lbmFibGVkIFNob3VsZCBhIGNhbmNlbCDigJzinJXigJ0gYmUgc2hvd24gaW4gdGhlIGhlYWRlciBvZiB0aGUgc3RlcD9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2FuY2VsSWNvbi5sYWJlbCBUaGUgbGFiZWwgdG8gYWRkIGZvciBgYXJpYS1sYWJlbGBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xhc3NlcyBBIHN0cmluZyBvZiBleHRyYSBjbGFzc2VzIHRvIGFkZCB0byB0aGUgc3RlcCdzIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MgQW4gZXh0cmEgY2xhc3MgdG8gYXBwbHkgdG8gdGhlIGBhdHRhY2hUb2AgZWxlbWVudCB3aGVuIGl0IGlzXG4gICAqIGhpZ2hsaWdodGVkICh0aGF0IGlzLCB3aGVuIGl0cyBzdGVwIGlzIGFjdGl2ZSkuIFlvdSBjYW4gdGhlbiB0YXJnZXQgdGhhdCBzZWxlY3RvciBpbiB5b3VyIENTUy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaWQgVGhlIHN0cmluZyB0byB1c2UgYXMgdGhlIGBpZGAgZm9yIHRoZSBzdGVwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyBBbiBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyBBbiBhbW91bnQgb2YgYm9yZGVyIHJhZGl1cyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMucG9wcGVyT3B0aW9ucyBFeHRyYSBvcHRpb25zIHRvIHBhc3MgdG8gUG9wcGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IG9wdGlvbnMuc2Nyb2xsVG8gU2hvdWxkIHRoZSBlbGVtZW50IGJlIHNjcm9sbGVkIHRvIHdoZW4gdGhpcyBzdGVwIGlzIHNob3duPyBJZiB0cnVlLCB1c2VzIHRoZSBkZWZhdWx0IGBzY3JvbGxJbnRvVmlld2AsXG4gICAqIGlmIGFuIG9iamVjdCwgcGFzc2VzIHRoYXQgb2JqZWN0IGFzIHRoZSBwYXJhbXMgdG8gYHNjcm9sbEludG9WaWV3YCBpLmUuIGB7YmVoYXZpb3I6ICdzbW9vdGgnLCBibG9jazogJ2NlbnRlcid9YFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLnNjcm9sbFRvSGFuZGxlciBBIGZ1bmN0aW9uIHRoYXQgbGV0cyB5b3Ugb3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2Nyb2xsVG8gYmVoYXZpb3IgYW5kXG4gICAqIGRlZmluZSBhIGN1c3RvbSBhY3Rpb24gdG8gZG8gdGhlIHNjcm9sbGluZywgYW5kIHBvc3NpYmx5IG90aGVyIGxvZ2ljLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLnNob3dPbiBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gaXQgcmV0dXJucyBgdHJ1ZWAsIHdpbGwgc2hvdyB0aGUgc3RlcC5cbiAgICogSWYgaXQgcmV0dXJucyBmYWxzZSwgdGhlIHN0ZXAgd2lsbCBiZSBza2lwcGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50ZXh0IFRoZSB0ZXh0IGluIHRoZSBib2R5IG9mIHRoZSBzdGVwLiBJdCBjYW4gYmUgb25lIG9mIHRocmVlIHR5cGVzOlxuICAgKiBgYGBcbiAgICogLSBIVE1MIHN0cmluZ1xuICAgKiAtIGBIVE1MRWxlbWVudGAgb2JqZWN0XG4gICAqIC0gYEZ1bmN0aW9uYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBzdGVwIGlzIGJ1aWx0LiBJdCBtdXN0IHJldHVybiBvbmUgdGhlIHR3byBvcHRpb25zIGFib3ZlLlxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGl0bGUgVGhlIHN0ZXAncyB0aXRsZS4gSXQgYmVjb21lcyBhbiBgaDNgIGF0IHRoZSB0b3Agb2YgdGhlIHN0ZXAuIEl0IGNhbiBiZSBvbmUgb2YgdHdvIHR5cGVzOlxuICAgKiBgYGBcbiAgICogLSBIVE1MIHN0cmluZ1xuICAgKiAtIGBGdW5jdGlvbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgc3RlcCBpcyBidWlsdC4gSXQgbXVzdCByZXR1cm4gSFRNTCBzdHJpbmcuXG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy53aGVuIFlvdSBjYW4gZGVmaW5lIGBzaG93YCwgYGhpZGVgLCBldGMgZXZlbnRzIGluc2lkZSBgd2hlbmAuIEZvciBleGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB3aGVuOiB7XG4gICAqICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAqICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKiBAcmV0dXJuIHtTdGVwfSBUaGUgbmV3bHkgY3JlYXRlZCBTdGVwIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0b3VyLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0b3VyLCBvcHRpb25zKTtcbiAgICB0aGlzLnRvdXIgPSB0b3VyO1xuICAgIHRoaXMuY2xhc3NQcmVmaXggPSB0aGlzLnRvdXIub3B0aW9uc1xuICAgICAgPyBub3JtYWxpemVQcmVmaXgodGhpcy50b3VyLm9wdGlvbnMuY2xhc3NQcmVmaXgpXG4gICAgICA6ICcnO1xuICAgIHRoaXMuc3R5bGVzID0gdG91ci5zdHlsZXM7XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCBhdHRhY2hUbyBvcHRpb25zLiBEdWUgdG8gbGF6eSBldmFsdWF0aW9uLCB3ZSBvbmx5IHJlc29sdmUgdGhlIG9wdGlvbnMgZHVyaW5nIGBiZWZvcmUtc2hvd2AgcGhhc2UuXG4gICAgICogRG8gbm90IHVzZSB0aGlzIGRpcmVjdGx5LCB1c2UgdGhlIF9nZXRSZXNvbHZlZEF0dGFjaFRvT3B0aW9ucyBtZXRob2QgaW5zdGVhZC5cbiAgICAgKiBAdHlwZSB7bnVsbHx7fXx7ZWxlbWVudCwgdG99fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVzb2x2ZWRBdHRhY2hUbyA9IG51bGw7XG5cbiAgICBhdXRvQmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgdGhlIHRvdXJcbiAgICogVHJpZ2dlcnMgdGhlIGBjYW5jZWxgIGV2ZW50XG4gICAqL1xuICBjYW5jZWwoKSB7XG4gICAgdGhpcy50b3VyLmNhbmNlbCgpO1xuICAgIHRoaXMudHJpZ2dlcignY2FuY2VsJyk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGxldGUgdGhlIHRvdXJcbiAgICogVHJpZ2dlcnMgdGhlIGBjb21wbGV0ZWAgZXZlbnRcbiAgICovXG4gIGNvbXBsZXRlKCkge1xuICAgIHRoaXMudG91ci5jb21wbGV0ZSgpO1xuICAgIHRoaXMudHJpZ2dlcignY29tcGxldGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHN0ZXAsIGRlbGV0ZSB0aGUgc3RlcCdzIGVsZW1lbnQsIGFuZCBkZXN0cm95IHRoZSBQb3BwZXIgaW5zdGFuY2UgZm9yIHRoZSBzdGVwLlxuICAgKiBUcmlnZ2VycyBgZGVzdHJveWAgZXZlbnRcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMudG9vbHRpcCkge1xuICAgICAgdGhpcy50b29sdGlwLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMudG9vbHRpcCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGhpcy5lbCkgJiYgdGhpcy5lbC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbCk7XG4gICAgICB0aGlzLmVsID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVTdGVwVGFyZ2V0T25IaWRlKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2Rlc3Ryb3knKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3VyIGZvciB0aGUgc3RlcFxuICAgKiBAcmV0dXJuIHtUb3VyfSBUaGUgdG91ciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0VG91cigpIHtcbiAgICByZXR1cm4gdGhpcy50b3VyO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIHN0ZXBcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy50b3VyLm1vZGFsLmhpZGUoKTtcblxuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlLWhpZGUnKTtcblxuICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICB0aGlzLmVsLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlU3RlcFRhcmdldE9uSGlkZSgpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdoaWRlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYXR0YWNoVG8gb3B0aW9ucy5cbiAgICogQHJldHVybnMge3t9fHtlbGVtZW50LCBvbn19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzb2x2ZUF0dGFjaFRvT3B0aW9ucygpIHtcbiAgICB0aGlzLl9yZXNvbHZlZEF0dGFjaFRvID0gcGFyc2VBdHRhY2hUbyh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRBdHRhY2hUbztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNlbGVjdG9yIGZvciByZXNvbHZlZCBhdHRhY2hUbyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7e318e2VsZW1lbnQsIG9ufX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRSZXNvbHZlZEF0dGFjaFRvT3B0aW9ucygpIHtcbiAgICBpZiAodGhpcy5fcmVzb2x2ZWRBdHRhY2hUbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVBdHRhY2hUb09wdGlvbnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRBdHRhY2hUbztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc3RlcCBpcyBvcGVuIGFuZCB2aXNpYmxlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0ZXAgaXMgb3BlbiBhbmQgdmlzaWJsZVxuICAgKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuZWwgJiYgIXRoaXMuZWwuaGlkZGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcyBgX3Nob3dgIGFuZCBlbnN1cmVzIGBiZWZvcmVTaG93UHJvbWlzZWAgcmVzb2x2ZXMgYmVmb3JlIGNhbGxpbmcgc2hvd1xuICAgKiBAcmV0dXJuIHsqfFByb21pc2V9XG4gICAqL1xuICBzaG93KCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5iZWZvcmVTaG93UHJvbWlzZSkpIHtcbiAgICAgIGNvbnN0IGJlZm9yZVNob3dQcm9taXNlID0gdGhpcy5vcHRpb25zLmJlZm9yZVNob3dQcm9taXNlKCk7XG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKGJlZm9yZVNob3dQcm9taXNlKSkge1xuICAgICAgICByZXR1cm4gYmVmb3JlU2hvd1Byb21pc2UudGhlbigoKSA9PiB0aGlzLl9zaG93KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zaG93KCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgb3B0aW9ucyBvZiB0aGUgc3RlcC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBzdGVwXG4gICAqL1xuICB1cGRhdGVTdGVwT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50KSB7XG4gICAgICB0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudC4kc2V0KHsgc3RlcDogdGhpcyB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudCBmb3IgdGhlIHN0ZXBcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbHx1bmRlZmluZWR9IFRoZSBlbGVtZW50IGluc3RhbmNlLiB1bmRlZmluZWQgaWYgaXQgaGFzIG5ldmVyIGJlZW4gc2hvd24sIG51bGwgaWYgaXQgaGFzIGJlZW4gZGVzdHJveWVkXG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhcmdldCBmb3IgdGhlIHN0ZXBcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbHx1bmRlZmluZWR9IFRoZSBlbGVtZW50IGluc3RhbmNlLiB1bmRlZmluZWQgaWYgaXQgaGFzIG5ldmVyIGJlZW4gc2hvd24sIG51bGwgaWYgcXVlcnkgc3RyaW5nIGhhcyBub3QgYmVlbiBmb3VuZFxuICAgKi9cbiAgZ2V0VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFNoZXBoZXJkIGVsZW1lbnQgZm9yIHN0ZXAgYmFzZWQgb24gb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUgRE9NIGVsZW1lbnQgZm9yIHRoZSBzdGVwIHRvb2x0aXBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVUb29sdGlwQ29udGVudCgpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbklkID0gYCR7dGhpcy5pZH0tZGVzY3JpcHRpb25gO1xuICAgIGNvbnN0IGxhYmVsSWQgPSBgJHt0aGlzLmlkfS1sYWJlbGA7XG5cbiAgICB0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudCA9IG5ldyBTaGVwaGVyZEVsZW1lbnQoe1xuICAgICAgdGFyZ2V0OiB0aGlzLnRvdXIub3B0aW9ucy5zdGVwc0NvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5LFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xhc3NQcmVmaXg6IHRoaXMuY2xhc3NQcmVmaXgsXG4gICAgICAgIGRlc2NyaXB0aW9uSWQsXG4gICAgICAgIGxhYmVsSWQsXG4gICAgICAgIHN0ZXA6IHRoaXMsXG4gICAgICAgIHN0eWxlczogdGhpcy5zdHlsZXNcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudC5nZXRFbGVtZW50KCk7XG4gIH1cblxuICAvKipcbiAgICogSWYgYSBjdXN0b20gc2Nyb2xsVG9IYW5kbGVyIGlzIGRlZmluZWQsIGNhbGwgdGhhdCwgb3RoZXJ3aXNlIGRvIHRoZSBnZW5lcmljXG4gICAqIHNjcm9sbEludG9WaWV3IGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IHNjcm9sbFRvT3B0aW9ucyBJZiB0cnVlLCB1c2VzIHRoZSBkZWZhdWx0IGBzY3JvbGxJbnRvVmlld2AsXG4gICAqIGlmIGFuIG9iamVjdCwgcGFzc2VzIHRoYXQgb2JqZWN0IGFzIHRoZSBwYXJhbXMgdG8gYHNjcm9sbEludG9WaWV3YCBpLmUuIGB7IGJlaGF2aW9yOiAnc21vb3RoJywgYmxvY2s6ICdjZW50ZXInIH1gXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2Nyb2xsVG8oc2Nyb2xsVG9PcHRpb25zKSB7XG4gICAgY29uc3QgeyBlbGVtZW50IH0gPSB0aGlzLl9nZXRSZXNvbHZlZEF0dGFjaFRvT3B0aW9ucygpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnNjcm9sbFRvSGFuZGxlcikpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxUb0hhbmRsZXIoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGlzRWxlbWVudChlbGVtZW50KSAmJlxuICAgICAgdHlwZW9mIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcgPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoc2Nyb2xsVG9PcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogX2dldENsYXNzT3B0aW9ucyBnZXRzIGFsbCBwb3NzaWJsZSBjbGFzc2VzIGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RlcE9wdGlvbnMgVGhlIHN0ZXAgc3BlY2lmaWMgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1bmlxdWUgc3RyaW5nIGZyb20gYXJyYXkgb2YgY2xhc3Nlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldENsYXNzT3B0aW9ucyhzdGVwT3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRTdGVwT3B0aW9ucyA9XG4gICAgICB0aGlzLnRvdXIgJiYgdGhpcy50b3VyLm9wdGlvbnMgJiYgdGhpcy50b3VyLm9wdGlvbnMuZGVmYXVsdFN0ZXBPcHRpb25zO1xuICAgIGNvbnN0IHN0ZXBDbGFzc2VzID0gc3RlcE9wdGlvbnMuY2xhc3NlcyA/IHN0ZXBPcHRpb25zLmNsYXNzZXMgOiAnJztcbiAgICBjb25zdCBkZWZhdWx0U3RlcE9wdGlvbnNDbGFzc2VzID1cbiAgICAgIGRlZmF1bHRTdGVwT3B0aW9ucyAmJiBkZWZhdWx0U3RlcE9wdGlvbnMuY2xhc3Nlc1xuICAgICAgICA/IGRlZmF1bHRTdGVwT3B0aW9ucy5jbGFzc2VzXG4gICAgICAgIDogJyc7XG4gICAgY29uc3QgYWxsQ2xhc3NlcyA9IFtcbiAgICAgIC4uLnN0ZXBDbGFzc2VzLnNwbGl0KCcgJyksXG4gICAgICAuLi5kZWZhdWx0U3RlcE9wdGlvbnNDbGFzc2VzLnNwbGl0KCcgJylcbiAgICBdO1xuICAgIGNvbnN0IHVuaXFDbGFzc2VzID0gbmV3IFNldChhbGxDbGFzc2VzKTtcblxuICAgIHJldHVybiBBcnJheS5mcm9tKHVuaXFDbGFzc2VzKS5qb2luKCcgJykudHJpbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9wdGlvbnMgZm9yIHRoZSBzdGVwLCBtYXBzIGB3aGVuYCB0byBldmVudHMsIHNldHMgdXAgYnV0dG9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRPcHRpb25zKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB0b3VyT3B0aW9ucyA9XG4gICAgICB0aGlzLnRvdXIgJiYgdGhpcy50b3VyLm9wdGlvbnMgJiYgdGhpcy50b3VyLm9wdGlvbnMuZGVmYXVsdFN0ZXBPcHRpb25zO1xuXG4gICAgdG91ck9wdGlvbnMgPSBtZXJnZSh7fSwgdG91ck9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgYXJyb3c6IHRydWVcbiAgICAgIH0sXG4gICAgICB0b3VyT3B0aW9ucyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgY29uc3QgeyB3aGVuIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0aGlzLm9wdGlvbnMuY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuaWQgfHwgYHN0ZXAtJHt1dWlkKCl9YDtcblxuICAgIGlmICh3aGVuKSB7XG4gICAgICBPYmplY3Qua2V5cyh3aGVuKS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLm9uKGV2ZW50LCB3aGVuW2V2ZW50XSwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBlbGVtZW50IGFuZCBzZXQgdXAgdGhlIFBvcHBlciBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwRWxlbWVudHMoKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLmVsKSkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbCA9IHRoaXMuX2NyZWF0ZVRvb2x0aXBDb250ZW50KCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmFkdmFuY2VPbikge1xuICAgICAgYmluZEFkdmFuY2UodGhpcyk7XG4gICAgfVxuICAgIHNldHVwVG9vbHRpcCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBgYmVmb3JlLXNob3dgLCBnZW5lcmF0ZXMgdGhlIHRvb2x0aXAgRE9NIGNvbnRlbnQsXG4gICAqIHNldHMgdXAgYSBQb3BwZXIgaW5zdGFuY2UgZm9yIHRoZSB0b29sdGlwLCB0aGVuIHRyaWdnZXJzIGBzaG93YC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zaG93KCkge1xuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlLXNob3cnKTtcblxuICAgIC8vIEZvcmNlIHJlc29sdmUgdG8gbWFrZSBzdXJlIHRoZSBvcHRpb25zIGFyZSB1cGRhdGVkIG9uIHN1YnNlcXVlbnQgc2hvd3MuXG4gICAgdGhpcy5fcmVzb2x2ZUF0dGFjaFRvT3B0aW9ucygpO1xuICAgIHRoaXMuX3NldHVwRWxlbWVudHMoKTtcblxuICAgIGlmICghdGhpcy50b3VyLm1vZGFsKSB7XG4gICAgICB0aGlzLnRvdXIuX3NldHVwTW9kYWwoKTtcbiAgICB9XG5cbiAgICB0aGlzLnRvdXIubW9kYWwuc2V0dXBGb3JTdGVwKHRoaXMpO1xuICAgIHRoaXMuX3N0eWxlVGFyZ2V0RWxlbWVudEZvclN0ZXAodGhpcyk7XG4gICAgdGhpcy5lbC5oaWRkZW4gPSBmYWxzZTtcblxuICAgIC8vIHN0YXJ0IHNjcm9sbGluZyB0byB0YXJnZXQgYmVmb3JlIHNob3dpbmcgdGhlIHN0ZXBcbiAgICBpZiAodGhpcy5vcHRpb25zLnNjcm9sbFRvKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5vcHRpb25zLnNjcm9sbFRvKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZWwuaGlkZGVuID0gZmFsc2U7XG5cbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuZ2V0RWxlbWVudCgpO1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoYCR7dGhpcy5jbGFzc1ByZWZpeH1zaGVwaGVyZC1lbmFibGVkYCk7XG4gICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoYCR7dGhpcy5jbGFzc1ByZWZpeH1zaGVwaGVyZC10YXJnZXRgKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ3NoZXBoZXJkLWVuYWJsZWQnKTtcblxuICAgIHRoaXMudHJpZ2dlcignc2hvdycpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZHVsYXRlcyB0aGUgc3R5bGVzIG9mIHRoZSBwYXNzZWQgc3RlcCdzIHRhcmdldCBlbGVtZW50LCBiYXNlZCBvbiB0aGUgc3RlcCdzIG9wdGlvbnMgYW5kXG4gICAqIHRoZSB0b3VyJ3MgYG1vZGFsYCBvcHRpb24sIHRvIHZpc3VhbGx5IGVtcGhhc2l6ZSB0aGUgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0gc3RlcCBUaGUgc3RlcCBvYmplY3QgdGhhdCBhdHRhY2hlcyB0byB0aGUgZWxlbWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0eWxlVGFyZ2V0RWxlbWVudEZvclN0ZXAoc3RlcCkge1xuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBzdGVwLnRhcmdldDtcblxuICAgIGlmICghdGFyZ2V0RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzdGVwLm9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MpIHtcbiAgICAgIHRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LmFkZChzdGVwLm9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MpO1xuICAgIH1cblxuICAgIHRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkJyk7XG5cbiAgICBpZiAoc3RlcC5vcHRpb25zLmNhbkNsaWNrVGFyZ2V0ID09PSBmYWxzZSkge1xuICAgICAgdGFyZ2V0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhIHN0ZXAgaXMgaGlkZGVuLCByZW1vdmUgdGhlIGhpZ2hsaWdodENsYXNzIGFuZCAnc2hlcGhlcmQtZW5hYmxlZCdcbiAgICogYW5kICdzaGVwaGVyZC10YXJnZXQnIGNsYXNzZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVTdGVwVGFyZ2V0T25IaWRlKCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0IHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodENsYXNzKSB7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MpO1xuICAgIH1cblxuICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgJ3NoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZCcsXG4gICAgICBgJHt0aGlzLmNsYXNzUHJlZml4fXNoZXBoZXJkLWVuYWJsZWRgLFxuICAgICAgYCR7dGhpcy5jbGFzc1ByZWZpeH1zaGVwaGVyZC10YXJnZXRgXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDbGVhbnVwIHRoZSBzdGVwcyBhbmQgc2V0IHBvaW50ZXJFdmVudHMgYmFjayB0byAnYXV0bydcbiAqIEBwYXJhbSB0b3VyIFRoZSB0b3VyIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cFN0ZXBzKHRvdXIpIHtcbiAgaWYgKHRvdXIpIHtcbiAgICBjb25zdCB7IHN0ZXBzIH0gPSB0b3VyO1xuXG4gICAgc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBzdGVwLm9wdGlvbnMgJiZcbiAgICAgICAgc3RlcC5vcHRpb25zLmNhbkNsaWNrVGFyZ2V0ID09PSBmYWxzZSAmJlxuICAgICAgICBzdGVwLm9wdGlvbnMuYXR0YWNoVG9cbiAgICAgICkge1xuICAgICAgICBpZiAoc3RlcC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgIHN0ZXAudGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3NoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKlxuICogR2VuZXJhdGVzIHRoZSBzdmcgcGF0aCBkYXRhIGZvciBhIHJvdW5kZWQgcmVjdGFuZ2xlIG92ZXJsYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb24gLSBEaW1lbnNpb25zIG9mIHJlY3RhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIE9mZnNldCBmcm9tIHRvcCBsZWZ0IGNvcm5lciBpbiB4IGF4aXMuIGRlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIE9mZnNldCBmcm9tIHRvcCBsZWZ0IGNvcm5lciBpbiB5IGF4aXMuIGRlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcj0wXSAtIENvcm5lciBSYWRpdXMuIEtlZXAgdGhpcyBzbWFsbGVyIHRoYW4gIGhhbGYgb2Ygd2lkdGggb3IgaGVpZ2h0LlxuICogQHJldHVybnMge3N0cmluZ30gLSBSb3VuZGVkIHJlY3RhbmdsZSBvdmVybGF5IHBhdGggZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VPdmVybGF5UGF0aCh7IHdpZHRoLCBoZWlnaHQsIHggPSAwLCB5ID0gMCwgciA9IDAgfSkge1xuICBjb25zdCB7IGlubmVyV2lkdGg6IHcsIGlubmVySGVpZ2h0OiBoIH0gPSB3aW5kb3c7XG5cbiAgcmV0dXJuIGBNJHt3fSwke2h9XFxcbkgwXFxcblYwXFxcbkgke3d9XFxcblYke2h9XFxcblpcXFxuTSR7eCArIHJ9LCR7eX1cXFxuYSR7cn0sJHtyfSwwLDAsMC0ke3J9LCR7cn1cXFxuViR7aGVpZ2h0ICsgeSAtIHJ9XFxcbmEke3J9LCR7cn0sMCwwLDAsJHtyfSwke3J9XFxcbkgke3dpZHRoICsgeCAtIHJ9XFxcbmEke3J9LCR7cn0sMCwwLDAsJHtyfS0ke3J9XFxcblYke3kgKyByfVxcXG5hJHtyfSwke3J9LDAsMCwwLSR7cn0tJHtyfVxcXG5aYDtcbn1cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IHV1aWQgfSBmcm9tICcuLi91dGlscy9nZW5lcmFsLmpzJztcbiAgaW1wb3J0IHsgbWFrZU92ZXJsYXlQYXRoIH0gZnJvbSAnLi4vdXRpbHMvb3ZlcmxheS1wYXRoLmpzJztcblxuICBleHBvcnQgbGV0IGVsZW1lbnQsIG9wZW5pbmdQcm9wZXJ0aWVzO1xuICBjb25zdCBndWlkID0gdXVpZCgpO1xuICBsZXQgbW9kYWxJc1Zpc2libGUgPSBmYWxzZTtcbiAgbGV0IHJhZklkID0gdW5kZWZpbmVkO1xuICBsZXQgcGF0aERlZmluaXRpb247XG5cbiAgJDogcGF0aERlZmluaXRpb24gPSBtYWtlT3ZlcmxheVBhdGgob3BlbmluZ1Byb3BlcnRpZXMpO1xuXG4gIGNsb3NlTW9kYWxPcGVuaW5nKCk7XG5cbiAgZXhwb3J0IGNvbnN0IGdldEVsZW1lbnQgPSAoKSA9PiBlbGVtZW50O1xuXG4gIGV4cG9ydCBmdW5jdGlvbiBjbG9zZU1vZGFsT3BlbmluZygpIHtcbiAgICBvcGVuaW5nUHJvcGVydGllcyA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICByOiAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBtb2RhbCBvdmVybGF5XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gaGlkZSgpIHtcbiAgICBtb2RhbElzVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgLy8gRW5zdXJlIHdlIGNsZWFudXAgYWxsIGV2ZW50IGxpc3RlbmVycyB3aGVuIHdlIGhpZGUgdGhlIG1vZGFsXG4gICAgX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VzIHRoZSBib3VuZHMgb2YgdGhlIGVsZW1lbnQgd2Ugd2FudCB0aGUgb3BlbmluZyBvdmVydG9wIG9mIHRvIHNldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb3BlbmluZyBhbmQgcG9zaXRpb24gaXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nIEFuIGFtb3VudCBvZiBwYWRkaW5nIHRvIGFkZCBhcm91bmQgdGhlIG1vZGFsIG92ZXJsYXkgb3BlbmluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gbW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyBBbiBhbW91bnQgb2YgYm9yZGVyIHJhZGl1cyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2Nyb2xsUGFyZW50IFRoZSBzY3JvbGxhYmxlIHBhcmVudCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0RWxlbWVudCBUaGUgZWxlbWVudCB0aGUgb3BlbmluZyB3aWxsIGV4cG9zZVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHBvc2l0aW9uTW9kYWwoXG4gICAgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgPSAwLFxuICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMgPSAwLFxuICAgIHNjcm9sbFBhcmVudCxcbiAgICB0YXJnZXRFbGVtZW50XG4gICkge1xuICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICBjb25zdCB7IHksIGhlaWdodCB9ID0gX2dldFZpc2libGVIZWlnaHQodGFyZ2V0RWxlbWVudCwgc2Nyb2xsUGFyZW50KTtcbiAgICAgIGNvbnN0IHsgeCwgd2lkdGgsIGxlZnQgfSA9IHRhcmdldEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBub3QgY29uc2lzdGVudC4gU29tZSBicm93c2VycyB1c2UgeCBhbmQgeSwgd2hpbGUgb3RoZXJzIHVzZSBsZWZ0IGFuZCB0b3BcbiAgICAgIG9wZW5pbmdQcm9wZXJ0aWVzID0ge1xuICAgICAgICB3aWR0aDogd2lkdGggKyBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyAqIDIsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgKiAyLFxuICAgICAgICB4OiAoeCB8fCBsZWZ0KSAtIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgICB5OiB5IC0gbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICAgIHI6IG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlTW9kYWxPcGVuaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIG1vZGFsIGlzIGVuYWJsZWQsIHNldHVwIHRoZSBzdmcgbWFzayBvcGVuaW5nIGFuZCBtb2RhbCBvdmVybGF5IGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBzZXR1cEZvclN0ZXAoc3RlcCkge1xuICAgIC8vIEVuc3VyZSB3ZSBtb3ZlIGxpc3RlbmVycyBmcm9tIHRoZSBwcmV2aW91cyBzdGVwLCBiZWZvcmUgd2Ugc2V0dXAgbmV3IG9uZXNcbiAgICBfY2xlYW51cFN0ZXBFdmVudExpc3RlbmVycygpO1xuXG4gICAgaWYgKHN0ZXAudG91ci5vcHRpb25zLnVzZU1vZGFsT3ZlcmxheSkge1xuICAgICAgX3N0eWxlRm9yU3RlcChzdGVwKTtcbiAgICAgIHNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBtb2RhbCBvdmVybGF5XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gc2hvdygpIHtcbiAgICBtb2RhbElzVmlzaWJsZSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBfcHJldmVudE1vZGFsQm9keVRvdWNoID0gKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgY29uc3QgX3ByZXZlbnRNb2RhbE92ZXJsYXlUb3VjaCA9IChlKSA9PiB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRvdWNobW92ZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZFN0ZXBFdmVudExpc3RlbmVycygpIHtcbiAgICAvLyBQcmV2ZW50cyB3aW5kb3cgZnJvbSBtb3Zpbmcgb24gdG91Y2guXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9wcmV2ZW50TW9kYWxCb2R5VG91Y2gsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbG9vcCBhbmQgcmVtb3ZlIHRvdWNobW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmIChyYWZJZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgcmFmSWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9wcmV2ZW50TW9kYWxCb2R5VG91Y2gsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3R5bGUgdGhlIG1vZGFsIGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgdG8gc3R5bGUgdGhlIG9wZW5pbmcgZm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfc3R5bGVGb3JTdGVwKHN0ZXApIHtcbiAgICBjb25zdCB7XG4gICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyxcbiAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXNcbiAgICB9ID0gc3RlcC5vcHRpb25zO1xuXG4gICAgY29uc3Qgc2Nyb2xsUGFyZW50ID0gX2dldFNjcm9sbFBhcmVudChzdGVwLnRhcmdldCk7XG5cbiAgICAvLyBTZXR1cCByZWN1cnNpdmUgZnVuY3Rpb24gdG8gY2FsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gdXBkYXRlIHRoZSBtb2RhbCBvcGVuaW5nIHBvc2l0aW9uXG4gICAgY29uc3QgcmFmTG9vcCA9ICgpID0+IHtcbiAgICAgIHJhZklkID0gdW5kZWZpbmVkO1xuICAgICAgcG9zaXRpb25Nb2RhbChcbiAgICAgICAgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMsXG4gICAgICAgIHNjcm9sbFBhcmVudCxcbiAgICAgICAgc3RlcC50YXJnZXRcbiAgICAgICk7XG4gICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZMb29wKTtcbiAgICB9O1xuXG4gICAgcmFmTG9vcCgpO1xuXG4gICAgX2FkZFN0ZXBFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSB0YXJnZXQgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGlzSHRtbEVsZW1lbnQgPSBlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgY29uc3Qgb3ZlcmZsb3dZID1cbiAgICAgIGlzSHRtbEVsZW1lbnQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkub3ZlcmZsb3dZO1xuICAgIGNvbnN0IGlzU2Nyb2xsYWJsZSA9IG92ZXJmbG93WSAhPT0gJ2hpZGRlbicgJiYgb3ZlcmZsb3dZICE9PSAndmlzaWJsZSc7XG5cbiAgICBpZiAoaXNTY3JvbGxhYmxlICYmIGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID49IGVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldFNjcm9sbFBhcmVudChlbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlzaWJsZSBoZWlnaHQgb2YgdGhlIHRhcmdldCBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBzY3JvbGxQYXJlbnQuXG4gICAqIElmIHRoZXJlIGlzIG5vIHNjcm9sbCBwYXJlbnQsIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIHRhcmdldCBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtzY3JvbGxQYXJlbnRdIFRoZSBzY3JvbGxhYmxlIHBhcmVudCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHt7eTogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0VmlzaWJsZUhlaWdodChlbGVtZW50LCBzY3JvbGxQYXJlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHRvcCA9IGVsZW1lbnRSZWN0LnkgfHwgZWxlbWVudFJlY3QudG9wO1xuICAgIGxldCBib3R0b20gPSBlbGVtZW50UmVjdC5ib3R0b20gfHwgdG9wICsgZWxlbWVudFJlY3QuaGVpZ2h0O1xuXG4gICAgaWYgKHNjcm9sbFBhcmVudCkge1xuICAgICAgY29uc3Qgc2Nyb2xsUmVjdCA9IHNjcm9sbFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHNjcm9sbFJlY3QueSB8fCBzY3JvbGxSZWN0LnRvcDtcbiAgICAgIGNvbnN0IHNjcm9sbEJvdHRvbSA9IHNjcm9sbFJlY3QuYm90dG9tIHx8IHNjcm9sbFRvcCArIHNjcm9sbFJlY3QuaGVpZ2h0O1xuXG4gICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIHNjcm9sbFRvcCk7XG4gICAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20sIHNjcm9sbEJvdHRvbSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoYm90dG9tIC0gdG9wLCAwKTsgLy8gRGVmYXVsdCB0byAwIGlmIGhlaWdodCBpcyBuZWdhdGl2ZVxuXG4gICAgcmV0dXJuIHsgeTogdG9wLCBoZWlnaHQgfTtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdmdcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBjbGFzcz17YCR7XG4gICAgbW9kYWxJc1Zpc2libGUgPyAnc2hlcGhlcmQtbW9kYWwtaXMtdmlzaWJsZScgOiAnJ1xuICB9IHNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyYH1cbiAgb246dG91Y2htb3ZlPXtfcHJldmVudE1vZGFsT3ZlcmxheVRvdWNofVxuPlxuICA8cGF0aCBkPXtwYXRoRGVmaW5pdGlvbn0gLz5cbjwvc3ZnPlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXIge1xuICAgIGhlaWdodDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIG9wYWNpdHk6IDA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2Utb3V0LCBoZWlnaHQgMG1zIDAuM3MsIG9wYWNpdHkgMC4zcyAwbXM7XG4gICAgd2lkdGg6IDEwMHZ3O1xuICAgIHotaW5kZXg6IDk5OTc7XG4gIH1cblxuICAuc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXIuc2hlcGhlcmQtbW9kYWwtaXMtdmlzaWJsZSB7XG4gICAgaGVpZ2h0OiAxMDB2aDtcbiAgICBvcGFjaXR5OiAwLjU7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZS1vdXQsIGhlaWdodCAwcyAwcywgb3BhY2l0eSAwLjNzIDBzO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lci5zaGVwaGVyZC1tb2RhbC1pcy12aXNpYmxlIHBhdGgge1xuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XG4gIH1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgeyBFdmVudGVkIH0gZnJvbSAnLi9ldmVudGVkLmpzJztcbmltcG9ydCB7IFN0ZXAgfSBmcm9tICcuL3N0ZXAuanMnO1xuaW1wb3J0IGF1dG9CaW5kIGZyb20gJy4vdXRpbHMvYXV0by1iaW5kLmpzJztcbmltcG9ydCB7XG4gIGlzSFRNTEVsZW1lbnQsXG4gIGlzRnVuY3Rpb24sXG4gIGlzU3RyaW5nLFxuICBpc1VuZGVmaW5lZFxufSBmcm9tICcuL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuaW1wb3J0IHsgY2xlYW51cFN0ZXBzIH0gZnJvbSAnLi91dGlscy9jbGVhbnVwLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZVByZWZpeCwgdXVpZCB9IGZyb20gJy4vdXRpbHMvZ2VuZXJhbC5qcyc7XG5pbXBvcnQgU2hlcGhlcmRNb2RhbCBmcm9tICcuL2NvbXBvbmVudHMvc2hlcGhlcmQtbW9kYWwuc3ZlbHRlJztcblxuY29uc3QgU2hlcGhlcmQgPSBuZXcgRXZlbnRlZCgpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyB0aGUgc2l0ZSB0b3VyXG4gKiBAZXh0ZW5kcyB7RXZlbnRlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIFRvdXIgZXh0ZW5kcyBFdmVudGVkIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgdG91clxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY29uZmlybUNhbmNlbCBJZiB0cnVlLCB3aWxsIGlzc3VlIGEgYHdpbmRvdy5jb25maXJtYCBiZWZvcmUgY2FuY2VsbGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jb25maXJtQ2FuY2VsTWVzc2FnZSBUaGUgbWVzc2FnZSB0byBkaXNwbGF5IGluIHRoZSBjb25maXJtIGRpYWxvZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jbGFzc1ByZWZpeCBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgYHNoZXBoZXJkLWVuYWJsZWRgIGFuZCBgc2hlcGhlcmQtdGFyZ2V0YCBjbGFzcyBuYW1lcyBhcyB3ZWxsIGFzIHRoZSBgZGF0YS1zaGVwaGVyZC1zdGVwLWlkYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZGVmYXVsdFN0ZXBPcHRpb25zIERlZmF1bHQgb3B0aW9ucyBmb3IgU3RlcHMgKHtAbGluayBTdGVwI2NvbnN0cnVjdG9yfSksIGNyZWF0ZWQgdGhyb3VnaCBgYWRkU3RlcGBcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmV4aXRPbkVzYyBFeGl0aW5nIHRoZSB0b3VyIHdpdGggdGhlIGVzY2FwZSBrZXkgd2lsbCBiZSBlbmFibGVkIHVubGVzcyB0aGlzIGlzIGV4cGxpY2l0bHlcbiAgICogc2V0IHRvIGZhbHNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMua2V5Ym9hcmROYXZpZ2F0aW9uIE5hdmlnYXRpbmcgdGhlIHRvdXIgdmlhIGxlZnQgYW5kIHJpZ2h0IGFycm93IGtleXMgd2lsbCBiZSBlbmFibGVkXG4gICAqIHVubGVzcyB0aGlzIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLnN0ZXBzQ29udGFpbmVyIEFuIG9wdGlvbmFsIGNvbnRhaW5lciBlbGVtZW50IGZvciB0aGUgc3RlcHMuXG4gICAqIElmIG5vdCBzZXQsIHRoZSBzdGVwcyB3aWxsIGJlIGFwcGVuZGVkIHRvIGBkb2N1bWVudC5ib2R5YC5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5tb2RhbENvbnRhaW5lciBBbiBvcHRpb25hbCBjb250YWluZXIgZWxlbWVudCBmb3IgdGhlIG1vZGFsLlxuICAgKiBJZiBub3Qgc2V0LCB0aGUgbW9kYWwgd2lsbCBiZSBhcHBlbmRlZCB0byBgZG9jdW1lbnQuYm9keWAuXG4gICAqIEBwYXJhbSB7b2JqZWN0W10gfCBTdGVwW119IG9wdGlvbnMuc3RlcHMgQW4gYXJyYXkgb2Ygc3RlcCBvcHRpb25zIG9iamVjdHMgb3IgU3RlcCBpbnN0YW5jZXMgdG8gaW5pdGlhbGl6ZSB0aGUgdG91ciB3aXRoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvdXJOYW1lIEFuIG9wdGlvbmFsIFwibmFtZVwiIGZvciB0aGUgdG91ci4gVGhpcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSB0aGUgdG91cidzXG4gICAqIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBgaWRgIHByb3BlcnR5IC0tIHdoaWNoIGlzIGFsc28gc2V0IG9uIHRoZSBgYm9keWAgZWxlbWVudCBhcyB0aGUgYGRhdGEtc2hlcGhlcmQtYWN0aXZlLXRvdXJgIGF0dHJpYnV0ZVxuICAgKiB3aGVuZXZlciB0aGUgdG91ciBiZWNvbWVzIGFjdGl2ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnVzZU1vZGFsT3ZlcmxheSBXaGV0aGVyIG9yIG5vdCBzdGVwcyBzaG91bGQgYmUgcGxhY2VkIGFib3ZlIGEgZGFya2VuZWRcbiAgICogbW9kYWwgb3ZlcmxheS4gSWYgdHJ1ZSwgdGhlIG92ZXJsYXkgd2lsbCBjcmVhdGUgYW4gb3BlbmluZyBhcm91bmQgdGhlIHRhcmdldCBlbGVtZW50IHNvIHRoYXQgaXRcbiAgICogY2FuIHJlbWFpbiBpbnRlcmFjdGl2ZVxuICAgKiBAcmV0dXJucyB7VG91cn1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgYXV0b0JpbmQodGhpcyk7XG5cbiAgICBjb25zdCBkZWZhdWx0VG91ck9wdGlvbnMgPSB7XG4gICAgICBleGl0T25Fc2M6IHRydWUsXG4gICAgICBrZXlib2FyZE5hdmlnYXRpb246IHRydWVcbiAgICB9O1xuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFRvdXJPcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLmNsYXNzUHJlZml4ID0gbm9ybWFsaXplUHJlZml4KHRoaXMub3B0aW9ucy5jbGFzc1ByZWZpeCk7XG4gICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgIHRoaXMuYWRkU3RlcHModGhpcy5vcHRpb25zLnN0ZXBzKTtcblxuICAgIC8vIFBhc3MgdGhlc2UgZXZlbnRzIG9udG8gdGhlIGdsb2JhbCBTaGVwaGVyZCBvYmplY3RcbiAgICBjb25zdCBldmVudHMgPSBbXG4gICAgICAnYWN0aXZlJyxcbiAgICAgICdjYW5jZWwnLFxuICAgICAgJ2NvbXBsZXRlJyxcbiAgICAgICdpbmFjdGl2ZScsXG4gICAgICAnc2hvdycsXG4gICAgICAnc3RhcnQnXG4gICAgXTtcbiAgICBldmVudHMubWFwKChldmVudCkgPT4ge1xuICAgICAgKChlKSA9PiB7XG4gICAgICAgIHRoaXMub24oZSwgKG9wdHMpID0+IHtcbiAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICBvcHRzLnRvdXIgPSB0aGlzO1xuICAgICAgICAgIFNoZXBoZXJkLnRyaWdnZXIoZSwgb3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgfSkoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2V0VG91cklEKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IHN0ZXAgdG8gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtPYmplY3R8U3RlcH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBzdGVwIG9wdGlvbnMgb3IgYSBTdGVwIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgb3B0aW9uYWwgaW5kZXggdG8gaW5zZXJ0IHRoZSBzdGVwIGF0LiBJZiB1bmRlZmluZWQsIHRoZSBzdGVwXG4gICAqIGlzIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgKiBAcmV0dXJuIHtTdGVwfSBUaGUgbmV3bHkgYWRkZWQgc3RlcFxuICAgKi9cbiAgYWRkU3RlcChvcHRpb25zLCBpbmRleCkge1xuICAgIGxldCBzdGVwID0gb3B0aW9ucztcblxuICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBTdGVwKSkge1xuICAgICAgc3RlcCA9IG5ldyBTdGVwKHRoaXMsIHN0ZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwLnRvdXIgPSB0aGlzO1xuICAgIH1cblxuICAgIGlmICghaXNVbmRlZmluZWQoaW5kZXgpKSB7XG4gICAgICB0aGlzLnN0ZXBzLnNwbGljZShpbmRleCwgMCwgc3RlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbXVsdGlwbGUgc3RlcHMgdG8gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+IHwgQXJyYXk8U3RlcD59IHN0ZXBzIFRoZSBzdGVwcyB0byBhZGQgdG8gdGhlIHRvdXJcbiAgICovXG4gIGFkZFN0ZXBzKHN0ZXBzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RlcHMpKSB7XG4gICAgICBzdGVwcy5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkU3RlcChzdGVwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdvIHRvIHRoZSBwcmV2aW91cyBzdGVwIGluIHRoZSB0b3VyXG4gICAqL1xuICBiYWNrKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuY3VycmVudFN0ZXApO1xuICAgIHRoaXMuc2hvdyhpbmRleCAtIDEsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBfZG9uZSgpIHRyaWdnZXJpbmcgdGhlICdjYW5jZWwnIGV2ZW50XG4gICAqIElmIGBjb25maXJtQ2FuY2VsYCBpcyB0cnVlLCB3aWxsIHNob3cgYSB3aW5kb3cuY29uZmlybSBiZWZvcmUgY2FuY2VsbGluZ1xuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uZmlybUNhbmNlbCkge1xuICAgICAgY29uc3QgY2FuY2VsTWVzc2FnZSA9XG4gICAgICAgIHRoaXMub3B0aW9ucy5jb25maXJtQ2FuY2VsTWVzc2FnZSB8fFxuICAgICAgICAnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHN0b3AgdGhlIHRvdXI/JztcbiAgICAgIGNvbnN0IHN0b3BUb3VyID0gd2luZG93LmNvbmZpcm0oY2FuY2VsTWVzc2FnZSk7XG4gICAgICBpZiAoc3RvcFRvdXIpIHtcbiAgICAgICAgdGhpcy5fZG9uZSgnY2FuY2VsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RvbmUoJ2NhbmNlbCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBfZG9uZSgpIHRyaWdnZXJpbmcgdGhlIGBjb21wbGV0ZWAgZXZlbnRcbiAgICovXG4gIGNvbXBsZXRlKCkge1xuICAgIHRoaXMuX2RvbmUoJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RlcCBmcm9tIGEgZ2l2ZW4gaWRcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIHN0ZXAgdG8gcmV0cmlldmVcbiAgICogQHJldHVybiB7U3RlcH0gVGhlIHN0ZXAgY29ycmVzcG9uZGluZyB0byB0aGUgYGlkYFxuICAgKi9cbiAgZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzLmZpbmQoKHN0ZXApID0+IHtcbiAgICAgIHJldHVybiBzdGVwLmlkID09PSBpZDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0ZXBcbiAgICogQHJldHVybnMge1N0ZXB8bnVsbH1cbiAgICovXG4gIGdldEN1cnJlbnRTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGVwO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGN1cnJlbnQgc3RlcFxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICBjb25zdCBjdXJyZW50U3RlcCA9IHRoaXMuZ2V0Q3VycmVudFN0ZXAoKTtcblxuICAgIGlmIChjdXJyZW50U3RlcCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRTdGVwLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRvdXIgaXMgYWN0aXZlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gU2hlcGhlcmQuYWN0aXZlVG91ciA9PT0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyB0byB0aGUgbmV4dCBzdGVwIGluIHRoZSB0b3VyXG4gICAqIElmIHdlIGFyZSBhdCB0aGUgZW5kLCBjYWxsIGBjb21wbGV0ZWBcbiAgICovXG4gIG5leHQoKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2YodGhpcy5jdXJyZW50U3RlcCk7XG5cbiAgICBpZiAoaW5kZXggPT09IHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coaW5kZXggKyAxLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3RlcCBmcm9tIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBpZCBmb3IgdGhlIHN0ZXAgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVTdGVwKG5hbWUpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXRDdXJyZW50U3RlcCgpO1xuXG4gICAgLy8gRmluZCB0aGUgc3RlcCwgZGVzdHJveSBpdCBhbmQgcmVtb3ZlIGl0IGZyb20gdGhpcy5zdGVwc1xuICAgIHRoaXMuc3RlcHMuc29tZSgoc3RlcCwgaSkgPT4ge1xuICAgICAgaWYgKHN0ZXAuaWQgPT09IG5hbWUpIHtcbiAgICAgICAgaWYgKHN0ZXAuaXNPcGVuKCkpIHtcbiAgICAgICAgICBzdGVwLmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ZXAuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnN0ZXBzLnNwbGljZShpLCAxKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuaWQgPT09IG5hbWUpIHtcbiAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgc3RlcHMgbGVmdCwgc2hvdyB0aGUgZmlyc3Qgb25lLCBvdGhlcndpc2UganVzdCBjYW5jZWwgdGhlIHRvdXJcbiAgICAgIHRoaXMuc3RlcHMubGVuZ3RoID8gdGhpcy5zaG93KDApIDogdGhpcy5jYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBhIHNwZWNpZmljIHN0ZXAgaW4gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXkgVGhlIGtleSB0byBsb29rIHVwIHRoZSBzdGVwIGJ5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yd2FyZCBUcnVlIGlmIHdlIGFyZSBnb2luZyBmb3J3YXJkLCBmYWxzZSBpZiBiYWNrd2FyZFxuICAgKi9cbiAgc2hvdyhrZXkgPSAwLCBmb3J3YXJkID0gdHJ1ZSkge1xuICAgIGNvbnN0IHN0ZXAgPSBpc1N0cmluZyhrZXkpID8gdGhpcy5nZXRCeUlkKGtleSkgOiB0aGlzLnN0ZXBzW2tleV07XG5cbiAgICBpZiAoc3RlcCkge1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdGVCZWZvcmVTaG93KCk7XG5cbiAgICAgIGNvbnN0IHNob3VsZFNraXBTdGVwID1cbiAgICAgICAgaXNGdW5jdGlvbihzdGVwLm9wdGlvbnMuc2hvd09uKSAmJiAhc3RlcC5vcHRpb25zLnNob3dPbigpO1xuXG4gICAgICAvLyBJZiBgc2hvd09uYCByZXR1cm5zIGZhbHNlLCB3ZSB3YW50IHRvIHNraXAgdGhlIHN0ZXAsIG90aGVyd2lzZSwgc2hvdyB0aGUgc3RlcCBsaWtlIG5vcm1hbFxuICAgICAgaWYgKHNob3VsZFNraXBTdGVwKSB7XG4gICAgICAgIHRoaXMuX3NraXBTdGVwKHN0ZXAsIGZvcndhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzaG93Jywge1xuICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgcHJldmlvdXM6IHRoaXMuY3VycmVudFN0ZXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IHN0ZXA7XG4gICAgICAgIHN0ZXAuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgdG91clxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdzdGFydCcpO1xuXG4gICAgLy8gU2F2ZSB0aGUgZm9jdXNlZCBlbGVtZW50IGJlZm9yZSB0aGUgdG91ciBvcGVuc1xuICAgIHRoaXMuZm9jdXNlZEVsQmVmb3JlT3BlbiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gbnVsbDtcblxuICAgIHRoaXMuX3NldHVwTW9kYWwoKTtcblxuICAgIHRoaXMuX3NldHVwQWN0aXZlVG91cigpO1xuICAgIHRoaXMubmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuZXZlciB0aGUgdG91ciBpcyBjYW5jZWxsZWQgb3IgY29tcGxldGVkLCBiYXNpY2FsbHkgYW55dGltZSB3ZSBleGl0IHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZSB0byB0cmlnZ2VyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9uZShldmVudCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuY3VycmVudFN0ZXApO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc3RlcHMpKSB7XG4gICAgICB0aGlzLnN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHN0ZXAuZGVzdHJveSgpKTtcbiAgICB9XG5cbiAgICBjbGVhbnVwU3RlcHModGhpcyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoZXZlbnQsIHsgaW5kZXggfSk7XG5cbiAgICBTaGVwaGVyZC5hY3RpdmVUb3VyID0gbnVsbDtcbiAgICB0aGlzLnRyaWdnZXIoJ2luYWN0aXZlJywgeyB0b3VyOiB0aGlzIH0pO1xuXG4gICAgaWYgKHRoaXMubW9kYWwpIHtcbiAgICAgIHRoaXMubW9kYWwuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmIChldmVudCA9PT0gJ2NhbmNlbCcgfHwgZXZlbnQgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGlmICh0aGlzLm1vZGFsKSB7XG4gICAgICAgIGNvbnN0IG1vZGFsQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAnLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChtb2RhbENvbnRhaW5lcikge1xuICAgICAgICAgIG1vZGFsQ29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9jdXMgdGhlIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBiZWZvcmUgdGhlIHRvdXIgc3RhcnRlZFxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRoaXMuZm9jdXNlZEVsQmVmb3JlT3BlbikpIHtcbiAgICAgIHRoaXMuZm9jdXNlZEVsQmVmb3JlT3Blbi5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgdG91ciBcImFjdGl2ZVwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBBY3RpdmVUb3VyKCkge1xuICAgIHRoaXMudHJpZ2dlcignYWN0aXZlJywgeyB0b3VyOiB0aGlzIH0pO1xuXG4gICAgU2hlcGhlcmQuYWN0aXZlVG91ciA9IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogX3NldHVwTW9kYWwgY3JlYXRlIHRoZSBtb2RhbCBjb250YWluZXIgYW5kIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBNb2RhbCgpIHtcbiAgICB0aGlzLm1vZGFsID0gbmV3IFNoZXBoZXJkTW9kYWwoe1xuICAgICAgdGFyZ2V0OiB0aGlzLm9wdGlvbnMubW9kYWxDb250YWluZXIgfHwgZG9jdW1lbnQuYm9keSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsYXNzUHJlZml4OiB0aGlzLmNsYXNzUHJlZml4LFxuICAgICAgICBzdHlsZXM6IHRoaXMuc3R5bGVzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYHNob3dPbmAgZXZhbHVhdGVzIHRvIGZhbHNlLCB0byBza2lwIHRoZSBzdGVwIG9yIGNvbXBsZXRlIHRoZSB0b3VyIGlmIGl0J3MgdGhlIGxhc3Qgc3RlcFxuICAgKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgdG8gc2tpcFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcndhcmQgVHJ1ZSBpZiB3ZSBhcmUgZ29pbmcgZm9yd2FyZCwgZmFsc2UgaWYgYmFja3dhcmRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9za2lwU3RlcChzdGVwLCBmb3J3YXJkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2Yoc3RlcCk7XG5cbiAgICBpZiAoaW5kZXggPT09IHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSBmb3J3YXJkID8gaW5kZXggKyAxIDogaW5kZXggLSAxO1xuICAgICAgdGhpcy5zaG93KG5leHRJbmRleCwgZm9yd2FyZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSBzaG93aW5nLCBoaWRlIHRoZSBjdXJyZW50IHN0ZXAgYW5kIGlmIHRoZSB0b3VyIGlzIG5vdFxuICAgKiBhbHJlYWR5IGFjdGl2ZSwgY2FsbCBgdGhpcy5fc2V0dXBBY3RpdmVUb3VyYC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVTdGF0ZUJlZm9yZVNob3coKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFN0ZXApIHtcbiAgICAgIHRoaXMuY3VycmVudFN0ZXAuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLl9zZXR1cEFjdGl2ZVRvdXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzLmlkIHRvIGAke3RvdXJOYW1lfS0tJHt1dWlkfWBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRUb3VySUQoKSB7XG4gICAgY29uc3QgdG91ck5hbWUgPSB0aGlzLm9wdGlvbnMudG91ck5hbWUgfHwgJ3RvdXInO1xuXG4gICAgdGhpcy5pZCA9IGAke3RvdXJOYW1lfS0tJHt1dWlkKCl9YDtcbiAgfVxufVxuXG5leHBvcnQgeyBTaGVwaGVyZCB9O1xuIiwiaW1wb3J0IHsgU3RlcCB9IGZyb20gJy4vc3RlcC5qcyc7XG5pbXBvcnQgeyBTaGVwaGVyZCwgVG91ciB9IGZyb20gJy4vdG91ci5qcyc7XG5cbk9iamVjdC5hc3NpZ24oU2hlcGhlcmQsIHsgVG91ciwgU3RlcCB9KTtcblxuZXhwb3J0IGRlZmF1bHQgU2hlcGhlcmQ7XG4iXSwibmFtZXMiOlsiaXNNZXJnZWFibGVPYmplY3QiLCJ2YWx1ZSIsImlzTm9uTnVsbE9iamVjdCIsImlzU3BlY2lhbCIsInN0cmluZ1ZhbHVlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNSZWFjdEVsZW1lbnQiLCJjYW5Vc2VTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCIkJHR5cGVvZiIsImVtcHR5VGFyZ2V0IiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwiY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQiLCJvcHRpb25zIiwiY2xvbmUiLCJkZWVwbWVyZ2UiLCJkZWZhdWx0QXJyYXlNZXJnZSIsInRhcmdldCIsInNvdXJjZSIsImNvbmNhdCIsIm1hcCIsImVsZW1lbnQiLCJnZXRNZXJnZUZ1bmN0aW9uIiwia2V5IiwiY3VzdG9tTWVyZ2UiLCJnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwic3ltYm9sIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJnZXRLZXlzIiwia2V5cyIsInByb3BlcnR5SXNPbk9iamVjdCIsIm9iamVjdCIsInByb3BlcnR5IiwiXyIsInByb3BlcnR5SXNVbnNhZmUiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlT2JqZWN0IiwiZGVzdGluYXRpb24iLCJmb3JFYWNoIiwiYXJyYXlNZXJnZSIsInNvdXJjZUlzQXJyYXkiLCJ0YXJnZXRJc0FycmF5Iiwic291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCIsImFsbCIsImRlZXBtZXJnZUFsbCIsImFycmF5IiwiRXJyb3IiLCJyZWR1Y2UiLCJwcmV2IiwibmV4dCIsImRlZXBtZXJnZV8xIiwiaXNFbGVtZW50IiwiRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzRnVuY3Rpb24iLCJpc1N0cmluZyIsImlzVW5kZWZpbmVkIiwidW5kZWZpbmVkIiwiRXZlbnRlZCIsIm9uIiwiZXZlbnQiLCJoYW5kbGVyIiwiY3R4Iiwib25jZSIsImJpbmRpbmdzIiwicHVzaCIsIm9mZiIsImJpbmRpbmciLCJpbmRleCIsInNwbGljZSIsInRyaWdnZXIiLCJhcmdzIiwiYXJndW1lbnRzIiwiY29udGV4dCIsImFwcGx5IiwiYXV0b0JpbmQiLCJzZWxmIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImNvbnN0cnVjdG9yIiwiaSIsImxlbmd0aCIsImJpbmQiLCJfc2V0dXBBZHZhbmNlT25IYW5kbGVyIiwic2VsZWN0b3IiLCJzdGVwIiwiaXNPcGVuIiwidGFyZ2V0SXNFbCIsImVsIiwiY3VycmVudFRhcmdldCIsInRhcmdldElzU2VsZWN0b3IiLCJtYXRjaGVzIiwidG91ciIsImJpbmRBZHZhbmNlIiwiYWR2YW5jZU9uIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYm9keSIsInRvcCIsImJvdHRvbSIsInJpZ2h0IiwibGVmdCIsImF1dG8iLCJiYXNlUGxhY2VtZW50cyIsInN0YXJ0IiwiZW5kIiwiY2xpcHBpbmdQYXJlbnRzIiwidmlld3BvcnQiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJ2YXJpYXRpb25QbGFjZW1lbnRzIiwiYWNjIiwicGxhY2VtZW50IiwicGxhY2VtZW50cyIsImJlZm9yZVJlYWQiLCJyZWFkIiwiYWZ0ZXJSZWFkIiwiYmVmb3JlTWFpbiIsIm1haW4iLCJhZnRlck1haW4iLCJiZWZvcmVXcml0ZSIsIndyaXRlIiwiYWZ0ZXJXcml0ZSIsIm1vZGlmaWVyUGhhc2VzIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0V2luZG93Iiwibm9kZSIsIndpbmRvdyIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIk93bkVsZW1lbnQiLCJpc1NoYWRvd1Jvb3QiLCJTaGFkb3dSb290IiwiYXBwbHlTdHlsZXMiLCJfcmVmIiwic3RhdGUiLCJlbGVtZW50cyIsIm5hbWUiLCJzdHlsZSIsInN0eWxlcyIsImF0dHJpYnV0ZXMiLCJhc3NpZ24iLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJlZmZlY3QiLCJfcmVmMiIsImluaXRpYWxTdHlsZXMiLCJwb3NpdGlvbiIsInN0cmF0ZWd5IiwibWFyZ2luIiwiYXJyb3ciLCJzdHlsZVByb3BlcnRpZXMiLCJhdHRyaWJ1dGUiLCJlbmFibGVkIiwicGhhc2UiLCJmbiIsInJlcXVpcmVzIiwiZ2V0QmFzZVBsYWNlbWVudCIsInNwbGl0IiwibWF4IiwiTWF0aCIsIm1pbiIsInJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaW5jbHVkZVNjYWxlIiwicmVjdCIsInNjYWxlWCIsInNjYWxlWSIsIm9mZnNldEhlaWdodCIsIm9mZnNldFdpZHRoIiwid2lkdGgiLCJoZWlnaHQiLCJ4IiwieSIsImdldExheW91dFJlY3QiLCJjbGllbnRSZWN0IiwiYWJzIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsImNvbnRhaW5zIiwicGFyZW50IiwiY2hpbGQiLCJyb290Tm9kZSIsImdldFJvb3ROb2RlIiwiaXNTYW1lTm9kZSIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzVGFibGVFbGVtZW50IiwiaW5kZXhPZiIsImdldERvY3VtZW50RWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImdldFBhcmVudE5vZGUiLCJhc3NpZ25lZFNsb3QiLCJnZXRUcnVlT2Zmc2V0UGFyZW50Iiwib2Zmc2V0UGFyZW50IiwiZ2V0Q29udGFpbmluZ0Jsb2NrIiwiaXNGaXJlZm94IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImVsZW1lbnRDc3MiLCJjdXJyZW50Tm9kZSIsImNzcyIsInRyYW5zZm9ybSIsInBlcnNwZWN0aXZlIiwiY29udGFpbiIsIndpbGxDaGFuZ2UiLCJnZXRPZmZzZXRQYXJlbnQiLCJnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQiLCJ3aXRoaW4iLCJtYXRoTWF4IiwibWF0aE1pbiIsIndpdGhpbk1heENsYW1wIiwidiIsImdldEZyZXNoU2lkZU9iamVjdCIsIm1lcmdlUGFkZGluZ09iamVjdCIsInBhZGRpbmdPYmplY3QiLCJleHBhbmRUb0hhc2hNYXAiLCJoYXNoTWFwIiwidG9QYWRkaW5nT2JqZWN0IiwicGFkZGluZyIsInJlY3RzIiwiX3N0YXRlJG1vZGlmaWVyc0RhdGEkIiwiYXJyb3dFbGVtZW50IiwicG9wcGVyT2Zmc2V0cyIsIm1vZGlmaWVyc0RhdGEiLCJiYXNlUGxhY2VtZW50IiwiYXhpcyIsImlzVmVydGljYWwiLCJsZW4iLCJhcnJvd1JlY3QiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJhcnJvd09mZnNldFBhcmVudCIsImNsaWVudFNpemUiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsImNlbnRlclRvUmVmZXJlbmNlIiwiY2VudGVyIiwib2Zmc2V0IiwiYXhpc1Byb3AiLCJjZW50ZXJPZmZzZXQiLCJfb3B0aW9ucyRlbGVtZW50IiwicmVxdWlyZXNJZkV4aXN0cyIsImdldFZhcmlhdGlvbiIsInVuc2V0U2lkZXMiLCJyb3VuZE9mZnNldHNCeURQUiIsIndpbiIsImRwciIsImRldmljZVBpeGVsUmF0aW8iLCJtYXBUb1N0eWxlcyIsIl9PYmplY3QkYXNzaWduMiIsInBvcHBlclJlY3QiLCJ2YXJpYXRpb24iLCJvZmZzZXRzIiwiZ3B1QWNjZWxlcmF0aW9uIiwiYWRhcHRpdmUiLCJyb3VuZE9mZnNldHMiLCJpc0ZpeGVkIiwiX29mZnNldHMkeCIsIl9vZmZzZXRzJHkiLCJfcmVmMyIsImhhc1giLCJoYXNZIiwic2lkZVgiLCJzaWRlWSIsImhlaWdodFByb3AiLCJ3aWR0aFByb3AiLCJvZmZzZXRZIiwidmlzdWFsVmlld3BvcnQiLCJvZmZzZXRYIiwiY29tbW9uU3R5bGVzIiwiX3JlZjQiLCJfT2JqZWN0JGFzc2lnbiIsImNvbXB1dGVTdHlsZXMiLCJfcmVmNSIsIl9vcHRpb25zJGdwdUFjY2VsZXJhdCIsIl9vcHRpb25zJGFkYXB0aXZlIiwiX29wdGlvbnMkcm91bmRPZmZzZXRzIiwiZGF0YSIsInBhc3NpdmUiLCJpbnN0YW5jZSIsIl9vcHRpb25zJHNjcm9sbCIsInNjcm9sbCIsIl9vcHRpb25zJHJlc2l6ZSIsInJlc2l6ZSIsInNjcm9sbFBhcmVudHMiLCJzY3JvbGxQYXJlbnQiLCJ1cGRhdGUiLCJoYXNoIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJyZXBsYWNlIiwibWF0Y2hlZCIsImdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IiwiZ2V0V2luZG93U2Nyb2xsIiwic2Nyb2xsTGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0Vmlld3BvcnRSZWN0IiwiaHRtbCIsInRlc3QiLCJnZXREb2N1bWVudFJlY3QiLCJfZWxlbWVudCRvd25lckRvY3VtZW4iLCJ3aW5TY3JvbGwiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImRpcmVjdGlvbiIsImlzU2Nyb2xsUGFyZW50IiwiX2dldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImdldFNjcm9sbFBhcmVudCIsImxpc3RTY3JvbGxQYXJlbnRzIiwibGlzdCIsImlzQm9keSIsInVwZGF0ZWRMaXN0IiwicmVjdFRvQ2xpZW50UmVjdCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsImdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlIiwiY2xpcHBpbmdQYXJlbnQiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjYW5Fc2NhcGVDbGlwcGluZyIsImNsaXBwZXJFbGVtZW50IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJtYWluQ2xpcHBpbmdQYXJlbnRzIiwiZmlyc3RDbGlwcGluZ1BhcmVudCIsImNsaXBwaW5nUmVjdCIsImFjY1JlY3QiLCJjb21wdXRlT2Zmc2V0cyIsImNvbW1vblgiLCJjb21tb25ZIiwibWFpbkF4aXMiLCJkZXRlY3RPdmVyZmxvdyIsIl9vcHRpb25zIiwiX29wdGlvbnMkcGxhY2VtZW50IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwiYWx0Q29udGV4dCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImNvbnRleHRFbGVtZW50IiwicmVmZXJlbmNlQ2xpZW50UmVjdCIsInBvcHBlckNsaWVudFJlY3QiLCJlbGVtZW50Q2xpZW50UmVjdCIsIm92ZXJmbG93T2Zmc2V0cyIsIm9mZnNldERhdGEiLCJtdWx0aXBseSIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwiZmxpcFZhcmlhdGlvbnMiLCJfb3B0aW9ucyRhbGxvd2VkQXV0b1AiLCJhbGxvd2VkQXV0b1BsYWNlbWVudHMiLCJhbGxQbGFjZW1lbnRzIiwiYWxsb3dlZFBsYWNlbWVudHMiLCJvdmVyZmxvd3MiLCJzb3J0IiwiYSIsImIiLCJnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyIsIm9wcG9zaXRlUGxhY2VtZW50IiwiZmxpcCIsIl9za2lwIiwiX29wdGlvbnMkbWFpbkF4aXMiLCJjaGVja01haW5BeGlzIiwiX29wdGlvbnMkYWx0QXhpcyIsImFsdEF4aXMiLCJjaGVja0FsdEF4aXMiLCJzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMiLCJmYWxsYmFja1BsYWNlbWVudHMiLCJfb3B0aW9ucyRmbGlwVmFyaWF0aW8iLCJwcmVmZXJyZWRQbGFjZW1lbnQiLCJpc0Jhc2VQbGFjZW1lbnQiLCJyZWZlcmVuY2VSZWN0IiwiY2hlY2tzTWFwIiwiTWFwIiwibWFrZUZhbGxiYWNrQ2hlY2tzIiwiZmlyc3RGaXR0aW5nUGxhY2VtZW50IiwiX2Jhc2VQbGFjZW1lbnQiLCJpc1N0YXJ0VmFyaWF0aW9uIiwibWFpblZhcmlhdGlvblNpZGUiLCJhbHRWYXJpYXRpb25TaWRlIiwiY2hlY2tzIiwiZXZlcnkiLCJjaGVjayIsInNldCIsIm51bWJlck9mQ2hlY2tzIiwiX2xvb3AiLCJfaSIsImZpdHRpbmdQbGFjZW1lbnQiLCJmaW5kIiwiZ2V0Iiwic2xpY2UiLCJfcmV0IiwicmVzZXQiLCJnZXRTaWRlT2Zmc2V0cyIsInByZXZlbnRlZE9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzb21lIiwic2lkZSIsImhpZGUiLCJwcmV2ZW50T3ZlcmZsb3ciLCJyZWZlcmVuY2VPdmVyZmxvdyIsInBvcHBlckFsdE92ZXJmbG93IiwicmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzIiwicG9wcGVyRXNjYXBlT2Zmc2V0cyIsImlzUmVmZXJlbmNlSGlkZGVuIiwiaGFzUG9wcGVyRXNjYXBlZCIsImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZIiwiaW52ZXJ0RGlzdGFuY2UiLCJza2lkZGluZyIsImRpc3RhbmNlIiwiX29wdGlvbnMkb2Zmc2V0IiwiX2RhdGEkc3RhdGUkcGxhY2VtZW50IiwiZ2V0QWx0QXhpcyIsIl9vcHRpb25zJHRldGhlciIsInRldGhlciIsIl9vcHRpb25zJHRldGhlck9mZnNldCIsInRldGhlck9mZnNldCIsInRldGhlck9mZnNldFZhbHVlIiwibm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlIiwib2Zmc2V0TW9kaWZpZXJTdGF0ZSIsIl9vZmZzZXRNb2RpZmllclN0YXRlJCIsIm1haW5TaWRlIiwiYWx0U2lkZSIsImFkZGl0aXZlIiwibWluTGVuIiwibWF4TGVuIiwiYXJyb3dQYWRkaW5nT2JqZWN0IiwiYXJyb3dQYWRkaW5nTWluIiwiYXJyb3dQYWRkaW5nTWF4IiwiYXJyb3dMZW4iLCJtaW5PZmZzZXQiLCJtYXhPZmZzZXQiLCJjbGllbnRPZmZzZXQiLCJvZmZzZXRNb2RpZmllclZhbHVlIiwidGV0aGVyTWluIiwidGV0aGVyTWF4IiwicHJldmVudGVkT2Zmc2V0IiwiX29mZnNldE1vZGlmaWVyU3RhdGUkMiIsIl9tYWluU2lkZSIsIl9hbHRTaWRlIiwiX29mZnNldCIsIl9sZW4iLCJfbWluIiwiX21heCIsImlzT3JpZ2luU2lkZSIsIl9vZmZzZXRNb2RpZmllclZhbHVlIiwiX3RldGhlck1pbiIsIl90ZXRoZXJNYXgiLCJfcHJldmVudGVkT2Zmc2V0IiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiaXNFbGVtZW50U2NhbGVkIiwiZ2V0Q29tcG9zaXRlUmVjdCIsImVsZW1lbnRPclZpcnR1YWxFbGVtZW50IiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsIm9yZGVyIiwibW9kaWZpZXJzIiwidmlzaXRlZCIsIlNldCIsInJlc3VsdCIsIm1vZGlmaWVyIiwiYWRkIiwiZGVwIiwiaGFzIiwiZGVwTW9kaWZpZXIiLCJvcmRlck1vZGlmaWVycyIsIm9yZGVyZWRNb2RpZmllcnMiLCJkZWJvdW5jZSIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJtZXJnZUJ5TmFtZSIsIm1lcmdlZCIsImN1cnJlbnQiLCJleGlzdGluZyIsIkRFRkFVTFRfT1BUSU9OUyIsImFyZVZhbGlkRWxlbWVudHMiLCJfa2V5IiwicG9wcGVyR2VuZXJhdG9yIiwiZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zIiwiX2dlbmVyYXRvck9wdGlvbnMkZGVmIiwiZGVmYXVsdE1vZGlmaWVycyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZjIiLCJkZWZhdWx0T3B0aW9ucyIsImNyZWF0ZVBvcHBlciIsImVmZmVjdENsZWFudXBGbnMiLCJpc0Rlc3Ryb3llZCIsInNldE9wdGlvbnMiLCJzZXRPcHRpb25zQWN0aW9uIiwiY2xlYW51cE1vZGlmaWVyRWZmZWN0cyIsIm0iLCJydW5Nb2RpZmllckVmZmVjdHMiLCJmb3JjZVVwZGF0ZSIsIl9zdGF0ZSRlbGVtZW50cyIsIl9zdGF0ZSRvcmRlcmVkTW9kaWZpZSIsIl9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIiLCJkZXN0cm95Iiwib25GaXJzdFVwZGF0ZSIsIl9yZWYzJG9wdGlvbnMiLCJjbGVhbnVwRm4iLCJub29wRm4iLCJldmVudExpc3RlbmVycyIsIl9nZXRDZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIiLCJnZW5lcmF0ZUZvY3VzQWZ0ZXJSZW5kZXJNb2RpZmllciIsInNldFRpbWVvdXQiLCJmb2N1c09wdGlvbnMiLCJwcmV2ZW50U2Nyb2xsIiwiZm9jdXMiLCJtYWtlQ2VudGVyZWRQb3BwZXIiLCJjZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIiLCJwb3BwZXJPcHRpb25zIiwiZnJvbSIsIm5vcm1hbGl6ZVByZWZpeCIsInByZWZpeCIsImNoYXJBdCIsInBhcnNlQXR0YWNoVG8iLCJhdHRhY2hUbyIsInJldHVybk9wdHMiLCJzaG91bGRDZW50ZXJTdGVwIiwicmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMiLCJzZXR1cFRvb2x0aXAiLCJ0b29sdGlwIiwiYXR0YWNoVG9PcHRpb25zIiwiX2dldFJlc29sdmVkQXR0YWNoVG9PcHRpb25zIiwiZ2V0UG9wcGVyT3B0aW9ucyIsImNvbnRlbnQiLCJzaGVwaGVyZEVsZW1lbnRDb21wb25lbnQiLCJnZXRFbGVtZW50IiwiY2xhc3NMaXN0IiwidXVpZCIsImQiLCJEYXRlIiwibm93IiwiYyIsInIiLCJyYW5kb20iLCJmbG9vciIsImRlZmF1bHRTdGVwT3B0aW9ucyIsIl9tZXJnZU1vZGlmaWVycyIsInN0ZXBPcHRpb25zIiwibWVyZ2VkUG9wcGVyT3B0aW9ucyIsIm5hbWVzIiwibW9kIiwiZmlsdGVyZWRNb2RpZmllcnMiLCJpbmNsdWRlcyIsIm5vb3AiLCJ0YXIiLCJzcmMiLCJrIiwicnVuIiwiYmxhbmtfb2JqZWN0IiwiY3JlYXRlIiwicnVuX2FsbCIsImZucyIsImlzX2Z1bmN0aW9uIiwidGhpbmciLCJzYWZlX25vdF9lcXVhbCIsImlzX2VtcHR5Iiwib2JqIiwiYXBwZW5kIiwiYXBwZW5kQ2hpbGQiLCJpbnNlcnQiLCJhbmNob3IiLCJpbnNlcnRCZWZvcmUiLCJkZXRhY2giLCJyZW1vdmVDaGlsZCIsImRlc3Ryb3lfZWFjaCIsIml0ZXJhdGlvbnMiLCJkZXRhY2hpbmciLCJjcmVhdGVFbGVtZW50Iiwic3ZnX2VsZW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJ0ZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJzcGFjZSIsImVtcHR5IiwibGlzdGVuIiwiYXR0ciIsImdldEF0dHJpYnV0ZSIsInNldF9hdHRyaWJ1dGVzIiwiZGVzY3JpcHRvcnMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiX19wcm90b19fIiwiY3NzVGV4dCIsImNoaWxkcmVuIiwiY2hpbGROb2RlcyIsInRvZ2dsZV9jbGFzcyIsInRvZ2dsZSIsImN1cnJlbnRfY29tcG9uZW50Iiwic2V0X2N1cnJlbnRfY29tcG9uZW50IiwiY29tcG9uZW50IiwiZ2V0X2N1cnJlbnRfY29tcG9uZW50Iiwib25Nb3VudCIsIiQkIiwib25fbW91bnQiLCJhZnRlclVwZGF0ZSIsImFmdGVyX3VwZGF0ZSIsImRpcnR5X2NvbXBvbmVudHMiLCJiaW5kaW5nX2NhbGxiYWNrcyIsInJlbmRlcl9jYWxsYmFja3MiLCJmbHVzaF9jYWxsYmFja3MiLCJyZXNvbHZlZF9wcm9taXNlIiwidXBkYXRlX3NjaGVkdWxlZCIsInNjaGVkdWxlX3VwZGF0ZSIsImZsdXNoIiwiYWRkX3JlbmRlcl9jYWxsYmFjayIsInNlZW5fY2FsbGJhY2tzIiwiZmx1c2hpZHgiLCJzYXZlZF9jb21wb25lbnQiLCJwb3AiLCJjYWxsYmFjayIsImNsZWFyIiwiZnJhZ21lbnQiLCJiZWZvcmVfdXBkYXRlIiwiZGlydHkiLCJwIiwib3V0cm9pbmciLCJvdXRyb3MiLCJncm91cF9vdXRyb3MiLCJjaGVja19vdXRyb3MiLCJ0cmFuc2l0aW9uX2luIiwiYmxvY2siLCJsb2NhbCIsImRlbGV0ZSIsInRyYW5zaXRpb25fb3V0IiwibyIsImdldF9zcHJlYWRfdXBkYXRlIiwibGV2ZWxzIiwidXBkYXRlcyIsInRvX251bGxfb3V0IiwiYWNjb3VudGVkX2ZvciIsIiQkc2NvcGUiLCJuIiwiY3JlYXRlX2NvbXBvbmVudCIsIm1vdW50X2NvbXBvbmVudCIsImN1c3RvbUVsZW1lbnQiLCJvbl9kZXN0cm95IiwibmV3X29uX2Rlc3Ryb3kiLCJkZXN0cm95X2NvbXBvbmVudCIsIm1ha2VfZGlydHkiLCJmaWxsIiwiaW5pdCIsImNyZWF0ZV9mcmFnbWVudCIsIm5vdF9lcXVhbCIsInByb3BzIiwiYXBwZW5kX3N0eWxlcyIsInBhcmVudF9jb21wb25lbnQiLCJib3VuZCIsIm9uX2Rpc2Nvbm5lY3QiLCJjYWxsYmFja3MiLCJza2lwX2JvdW5kIiwicm9vdCIsInJlYWR5IiwicmV0IiwiaHlkcmF0ZSIsIm5vZGVzIiwibCIsImludHJvIiwiU3ZlbHRlQ29tcG9uZW50IiwiJGRlc3Ryb3kiLCIkb24iLCJ0eXBlIiwiJHNldCIsIiQkcHJvcHMiLCIkJHNldCIsImFjdGlvbiIsImNsYXNzZXMiLCJkaXNhYmxlZCIsImxhYmVsIiwic2Vjb25kYXJ5Iiwib3B0aW9uIiwiJCRpbnZhbGlkYXRlIiwiY29uZmlnIiwiZ2V0Q29uZmlnT3B0aW9uIiwiY3JlYXRlX2lmX2Jsb2NrIiwiJCIsImJ1dHRvbnMiLCJoYW5kbGVDYW5jZWxDbGljayIsInByZXZlbnREZWZhdWx0IiwiY2FuY2VsIiwibGFiZWxJZCIsInRpdGxlIiwiaW5uZXJIVE1MIiwiY3JlYXRlX2lmX2Jsb2NrXzEiLCJjYW5jZWxJY29uIiwiZGVzY3JpcHRpb25JZCIsInNob3dfaWZfMiIsInNob3dfaWZfMSIsInNob3dfaWYiLCJjbGFzc05hbWUiLCJmaXJzdEZvY3VzYWJsZUVsZW1lbnQiLCJmb2N1c2FibGVFbGVtZW50cyIsImxhc3RGb2N1c2FibGVFbGVtZW50IiwiZGF0YVN0ZXBJZCIsImhhc0NhbmNlbEljb24iLCJoYXNUaXRsZSIsImNsYXNzUHJlZml4IiwiaWQiLCJxdWVyeVNlbGVjdG9yQWxsIiwidXBkYXRlRHluYW1pY0NsYXNzZXMiLCJyZW1vdmVDbGFzc2VzIiwiYWRkQ2xhc3NlcyIsIm9sZENsYXNzZXMiLCJnZXRDbGFzc2VzQXJyYXkiLCJyZW1vdmUiLCJuZXdDbGFzc2VzIiwiaGFuZGxlS2V5RG93biIsImtleUNvZGUiLCJLRVlfVEFCIiwic2hpZnRLZXkiLCJhY3RpdmVFbGVtZW50IiwiS0VZX0VTQyIsImV4aXRPbkVzYyIsIkxFRlRfQVJST1ciLCJrZXlib2FyZE5hdmlnYXRpb24iLCJiYWNrIiwiUklHSFRfQVJST1ciLCJwb2x5ZmlsbCIsInciLCJfX2ZvcmNlU21vb3RoU2Nyb2xsUG9seWZpbGxfXyIsIlNDUk9MTF9USU1FIiwib3JpZ2luYWwiLCJzY3JvbGxUbyIsInNjcm9sbEJ5IiwiZWxlbWVudFNjcm9sbCIsInNjcm9sbEVsZW1lbnQiLCJzY3JvbGxJbnRvVmlldyIsInBlcmZvcm1hbmNlIiwiaXNNaWNyb3NvZnRCcm93c2VyIiwidXNlckFnZW50UGF0dGVybnMiLCJSZWdFeHAiLCJqb2luIiwiUk9VTkRJTkdfVE9MRVJBTkNFIiwiZWFzZSIsImNvcyIsIlBJIiwic2hvdWxkQmFpbE91dCIsImZpcnN0QXJnIiwiYmVoYXZpb3IiLCJUeXBlRXJyb3IiLCJoYXNTY3JvbGxhYmxlU3BhY2UiLCJjYW5PdmVyZmxvdyIsIm92ZXJmbG93VmFsdWUiLCJpc1Njcm9sbGFibGUiLCJpc1Njcm9sbGFibGVZIiwiaXNTY3JvbGxhYmxlWCIsImZpbmRTY3JvbGxhYmxlUGFyZW50IiwidGltZSIsImN1cnJlbnRYIiwiY3VycmVudFkiLCJlbGFwc2VkIiwic3RhcnRUaW1lIiwic3RhcnRYIiwic3RhcnRZIiwibWV0aG9kIiwic2Nyb2xsYWJsZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNtb290aFNjcm9sbCIsInNjcm9sbFgiLCJzY3JvbGxZIiwiU3ludGF4RXJyb3IiLCJzY3JvbGxhYmxlUGFyZW50IiwicGFyZW50UmVjdHMiLCJjbGllbnRSZWN0cyIsIm1vZHVsZSIsInNtb290aHNjcm9sbCIsIlN0ZXAiLCJfcmVzb2x2ZWRBdHRhY2hUbyIsIl9zZXRPcHRpb25zIiwiY29tcGxldGUiLCJfdXBkYXRlU3RlcFRhcmdldE9uSGlkZSIsImdldFRvdXIiLCJtb2RhbCIsImhpZGRlbiIsIl9yZXNvbHZlQXR0YWNoVG9PcHRpb25zIiwiQm9vbGVhbiIsInNob3ciLCJiZWZvcmVTaG93UHJvbWlzZSIsIl9zaG93IiwidXBkYXRlU3RlcE9wdGlvbnMiLCJnZXRUYXJnZXQiLCJfY3JlYXRlVG9vbHRpcENvbnRlbnQiLCJTaGVwaGVyZEVsZW1lbnQiLCJzdGVwc0NvbnRhaW5lciIsIl9zY3JvbGxUbyIsInNjcm9sbFRvT3B0aW9ucyIsInNjcm9sbFRvSGFuZGxlciIsIl9nZXRDbGFzc09wdGlvbnMiLCJzdGVwQ2xhc3NlcyIsImRlZmF1bHRTdGVwT3B0aW9uc0NsYXNzZXMiLCJhbGxDbGFzc2VzIiwidW5pcUNsYXNzZXMiLCJ0cmltIiwidG91ck9wdGlvbnMiLCJtZXJnZSIsIndoZW4iLCJfc2V0dXBFbGVtZW50cyIsIl9zZXR1cE1vZGFsIiwic2V0dXBGb3JTdGVwIiwiX3N0eWxlVGFyZ2V0RWxlbWVudEZvclN0ZXAiLCJ0YXJnZXRFbGVtZW50IiwiaGlnaGxpZ2h0Q2xhc3MiLCJjYW5DbGlja1RhcmdldCIsImNsZWFudXBTdGVwcyIsInN0ZXBzIiwibWFrZU92ZXJsYXlQYXRoIiwiaW5uZXJXaWR0aCIsImgiLCJpbm5lckhlaWdodCIsImlzSHRtbEVsZW1lbnQiLCJfZ2V0U2Nyb2xsUGFyZW50IiwicGFyZW50RWxlbWVudCIsIl9nZXRWaXNpYmxlSGVpZ2h0IiwiZWxlbWVudFJlY3QiLCJzY3JvbGxSZWN0Iiwic2Nyb2xsQm90dG9tIiwib3BlbmluZ1Byb3BlcnRpZXMiLCJwYXRoRGVmaW5pdGlvbiIsImNsb3NlTW9kYWxPcGVuaW5nIiwiX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMiLCJwb3NpdGlvbk1vZGFsIiwibW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmciLCJtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzIiwidXNlTW9kYWxPdmVybGF5IiwiX3N0eWxlRm9yU3RlcCIsIl9wcmV2ZW50TW9kYWxCb2R5VG91Y2giLCJfcHJldmVudE1vZGFsT3ZlcmxheVRvdWNoIiwic3RvcFByb3BhZ2F0aW9uIiwiX2FkZFN0ZXBFdmVudExpc3RlbmVycyIsInJhZklkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyYWZMb29wIiwiU2hlcGhlcmQiLCJUb3VyIiwiZGVmYXVsdFRvdXJPcHRpb25zIiwiYWRkU3RlcHMiLCJldmVudHMiLCJvcHRzIiwiX3NldFRvdXJJRCIsImFkZFN0ZXAiLCJjdXJyZW50U3RlcCIsImNvbmZpcm1DYW5jZWwiLCJjYW5jZWxNZXNzYWdlIiwiY29uZmlybUNhbmNlbE1lc3NhZ2UiLCJzdG9wVG91ciIsImNvbmZpcm0iLCJfZG9uZSIsImdldEJ5SWQiLCJnZXRDdXJyZW50U3RlcCIsImlzQWN0aXZlIiwiYWN0aXZlVG91ciIsInJlbW92ZVN0ZXAiLCJmb3J3YXJkIiwiX3VwZGF0ZVN0YXRlQmVmb3JlU2hvdyIsInNob3VsZFNraXBTdGVwIiwic2hvd09uIiwiX3NraXBTdGVwIiwicHJldmlvdXMiLCJmb2N1c2VkRWxCZWZvcmVPcGVuIiwiX3NldHVwQWN0aXZlVG91ciIsIm1vZGFsQ29udGFpbmVyIiwiU2hlcGhlcmRNb2RhbCIsIm5leHRJbmRleCIsInRvdXJOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/shepherd.js/dist/js/shepherd.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/shepherd/shepherd.js");
/******/ 	var __webpack_export_target__ = window;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;