<?xml version="1.0" encoding="ISO-8859-1" ?>
<!-- $Id: mock_objects_tutorial.xml 1701 2008-03-24 20:08:06Z pp11 $ -->
<page title="Objets fantaisie" here="Utiliser des objets fantaisie">
    <synchronisation lang="en" version="1687" date="24/03/2008" maintainer="pp11" />
    <long_title>tutorial sur les tests unitaires en PHP - Utiliser les objets fantaisie en PHP</long_title>
    <content>
        <section name="remaniement" title="Remanier les tests à nouveau">
            <p>
                Avant d'ajouter de nouvelles fonctionnalités
                il y a du remaniement à faire.
                Nous allons effectuer des tests chronométrés
                et la classe <code>TimeTestCase</code> a définitivement
                besoin d'un fichier propre.
                Appelons le <em>tests/time_test_case.php</em>...
<php><![CDATA[
<strong><?php
if (! defined('SIMPLE_TEST')) {
    define('SIMPLE_TEST', 'simpletest/');
}
require_once(SIMPLE_TEST . 'unit_tester.php');

class TimeTestCase extends UnitTestCase {
    function TimeTestCase($test_name = '') {
        $this->UnitTestCase($test_name);
    }
    function assertSameTime($time1, $time2, $message = '') {
        if (! $message) {
            $message = "Time [$time1] should match time [$time2]";
        }
        $this->assertTrue(
                ($time1 == $time2) || ($time1 + 1 == $time2),
                $message);
    }
}
?></strong>
]]></php>
                Nous pouvons lors utiliser <code>require()</code>
                pour incorporer ce fichier dans le script <em>all_tests.php</em>.
            </p>
        </section>
        <section name="timestamp" title="Ajouter un timestamp au Log">
            <p>
                Je ne sais pas trop quel devrait être
                le format du message de log pour le test alors
                pour vérifier le timestamp nous pourrions juste
                faire la plus simple des choses possibles,
                c'est à dire rechercher une suite de chiffres.
<php><![CDATA[
<?php
require_once('../classes/log.php');<strong>
require_once('../classes/clock.php');

class TestOfLogging extends TimeTestCase {
    function TestOfLogging() {
        $this->TimeTestCase('Log class test');
    }</strong>
    function setUp() {
        @unlink('../temp/test.log');
    }
    function tearDown() {
        @unlink('../temp/test.log');
    }
    function getFileLine($filename, $index) {
        $messages = file($filename);
        return $messages[$index];
    }
    function testCreatingNewFile() {
        ...
    }
    function testAppendingToFile() {
        ...
    }<strong>
    function testTimestamps() {
        $log = new Log('../temp/test.log');
        $log->message('Test line');
        $this->assertTrue(
                preg_match('/(\d+)/', $this->getFileLine('../temp/test.log', 0), $matches),
                'Found timestamp');
        $clock = new clock();
        $this->assertSameTime((integer)$matches[1], $clock->now(), 'Correct time');
    }</strong>
}
?>
]]></php>
                Ce scénario de test crée un nouvel objet <code>Log</code>
                et écrit un message. Nous recherchons une suite de chiffres
                et nous la comparons à l'horloge présente en utilisant
                notre objet <code>Clock</code>. Bien sûr ça ne marche pas
                avant d'avoir écrit le code.
                <div class="demo">
                    <h1>All tests</h1>
                    <span class="pass">Pass</span>: log_test.php->Log class test->testappendingtofile->Expecting [/Test line 1/] in [Test line 1]<br />
                    <span class="pass">Pass</span>: log_test.php->Log class test->testappendingtofile->Expecting [/Test line 2/] in [Test line 2]<br />
                    <span class="pass">Pass</span>: log_test.php->Log class test->testcreatingnewfile->Created before message<br />
                    <span class="pass">Pass</span>: log_test.php->Log class test->testcreatingnewfile->File created<br />
                    <span class="fail">Fail</span>: log_test.php->Log class test->testtimestamps->Found timestamp<br />
                    <br />
                    <b>Notice</b>:  Undefined offset:  1 in <b>/home/marcus/projects/lastcraft/tutorial_tests/tests/log_test.php</b> on line <b>44</b><br />
                    <span class="fail">Fail</span>: log_test.php->Log class test->testtimestamps->Correct time<br />
                    <span class="pass">Pass</span>: clock_test.php->Clock class test->testclockadvance->Advancement<br />
                    <span class="pass">Pass</span>: clock_test.php->Clock class test->testclocktellstime->Now is the right time<br />
                    <div style="padding: 8px; margin-top: 1em; background-color: red; color: white;">3/3 test cases complete.
                    <strong>6</strong> passes and <strong>2</strong> fails.</div>
                </div>
                Cette suite de tests montre encore les succès
                de notre modification précédente.
            </p>
            <p>
                Nous pouvons faire passer les tests en ajoutant
                simplement un timestamp à l'écriture dans le fichier.
                Oui, bien sûr, tout ceci est assez trivial et d'habitude
                je ne le testerais pas aussi fanatiquement,
                mais ça va illustrer un problème plus général...
                Le fichier <em>log.php</em> devient...
<php><![CDATA[
<?php<strong>
require_once('../classes/clock.php');</strong>

class Log {
    var $_file_path;
    
    function Log($file_path) {
        $this->_file_path = $file_path;
    }
    
    function message($message) {<strong>
        $clock = new Clock();</strong>
        $file = fopen($this->_file_path, 'a');<strong>
        fwrite($file, "[" . $clock->now() . "] $message\n");</strong>
        fclose($file);
    }
}
?>
]]></php>
                Les tests devraient passer.
            </p>
            <p>
                Par contre notre nouveau test est plein de problèmes.
                Qu'est-ce qui se passe si notre format de temps change ?
                Les choses vont devenir largement plus compliquées
                si ça venait à se produire.
                Cela veut aussi dire que n'importe quel changement
                du format de notre classe horloge causera aussi
                un échec dans les tests de log.
                Bilan : nos tests de log sont tout mélangés
                avec les test d'horloge et par la même très fragiles.
                Tester à la fois des facettes de l'horloge
                et d'autres du log manque de cohésion,
                ou de focalisation étanche si vous préférez.
                Nos problèmes sont causés en partie parce que
                le résultat de l'horloge est imprévisible alors que
                l'unique chose à tester est la présence
                du résultat de <code>Clock::now()</code>.
                Peu importe le contenu de l'appel de cette méthode.
            </p>
            <p>
                Pouvons-nous rendre cet appel prévisible ?
                Oui si nous pouvons forcer le loggueur à utiliser
                une version factice de l'horloge lors du test.
                Cette classe d'horloge factice devrait se comporter
                exactement comme la classe <code>Clock</code>
                à part une sortie fixée dans la méthode <code>now()</code>.
                Et au passage, ça nous affranchirait même
                de la classe <code>TimeTestCase</code> !
            </p>
            <p>
                Nous pourrions écrire une telle classe assez
                facilement même s'il s'agit d'un boulot plutôt fastidieux.
                Nous devons juste créer une autre classe
                d'horloge avec la même interface sauf que
                la méthode <code>now()</code> retourne une valeur modifiable
                via une autre méthode d'initialisation.
                C'est plutôt pas mal de travail pour un test plutôt mineur.
            </p>
            <p>
                Sauf que ça se fait sans aucun effort.
            </p>
        </section>
        <section name="fantaisie" title="Une horloge fantaisie">
            <p>
                Pour atteindre le nirvana de l'horloge instantané
                pour test nous n'avons besoin que de trois lignes de code supplémentaires...
<php><![CDATA[
require_once('simpletest/mock_objects.php');
]]></php>
                Cette instruction inclut le code de générateur
                d'objet fantaisie. Le plus simple reste de le mettre
                dans le script <em>all_tests.php</em> étant donné
                qu'il est utilisé assez fréquemment.
<php><![CDATA[
Mock::generate('Clock');
]]></php>
                C'est la ligne qui fait le travail.
                Le générateur de code scanne la classe,
                en extrait toutes ses méthodes, crée le code
                pour générer une classe avec une interface identique,
                mais en ajoutant le nom &quot;Mock&quot;
                et ensuite <code>eval()</code> le nouveau code pour créer la nouvelle classe.
<php><![CDATA[
$clock = &new MockClock($this);
]]></php>
                Cette ligne peut être ajoutée dans n'importe
                quelle méthode de test qui nous intéresserait.
                Elle crée l'horloge fantaisie prête à recevoir nos instructions.
            </p>
            <p>
                Notre scénario de test en est à ses premiers pas
                vers un nettoyage radical...
<php><![CDATA[
<?php
require_once('../classes/log.php');
require_once('../classes/clock.php');<strong>
Mock::generate('Clock');

class TestOfLogging extends UnitTestCase {
    function TestOfLogging() {
        $this->UnitTestCase('Log class test');
    }</strong>
    function setUp() {
        @unlink('../temp/test.log');
    }
    function tearDown() {
        @unlink('../temp/test.log');
    }
    function getFileLine($filename, $index) {
        $messages = file($filename);
        return $messages[$index];
    }
    function testCreatingNewFile() {
        ...
    }
    function testAppendingToFile() {
        ...
    }
    function testTimestamps() {<strong>
        $clock = &new MockClock($this);
        $clock->setReturnValue('now', 'Timestamp');
        $log = new Log('../temp/test.log');
        $log->message('Test line', &$clock);
        $this->assertWantedPattern(
                '/Timestamp/',
                $this->getFileLine('../temp/test.log', 0),
                'Found timestamp');</strong>
    }
}
?>
]]></php>
                Cette méthode de test crée un objet <code>MockClock</code>
                puis définit la valeur retourné par la méthode
                <code>now()</code> par la chaîne &quot;Timestamp&quot;.
                A chaque fois que nous appelons <code>$clock->now()</code>,
                elle retournera cette même chaîne.
                Ça devrait être quelque chose de facilement repérable.
            </p>
            <p>
                Ensuite nous créons notre loggueur et envoyons un message.
                Nous incluons dans l'appel <code>message()</code>
                l'horloge que nous souhaitons utiliser.
                Ça veut dire que nous aurons à ajouter un paramètre
                optionnel à la classe de log pour rendre ce test possible...
<php><![CDATA[
class Log {
    var $_file_path;
    
    function Log($file_path) {
        $this->_file_path = $file_path;
    }
    
    function message($message, <strong>$clock = false</strong>) {<strong>
        if (!is_object($clock)) {
            $clock = new Clock();
        }</strong>
        $file = fopen($this->_file_path, 'a');
        fwrite($file, "[" . $clock->now() . "] $message\n");
        fclose($file);
    }
}
]]></php>
                Maintenant tous les tests passent et ils ne testent
                que le code du loggueur. Nous pouvons à nouveau respirer.
            </p>
            <p>
                Est-ce que ce paramètre supplémentaire dans la classe <code>Log</code>
                vous gêne ? Nous n'avons changé l'interface que
                pour faciliter les tests après tout.
                Les interfaces ne sont-elles pas la chose la plus importante ?
                Avons nous souillé notre classe avec du code de test ?
            </p>
            <p>
                Peut-être, mais réfléchissez à ce qui suit.
                A la prochaine occasion,
                regardez une carte avec des circuits imprimés,
                peut-être la carte mère de l'ordinateur que 
                ous regardez actuellement. Sur la plupart d'entre elles
                vous trouverez un trou bizarre et vide
                ou alors un point de soudure sans rien de fixé
                ou même une épingle ou une prise sans aucune fonction évidente.
                Peut-être certains sont là en prévision d'une expansion
                ou d'une variation future, mais la plupart n'y sont que pour les tests.
            </p>
            <p>
                Pensez-y. Les usines qui fabriquent ces cartes imprimées
                par centaine de milliers gaspillent des matières premières
                sur des pièces qui n'ajoutent rien à la fonction finale.
                Si les ingénieurs matériel peuvent faire quelques sacrifices
                à l'élégance, je suis sûr que nous pouvons aussi le faire.
                Notre sacrifice ne gaspille pas de matériel après tout.
            </p>
            <p>
                Ça vous gêne encore ? En fait moi aussi, mais pas tellement ici.
                La priorité numéro 1 reste du code qui marche,
                pas un prix pour minimalisme.
                Si ça vous gêne vraiment alors déplacez la création
                de l'horloge dans une autre méthode mère protégée.
                Ensuite sous classez l'horloge pour le test
                et écrasez la méthode mère avec une qui renvoie le leurre.
                Vos tests sont bancals mais votre interface est intacte.
            </p>
            <p>
                Une nouvelle fois je vous laisse la décision finale.
            </p>
        </section>
    </content>
    <internal>
        <link>
            <a href="#remaniement">Remanier les tests</a>
            dans le but de réutiliser notre nouveau test de temps.
        </link>
        <link>
            Ajouter des <a href="#timestamp">timestamps de Log</a>.
        </link>
        <link>
            <a href="#fantaisie">Créer une horloge fantaisie</a>
            pour rendre les tests cohésifs.
        </link>
    </internal>
    <external>
        <link>
            La section précédente :
            <a href="first_test_tutorial.php">tutorial de test unitaire</a>.
        </link>
        <link>
            La section suivante :
            <a href="boundary_classes_tutorial.php">les frontières de l'application</a>.
        </link>
        <link>
            Vous aurez besoin du
            <a href="simple_test.php">framework de test SimpleTest</a>
            pour essayer ces exemples.
        </link>
        <link>
            Documents sur les <a href="http://www.mockobjects.com/">objets fantaisie</a>.
        </link>
    </external>
    <meta>
        <keywords>
            développement logiciel,
            programmation php,
            outils de développement logiciel,
            tutoriel php,
            scripts php gratuits,
            architecture,
            ressources php,
            objet fantaisie,
            junit,
            phpunit,
            simpletest,
            test php,
            outil de test unitaire,
            suite de test php
        </keywords>
    </meta>
</page>

